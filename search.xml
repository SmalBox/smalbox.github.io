<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity热更及AB包切分分享笔记</title>
      <link href="2021/06/27/unity-re-geng-ji-ab-bao-qie-fen-fen-xiang-bi-ji/"/>
      <url>2021/06/27/unity-re-geng-ji-ab-bao-qie-fen-fen-xiang-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity热更及AB包切分分享笔记"><a href="#Unity热更及AB包切分分享笔记" class="headerlink" title="Unity热更及AB包切分分享笔记"></a>Unity热更及AB包切分分享笔记</h1><p>本文主要整理了在分享时的关键点。分享主要包括两个方面：1.热更时的各个方面注意点。2.AB包切分时改怎么规划组织切分打包AB包。</p><h2 id="更新机制"><a href="#更新机制" class="headerlink" title="更新机制"></a>更新机制</h2><ul><li>先看思路图：<ul><li><img src="/2021/06/27/unity-re-geng-ji-ab-bao-qie-fen-fen-xiang-bi-ji/%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6.png" alt="更新机制脑图"><h3 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h3><h4 id="提审"><a href="#提审" class="headerlink" title="提审"></a>提审</h4></li></ul></li><li>这里涉及到在不同渠道同时更新时，每个平台审核进度不一，会影响更新包的更新进度。<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><h4 id="包版本号"><a href="#包版本号" class="headerlink" title="包版本号"></a>包版本号</h4></li><li>一般是两位，例如1.9<h4 id="代码版本号"><a href="#代码版本号" class="headerlink" title="代码版本号"></a>代码版本号</h4></li><li>首先的问题，为什么要热更代码，最现实的问题就是成本问题，每一次重装的大更后台数据显示会有10%左右的人数掉落。相对于现阶段的获客成本来说是相当大的损失。</li><li>代码版本号一般为3位，例如1.9.1</li><li>包版本补丁和资源版本，都以代码版本为标准进行更新。<h4 id="资源版本号"><a href="#资源版本号" class="headerlink" title="资源版本号"></a>资源版本号</h4></li><li>一般是3位，主要跟随代码版本号和活动进行更新。</li></ul><h2 id="AB包分类"><a href="#AB包分类" class="headerlink" title="AB包分类"></a>AB包分类</h2><ul><li>同样先看图：<ul><li><img src="/2021/06/27/unity-re-geng-ji-ab-bao-qie-fen-fen-xiang-bi-ji/AB%E5%8C%85%E5%88%86%E7%B1%BB.png" alt="AB包分类"><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3></li></ul></li><li>每个字体一个AB包。<h3 id="图集"><a href="#图集" class="headerlink" title="图集"></a>图集</h3></li><li>一个图集一个AB包。<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3></li><li>场景相对有些复杂</li><li>场景包括很多资源，比如Shader、模型、图片等</li><li>一般来讲一个场景一个AB包，逻辑如下：<ul><li><img src="/2021/06/27/unity-re-geng-ji-ab-bao-qie-fen-fen-xiang-bi-ji/%E5%9C%BA%E6%99%AF%E5%88%86%E5%8C%85%E9%80%BB%E8%BE%91%E5%9B%BE.png" alt="场景分包逻辑图"></li></ul></li><li>其中Shader作为基础。</li><li>上一层的SceneCommen是通过工具在各个场景中找出的公用资源计算出来的。</li><li>再往上按照大场景的公共资源提取出来。</li><li>最后再每个小场景进行单独打AB包。<h3 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h3></li><li>两种策略<ol><li>当所涉及到的shader没有很多时，所有shader打一个AB包即可。</li><li>当shader比较大，能有几十m的时候就要考虑分版本增量打包。<h3 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h3></li></ol></li><li>所有特效一个AB包。</li><li>其中包括 UI、Scene、Model 的特效都打成一个AB包，加载后常驻内存，可快速调用。<h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3></li><li>按照美术规划目录打AB包。<h3 id="Animator"><a href="#Animator" class="headerlink" title="Animator"></a>Animator</h3></li><li>一个Animator一个AB包。<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3></li><li>动画一般跟着模型走，单独动画一个state一个AB包。</li><li>动画很占用内存，必要时要压缩Anim<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3></li><li>一个模型一个AB包。</li></ul><h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h2><ul><li>资源池<ul><li>每个加载的资源会给其一个计数器，当计数器为0时压入资源池。当资源池达到给定的上限时，会指定最老的资源对其释放。</li><li>一般来讲资源的释放会在新资源加载时进行。</li><li>在切换场景时会释放所有池中资源。只保留跨场景不清除的数据。</li></ul></li><li>如何正确释放资源<ul><li>不要使用Unity的Resources.UnloadUnusedAssets这个方法来图省事清理内存。这会让引擎线搜索所有资源然后再释放，会导致释放过程有明显卡顿。</li><li>适当使用System.GC.Collect来进行回收堆中内存。</li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>多人网络游戏同步机制<ul><li>帧同步<ul><li>一般用在人数少、操作较为固定、强击打类游戏中使用。</li></ul></li><li>状态同步<ul><li>在人数较多时会使用状态同步，记录每个发生的状态，并且在服务器中做核验计算。</li><li>必要时在服务器端会做“延迟补偿”来对比收到的数据的前N秒的所有状态数据对比是否发生响应事件。</li><li>对于游戏中的回放功能，状态同步是将状态数据重放来实现回放功能，而不是去真的录制正常游戏。</li></ul></li></ul></li><li>移动端游对服务器的需求<ul><li>“大逃杀类”游戏在性能测试时得到平均56核处理器能保证同时80场游戏运行。</li><li>“Dota类”游戏1个核心能同时处理16场游戏的计算。</li></ul></li><li>热更方面，Android目前可以做到IL2CPP全热更，具体可以参考<a href="https://github.com/noodle1983/UnityAndroidIl2cppPatchDemo">这个库</a></li><li>IOS目前官方肯定是要禁止所有热更，以防止有利用其绕过审核植入不明程序威胁生态安全。但是具体市面用的方案比如Lua可不可行，还是看apple官方的态度，想禁止是很容易的。案例可参照jsPath，这里不细说，有兴趣自行查阅。</li><li>程序设计时，所有功能设计要以 <strong>运行时优先</strong>，这样才能保证在每个功能合并时让整体处于较优状态。繁琐的事情可以写编辑器工具和自动化批处理来简化制作流程上的繁琐。</li><li>VFS(virtual File System 虚拟文件系统) 在处理工程资源相关时，可以建立一个VFS来统一封装资源的管理，对资源的加载卸载缓冲的使用封装起来为工程提供方便的使用接口。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ARLiveSolutionBaseOnVMix</title>
      <link href="2021/04/10/arlivesolutionbaseonvmix/"/>
      <url>2021/04/10/arlivesolutionbaseonvmix/</url>
      
        <content type="html"><![CDATA[<h1 id="AR-直播-解决方案-基于vMix"><a href="#AR-直播-解决方案-基于vMix" class="headerlink" title="AR 直播 解决方案 (基于vMix)"></a>AR 直播 解决方案 (基于vMix)</h1><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul><li><strong>vMix</strong><ul><li>价格(<a href="https://www.vmix.com/purchase/">官方购买说明</a>)：<ul><li>vMix is available in four editions. Each purchase does <strong>not expire</strong> and includes <strong>Free Version Updates for one year</strong> from the date of purchase.</li><li>购买之日起一年内免费更新。</li><li>各个版本功能对比和价格参考官方购买说明。<h2 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h2></li></ul></li></ul></li><li>大场景 无弹窗<br> <img src="/2021/04/10/arlivesolutionbaseonvmix/Scene1.png" alt="场景1"></li><li>原理：<ul><li>利用vmix的 <strong>覆盖功能</strong> 、 <strong>绿幕抠图功能</strong> 、<strong>摄像头捕捉功能</strong> 将人物抠好覆盖到摄像头捕捉的大场景中。</li></ul></li><li>准备的输入素材：<ol><li>摄像头捕捉显示画面</li><li>绿幕捕捉人物画面</li></ol></li><li>将 绿幕捕捉的人物 通过覆盖功能放到 摄像头捕捉的大场景画面中。</li></ul><h2 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h2><ul><li>大场景 有弹窗<br> <img src="/2021/04/10/arlivesolutionbaseonvmix/Scene2.png" alt="场景2"></li><li>原理：<ul><li>在场景1的基础上，再叠加一层，这层可以放：视频、图片、ppt。</li></ul></li><li>准备输入素材：<ol><li>摄像头捕捉显示画面</li><li>绿幕捕捉人物画面</li><li>视频、图片、ppt 素材</li></ol></li><li>将 绿幕捕捉的人物，视频、图片、ppt等 覆盖到摄像头显示画面。</li></ul><h2 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h2><ul><li>背景使用 视频、图片、ppt 来填充，绿幕人物摆放<br> <img src="/2021/04/10/arlivesolutionbaseonvmix/Scene3.png" alt="场景3"></li><li>原理：<ul><li>利用vmix的 <strong>覆盖功能</strong> 、 <strong>绿幕抠图功能</strong> 将人物口号覆盖到 ppt、视频、图片 <em>（全屏）</em> 上。</li></ul></li><li>准备的输入素材：<ol><li>绿幕捕捉人物画面</li><li>视频、图片、ppt 素材</li></ol></li><li>将 绿幕捕捉的人物，覆盖到 视频、图片ppt 上。</li></ul><h2 id="Pad控制端"><a href="#Pad控制端" class="headerlink" title="Pad控制端"></a>Pad控制端</h2><p>   <img src="/2021/04/10/arlivesolutionbaseonvmix/PadControl.png" alt="PadControl"></p><ul><li><strong>方案1：</strong><ul><li>要求使用WindowsPad。通过 windows 的远程控制，可用WinPad访问vmix控制台的电脑。将获得控制台的所有控制功能。</li><li>优点：局域网访问速度稳定快速。控制功能系统自带无需额外开销。</li><li>缺点：限制控制端必须是WindowsPad。默认局域网ip登录访问，外网要自行想办法配置公网ip问题。控制后vmix的电脑进入锁屏状态无法使用。</li></ul></li><li><strong>方案2：</strong><ul><li>通过第三方远程控制软件控制vmix电脑。也可获得控制台的所有控制功能。</li><li>优点：不受限于Pad的系统平台，可用Ipad、WinPad、AndroidPad。远程控制时，被控vmix电脑也可使用。</li><li>缺点：访问速度和画质受限于网络稳定性一般。需要额外购买第三方软件服务。</li></ul></li><li><strong>方案3：</strong><ul><li>通过vmix的官方 <a href="https://www.vmix.com/help24/index.htm?ScriptingandAutomation.html">TCP API 接口</a> 和 <a href="https://www.vmix.com/help24/index.htm?WebScripting.html">命令及参数</a>。可以通过网路命令的方式实现大多数软件中常用的功能。</li><li>利用官方网络API可以制作独立的客户端安装在Pad上，通过发送网络消息的方式控制vmix软件。</li><li>优点：在vmix提供的命令的范围内，Pad端的界面可定制。</li><li>缺点：Pad端需要单独制作软件，设计开发成本比较高，制作周期长。受限于官方API给出的命令，超出这个命令范围无法定制，没有远程直接控制vmix软件要功能齐全。运行在局域网中，想要外网控制需要解决公网ip问题。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> AR - 导播 - 绿幕抠像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity打包的Apk再解包打包签名</title>
      <link href="2021/04/09/unity-da-bao-de-apk-zai-jie-bao-da-bao-qian-ming/"/>
      <url>2021/04/09/unity-da-bao-de-apk-zai-jie-bao-da-bao-qian-ming/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity打包的Apk再解包打包签名"><a href="#Unity打包的Apk再解包打包签名" class="headerlink" title="Unity打包的Apk再解包打包签名"></a>Unity打包的Apk再解包打包签名</h1><ul><li>Unity打包出Apk后 可用无需重新Unity打包 修改调整Apk包中默认的素材。</li><li>例如：<ul><li>Unity中StreamingAssets下存放的图片、配置文件等可以再不重新Unity打包的情况下替换素材。</li></ul></li><li><strong>简介</strong><ul><li>先介绍Apk的基础结构。再将Apk中与Unity对应的文件路径进行介绍。有了这些基础就知道在哪里替换素材了。</li><li>接着为了替换素材还要把Apk解包，解包替换素材后，还要再重新打包成Apk，最后重新打包的Apk需要签名后才能安装使用。<em>（这里会介绍Unity默认打包时用到的Unity默认打包证书的相关内容）</em></li></ul></li></ul><h2 id="Apk结构"><a href="#Apk结构" class="headerlink" title="Apk结构"></a>Apk结构</h2><ul><li>APK是Android Package的缩写，即Android application package文件或Android安装包。其中包含了应用的二进制代码、资源、配置文件等。APK文件其实就是zip格式，但其扩展名被改为apk，在Windows下将apk扩展名改为zip，用解压软件WinRAR/WinZIP/7-Zip可以直接打开。解压后，你会看到有几个文件和文件夹。一个典型的APK文件通常有下列内容组成：<ul><li>AndroidManifest.xml  程序全局配置文件</li><li>classes.dex          Dalvik字节码</li><li>resources.arsc       编译后的二进制资源文件</li><li>META-INF\            该目录下存放的是签名信息</li><li>res\                 该目录存放资源文件</li><li>assets\              该目录可以存放一些配置文件</li></ul></li><li>下面对这些文件和目录做些基本的注释和介绍：<ul><li>AndroidManifest.xml<ul><li>该文件是每个apk应用程序都必须包含的文件，它描述了应用程序的名字、版本、权限、引用的库文件等等信息。</li></ul></li><li>classes.dex文件 <ul><li>classes.dex是java源码编译后生成的java字节码文件。dex是Dalvik VM executes的全称，即Android Dalvik执行程序。利用解析工具可以将其转换成java来加以阅读和理解。</li></ul></li><li>resources.arsc <ul><li>编译后的二进制资源文件。在做主题美化时要常与这个文件打交道。</li></ul></li><li>META-INF目录 <ul><li>META-INF目录下存放的是签名信息，有三个签名文件，用来保证apk包的完整性和系统的安全。在eclipse编译生成一个apk包时，会对所有要打包的文件做一个校验计算，并把计算结果放在META-INF目录下。这就保证了apk包里的文件不能被随意替换。比如拿到一个apk包后，如果想要替换里面的一幅图片，一段代码， 或一段版权信息，想直接解压缩、替换再重新打包，基本是不可能的。如此一来就给病毒感染和恶意修改增加了难度，有助于保护系统的安全。</li></ul></li><li>res目录 <ul><li>res目录存放资源文件。包括图片，字符串等等。res下有若干个子目录，主要为drawable，layout，xml。</li><li>解包后，几乎所有可能的修改和编辑工作基本都在这里。汉化ROM的主要工作就在这里。汉化ROM实际上就是汉化所有的apk应用程序的字符文件。</li></ul></li><li>assets目录<ul><li>assets目录可以存放一些配置文件，这些文件的内容在程序运行过程中可以通过相关的API获得。 </li></ul></li></ul></li></ul><h2 id="Unity与Apk"><a href="#Unity与Apk" class="headerlink" title="Unity与Apk"></a>Unity与Apk</h2><ul><li>在Unity中StreamingAssets里的文件会在解压后的assets/目录下存放。<ul><li>例如：<ul><li>在StreamingAssets中存放Config/config.txt。</li><li>那么在apk解压包中会看到此文件被放到了assets/Config/config.txt</li></ul></li></ul></li><li>通过对应关系可以在解包后的apk中替换在StreamingAssets中存放的素材。</li><li><em>注意：Android平台的StreamingAssets文件夹下的资源都要用WWW或UnityWebRequest的方式获取，无法直接用System.IO.File的各种方法来读取。</em></li><li>例如读取在StreamingAssets下的文本文件： <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Collections</span><span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token namespace">UnityEngine</span><span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token namespace">UnityEngine<span class="token punctuation">.</span>Networking</span><span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token namespace">UnityEngine<span class="token punctuation">.</span>UI</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoadRes</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token class-name">GameObject</span> configText<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>      <span class="token function">StartCoroutine</span><span class="token punctuation">(</span><span class="token function">LoadConfigTextCoroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 读取配置文件</span>  <span class="token keyword">private</span> <span class="token return-type class-name">IEnumerator</span> <span class="token function">LoadConfigTextCoroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>      <span class="token class-name"><span class="token keyword">string</span></span> path <span class="token operator">=</span> Application<span class="token punctuation">.</span>streamingAssetsPath <span class="token operator">+</span> <span class="token string">"/Config/config.txt"</span><span class="token punctuation">;</span>      <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name">UnityWebRequest</span> uwr <span class="token operator">=</span> UnityWebRequest<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>          <span class="token keyword">yield</span> <span class="token keyword">return</span> uwr<span class="token punctuation">.</span><span class="token function">SendWebRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 用 configText 这个 GameObject 来显示获取的文本</span>          configText<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>Text<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>text <span class="token operator">=</span> uwr<span class="token punctuation">.</span>downloadHandler<span class="token punctuation">.</span>text<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Apk解包"><a href="#Apk解包" class="headerlink" title="Apk解包"></a>Apk解包</h2><ul><li>上面讲到apk是个zip包，可以解压后看到内容。但是其中的文件时被编译过的，所以为了看到原始的内容，就要用工具来解包，也就是说要反编译apk获取到原始内容。</li><li>本文使用 <a href="https://ibotpeaches.github.io/Apktool/">ApkTool</a> 作为工具来解包打包apk。<ul><li><a href="https://ibotpeaches.github.io/Apktool/documentation/">ApkTool官方说明文档</a></li></ul></li><li>配置ApkTool<ul><li>根据<a href="https://ibotpeaches.github.io/Apktool/install/">官方说明</a>中的install章节 配置环境。(下方bat和jar文件以处理好<a href="https://pan.baidu.com/s/1qsdhwAjqU3V9C6lagqDowQ">点击云盘下载,提取码:jb39</a>)<ul><li>Windows:</li><li>下载批处理文件 <strong>apktool.bat</strong></li><li>下载 apktool.jar 的最新版，后改名为 <strong>apktool.jar</strong></li><li>移动两个文件 (apktool.jar &amp; apktool.bat) 到Windows 路径 (通常是 C://Windows)</li><li>如果没有放到 C://Windows 需要在系统的环境变量中添加路径。</li><li>尝试在终端中运行 apktool </li></ul></li></ul></li><li>其他平台参考官方文档。</li><li><strong>一条命令解包</strong> <pre class="line-numbers language-Dos" data-language="Dos"><code class="language-Dos">$ apktool d bar.apk -o baz&#x2F;&#x2F; decodes bar.apk to baz folder&#x2F;&#x2F; 在baz文件夹中解包bar.apk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>解包对比，上图是直接解压，下图是apktool解包的目录：<br><img src="/2021/04/09/unity-da-bao-de-apk-zai-jie-bao-da-bao-qian-ming/UnpackApkContrast.png" alt="解包对比"></li></ul></li></ul><h2 id="Apk打包"><a href="#Apk打包" class="headerlink" title="Apk打包"></a>Apk打包</h2><ul><li><strong>一条命令打包</strong> <pre class="line-numbers language-Dos" data-language="Dos"><code class="language-Dos">$ apktool d bar.apk -o baz&#x2F;&#x2F; decodes bar.apk to baz folder&#x2F;&#x2F; 在baz文件夹下打包成bar.apk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Apk签名"><a href="#Apk签名" class="headerlink" title="Apk签名"></a>Apk签名</h2><ul><li><strong>一条命令签名</strong> <pre class="line-numbers language-Dos" data-language="Dos"><code class="language-Dos">$ jarsigner.exe -verbose -keystore debug.keystore -signedjar TestApkChangedSigned.apk TestApkChanged.apk androiddebugkey<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>下面解释一下命令：<ul><li><strong>jarsigner</strong>是Java的签名工具</li><li><strong>-verbose</strong>参数表示：显示出签名详细信息</li><li><strong>-keystore</strong>表示使用当前目录中的debug.keystore签名证书文件。</li><li><strong>-storepass</strong> 密钥口令 <em>没写这个参数时，会提示输入口令，正常输入口令即可。</em></li><li><strong>-signedjar</strong> 后跟三个参数：<ul><li>ThinkDrive_signed.apk表示签名后生成的APK名称，</li><li>ThinkDrive_temp.apk 表示未签名的APK，</li><li>androiddebugkey表示debug.keystore的别名</li></ul></li></ul></li><li><strong>Unity中的签名</strong><ul><li>默认如果不设置直接打包出的apk签名使用的是unity默认提供的签名。<ul><li>默认签名在 <strong>C:\User\用户名.android\debug.keystore</strong> 这里。</li><li>签名的密码是：android</li><li>签名的别名是：androiddebugkey</li></ul></li></ul></li><li><strong>签名信息</strong><ul><li>可以用 如下命令查看签名信息：<pre class="line-numbers language-dos" data-language="dos"><code class="language-dos">$ keytool -list -keystore debug.keystore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>也可以在解包后查看签名信息：<ul><li>找到META-INF下的CERT.RSA（密钥信息文件）<pre class="line-numbers language-dos" data-language="dos"><code class="language-dos">$ keytool -printcert -file CERT.RSA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><em>注:密钥信息在apktool解包后路径在original/META-INF/中。</em></li></ul></li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/ouyangping/p/6366461.html">APK应用程序的解包、修改、编辑、汉化、打包及应用</a></li><li><a href="https://blog.csdn.net/linxinfa/article/details/77572382">关于Unity android打包的keystore</a></li><li><a href="https://www.cnblogs.com/mingfeng002/p/8559586.html">android apk反编译,重新打包,签名</a></li><li><a href="https://blog.csdn.net/jerry_wmje/article/details/90639446">Unity之Android平台相关路径问题</a></li><li><a href="https://ibotpeaches.github.io/Apktool/install/">ApkTool Install Instructions</a></li><li><a href="https://ibotpeaches.github.io/Apktool/documentation/#building">ApkTool Introduction</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Unity - Apk - 打包 - 解包 - 签名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityWebBrowserSolution</title>
      <link href="2021/03/25/unitywebbrowsersolution/"/>
      <url>2021/03/25/unitywebbrowsersolution/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity-中使用-Web-游览器-解决方案"><a href="#Unity-中使用-Web-游览器-解决方案" class="headerlink" title="Unity 中使用 Web 游览器 解决方案"></a>Unity 中使用 Web 游览器 解决方案</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>收集在Unity中嵌如Web的解决方案。</li><li><strong>UnityWebCore：</strong> 只支持Windows平台，调用浏览器内核，将网页渲染到mesh，作为gameObject。</li><li><strong>WWebView：</strong> 只支持Windows</li><li><strong>ZFBrowser：</strong> 适用于Windows、MacOS。(web内容以raw纹理方式显示。web页作为物体存在于场景中。)</li><li><strong>Unity-Webview：</strong> 适用于Android, iOS, Unity Web Player, and Mac (Windows 现在还不支持(包括Editor模式)).，调用移动平台的Webview。(通过调用对应平台的web引擎显示网页。导致网页显示在屏幕最上端，会遮盖住一切unity的物体。可以在mac editor中调试，并且能在unity的game窗口内部正常显示。)</li><li><strong><a href="https://docs.uniwebview.com/">UniWebView：</a></strong> 适用于Andriod、ios和Mac os，在移动端效果最好。2.0版本之后支持WP8，不支持windows桌面系统，包括编辑器状态。(原理同Unity-Webview，后续支持和官网api资料比较好。缺点是在mac editor调试时web页是从unity game窗口脱离出来的，运行时的整体性差了些。)</li><li><strong>……</strong></li></ul><h2 id="先上对比结论"><a href="#先上对比结论" class="headerlink" title="先上对比结论"></a>先上对比结论</h2><ul><li><strong>移动端</strong><ul><li><strong>Android、IOS 选择 UniWebView</strong></li><li><strong>推荐原因：①软件更新支持好。②官方文档质量好。</strong></li><li><em>不足：在调试时web页单独一个窗口显示，整体性不太好。</em></li></ul></li></ul><h1 id="UnityWebCore"><a href="#UnityWebCore" class="headerlink" title="UnityWebCore"></a>UnityWebCore</h1><h1 id="Unity-Webview"><a href="#Unity-Webview" class="headerlink" title="Unity-Webview"></a>Unity-Webview</h1><h1 id="UniWebView"><a href="#UniWebView" class="headerlink" title="UniWebView"></a>UniWebView</h1><h1 id="ZFBrowser"><a href="#ZFBrowser" class="headerlink" title="ZFBrowser"></a>ZFBrowser</h1><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ul><li><strong>Android net：：ERR_CLEARTEXT_NOT_PERMITTED</strong><ul><li><strong>从Android 9.0（API级别28）开始，默认情况下禁用明文支持。因此http的url均无法在webview中加载</strong></li><li>在unity中Plugins/Android/AndroidManifest添加节点 **”android:usesCleartextTraffic=”true”**，启动域名明文，支持http请求。<pre class="line-numbers language-manifest" data-language="manifest"><code class="language-manifest">&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;package&#x3D;&quot;com.example.webviewtest&quot;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot;&#x2F;&gt;    &lt;application        android:usesCleartextTraffic&#x3D;&quot;true&quot;&#x2F;&#x2F;确认网络权限给过以后，加入这句即可        &lt;activity android:name&#x3D;&quot;.MainActivity&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>```</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> UnityWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ILRuntimeNote</title>
      <link href="2021/03/17/ilruntimenote/"/>
      <url>2021/03/17/ilruntimenote/</url>
      
        <content type="html"><![CDATA[<h1 id="ILRuntime-Note"><a href="#ILRuntime-Note" class="headerlink" title="ILRuntime Note"></a>ILRuntime Note</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ul><li><strong>加载 hotfix dll，pdb 到内存流 =&gt; 得到 dll、pdb 内存流</strong> <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">// 假设dll和pdb在“/”路径下</span><span class="token class-name">MemoryStream</span> hotfixDll <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MemoryStream</span><span class="token punctuation">(</span>File<span class="token punctuation">.</span><span class="token function">ReadAllBytes</span><span class="token punctuation">(</span><span class="token string">"/HotFix.dll"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">MemoryStream</span> hotfixPdb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MemoryStream</span><span class="token punctuation">(</span>File<span class="token punctuation">.</span><span class="token function">ReadAllBytes</span><span class="token punctuation">(</span><span class="token string">"/HotFix.pdb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><strong>用 dll 和 pdb 来初始化 ILRuntime 的 appdomain =&gt; 得到 appdomain 对象</strong> <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token class-name">AppDomain</span> appDomain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">AppDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>appDomain<span class="token punctuation">.</span><span class="token function">LoadAssembly</span><span class="token punctuation">(</span>hotfixDll<span class="token punctuation">,</span> hotfixPdb<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ILRuntime<span class="token punctuation">.</span>Mono<span class="token punctuation">.</span>Cecil<span class="token punctuation">.</span>Pdb<span class="token punctuation">.</span>PdbReaderProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><strong>用 appdomain 做一些注册 用来优化性能或声明调用</strong></li><li><strong>用 appdomain 来调用各种方法进行操作</strong> <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">// 调用HotFix.dll中HotFix类中PrintLog静态方法，一个参数String。下面的null代表传递的对象实例，静态方法不需要传递，则为null</span>appDomain<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token string">"HotFix.HotFix"</span><span class="token punctuation">,</span> <span class="token string">"PrintLog"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"MyHotFix print"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="预热-热更Code快速上手"><a href="#预热-热更Code快速上手" class="headerlink" title="预热-热更Code快速上手"></a>预热-热更Code快速上手</h2><ul><li><strong>LoadHotfixFile() 加载热更dll</strong></li><li><strong>InitAppDomain() 初始化AppDomain</strong></li></ul><p>   <em>以上两步参考上面 <strong>基本流程</strong> 中代码示例。</em></p><ul><li><p><strong>InitILRuntime() 注册转换各种要用到的东西</strong></p></li><li><p><strong>MainPojCallHotFix() 主工程调用热更dll</strong></p><ul><li><p><strong>调用静态方法:</strong></p><ul><li><strong>调用静态无参数方法</strong></li><li><strong>调用静态一个参数方法</strong></li><li><strong>调用静态两个参数方法</strong></li></ul></li><li><p><strong>获取类:</strong></p></li><li><p><strong>获取方法:</strong></p><ul><li><strong>获取方法1 - 获取无重载方法</strong></li><li><strong>获取方法2 - 获取有形参重载的方法，创建形参重载的参数列表来获取方法，以区别是那个具体方法</strong></li></ul></li><li><p><strong>实例化类:</strong></p><ul><li><strong>实例化类型1 - 无缓存类，直接传递类名实例化</strong></li><li><strong>实例化类型2 - 有缓存类，通过缓存类型实例化</strong></li></ul></li><li><p><strong>调用实例的成员方法:</strong></p></li><li><p><strong>调用泛型方法：</strong></p></li><li><p><strong>获取泛型方法：</strong></p></li><li><p><strong>注册委托(主工程里声明委托，热更工程里将实例赋值给主工程委托，让主工程完成调用)</strong></p><ul><li>如果主工程里没有注册相应的委托，并在主工程里调用了热更dll的委托，运行时会提示注册，并且给与相应注册的代码如下，加入到主工程里的注册阶段即可。 <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">KeyNotFoundException<span class="token punctuation">:</span> Cannot find convertor <span class="token keyword">for</span> <span class="token keyword">global</span><span class="token punctuation">::</span>TestDelegateMethodPlease <span class="token keyword">add</span> <span class="token class-name">following</span> code<span class="token punctuation">:</span>appdomain<span class="token punctuation">.</span>DelegateManager<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">RegisterDelegateConvertor</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">global</span><span class="token punctuation">:</span><span class="token punctuation">:</span>TestDelegateMethod<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>act<span class="token punctuation">)</span> <span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">global</span><span class="token punctuation">::</span><span class="token function">TestDelegateMethod</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">=></span>    <span class="token punctuation">&#123;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>Action<span class="token operator">&lt;</span>System<span class="token punctuation">.</span>Int32<span class="token operator">></span><span class="token punctuation">)</span>act<span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>跨域继承(热更工程中继承主工程里的类，主工程可以调用实现的功能)</strong></p><ul><li>必须在主工程中注册适配器才能用</li><li><strong>假设主工程中被继承的方法为InfoBase,定义如下</strong> <pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine;namespace SmalBox.Auto&#123;    public abstract class InfoBase    &#123;        public virtual int ID &#123; get &#123; return 0; &#125; set &#123; &#125; &#125;        public virtual void Info(string str) &#123; Debug.Log(&quot;Info str:&quot; + str); &#125;        public abstract void Num(int num);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>注册适配器具体步骤 - 手写Adaptor脚本（假设主工程中被继承的方法为InfoBase）</strong><ul><li>在主工程中添加UIBase的适配器类：<strong>InfoBaseAdapter</strong></li><li>让InfoBaseAdapter继承CrossBindingAdaptor</li><li>IDE中选择实现其三个抽象方法 <strong>BaseCLRType</strong>、<strong>AdaptorType</strong>、<strong>BaseCLRTypes</strong>，IDE会自动把重写框架写好。</li><li>选择UIBaseAdapter重写其方法，生成<strong>CreateCLRInstance</strong>方法。</li><li>生成<strong>Adaptor</strong>方法来写逻辑</li><li><strong>现在可以来写以上提到的生成出的5个必要的方法</strong><ol><li><strong>BaseCLRType</strong><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; 返回主工程中 基类的类型public override Type BaseCLRType &#123;get&#123;return typeof(InfoBase);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><strong>AdaptorType</strong><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; 返回本类中 Adaptor的类型public override Type AdaptorType &#123;get&#123;return typeof(Adaptor);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><strong>BaseCLRTypes</strong><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; 只实现一个接口 返回null即可，实现多个参看官网文档public override Type[] BaseCLRTypes &#123;get&#123;return null;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><em>跨域继承只能有1个Adapter，因此应该尽量避免一个类同时实现多个外部接口，对于coroutine来说是IEnumerator<object>,IEnumerator和IDisposable，ILRuntime虽然支持，但是一定要小心这种用法，使用不当很容易造成不可预期的问题日常开发如果需要实现多个DLL外部接口，请在Unity这边先做一个基类实现那些个接口，然后继承那个基类。</object></em></li><li><strong>CreateCLRInstance</strong><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; 返回用 appdomain和instance 作为参数，调用下面的Adaptor的构造方法，public override object CreateCLRInstance(ILRuntime.Runtime.Enviorment.AppDomain appdomain, ILTypeInstance instance) &#123;return new Adaptor(appdomain, instance);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><strong>Adaptor</strong><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class Adapter : SmalBox.Auto.InfoBase, CrossBindingAdaptorType&#123;   &#x2F;&#x2F; 创建空构造方法、有appdomain、instance参数的构造方法。   ILTypeInstance instance;   ILRuntime.Runtime.Enviorment.AppDomain appdomain;   public Adapter()&#123;&#125;   public Adapter(ILRuntime.Runtime.Enviorment.AppDomain appdomain, ILTypeInstance instance)   &#123;       this.appdomain &#x3D; appdomain;       this.instance &#x3D; instance;   &#125;   &#x2F;&#x2F; 返回IL实例   public ILTypeInstance ILInstance &#123; get &#123; return instance; &#125; &#125;   &#x2F;&#x2F; 下面重写基类定义的内容   &#x2F;&#x2F; 重写ID 属性   static CrossBindingFunctionInfo&lt;System.Int32&gt; mget_ID_0 &#x3D; new CrossBindingFunctionInfo&lt;System.Int32&gt;(&quot;get_ID&quot;);   static CrossBindingMethodInfo&lt;System.Int32&gt; mset_ID_1 &#x3D; new CrossBindingMethodInfo&lt;System.Int32&gt;(&quot;set_ID&quot;);   public override System.Int32 ID   &#123;      get      &#123;          if (mget_ID_0.CheckShouldInvokeBase(this.instance))              return base.ID;          else              return mget_ID_0.Invoke(this.instance);      &#125;      set      &#123;          if (mset_ID_1.CheckShouldInvokeBase(this.instance))              base.ID &#x3D; value;          else              mset_ID_1.Invoke(this.instance, value);      &#125;   &#125;   &#x2F;&#x2F; 重写Info 虚方法   static CrossBindingMethodInfo&lt;System.String&gt; mInfo_2 &#x3D; new CrossBindingMethodInfo&lt;System.String&gt;(&quot;Info&quot;);   public override void Info(System.String str)   &#123;       if (mInfo_2.CheckShouldInvokeBase(this.instance))           base.Info(str);       else           mInfo_2.Invoke(this.instance, str);   &#125;   &#x2F;&#x2F; 重写Num 抽象方法   static CrossBindingMethodInfo&lt;System.Int32&gt; mNum_3 &#x3D; new CrossBindingMethodInfo&lt;System.Int32&gt;(&quot;Num&quot;);   public override void Num(System.Int32 num)   &#123;       mNum_3.Invoke(this.instance, num);   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ul></li><li><strong>注册适配器具体步骤 - 扩展编辑器自动生成Adaptor脚本 （上面手写太麻烦？ILRuntime给出一个编辑器扩展接口可以自动分析基类，生成其Adapter类ヽ(✿ﾟ▽ﾟ)ノ）</strong> <pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEditor;using SmalBox.Auto;public class AutoCrossAdapter&#123;   [MenuItem(&quot;SmalBox&#x2F;ILRuntime&#x2F;生成跨域继承适配器&quot;)]    static void GenerateCrossbindAdapter()    &#123;        &#x2F;&#x2F;由于跨域继承特殊性太多，自动生成无法实现完全无副作用生成，所以这里提供的代码自动生成主要是给大家生成个初始模版，简化大家的工作        &#x2F;&#x2F;大多数情况直接使用自动生成的模版即可，如果遇到问题可以手动去修改生成后的文件，因此这里需要大家自行处理是否覆盖的问题        using(System.IO.StreamWriter sw &#x3D; new System.IO.StreamWriter(&quot;Assets&#x2F;MyTest&#x2F;MainObj&#x2F;Adapter&#x2F;InfoBaseAdapter.cs&quot;)) &#x2F;&#x2F; 这里设定要生成到哪里，脚本叫什么名字        &#123;           &#x2F;&#x2F; 这句用GenerateCrossBindingAdapterCode,传入基类类型、命名空间名字 即可。            sw.WriteLine(ILRuntime.Runtime.Enviorment.CrossBindingCodeGenerator.GenerateCrossBindingAdapterCode(typeof(InfoBase), &quot;SmalBox.Auto&quot;));        &#125;        &#x2F;&#x2F; ...N多基类都写在这。。。        &#x2F;&#x2F; 在个编辑器脚本里如上加入所有基类，然后点击菜单上的这个按钮即可自动生成。        &#x2F;&#x2F; 自动生成出问题了再按照上面手写的来看看哪里有问题需要修复。        AssetDatabase.Refresh();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>CLR重定向</strong></p></li><li><p><strong>CLR绑定</strong></p><ul><li>CLR绑定借助了ILRuntime的CLR重定向机制来实现，因为实质上也是将对CLR方法的反射调用重定向到我们自己定义的方法里面来。</li><li>ILRuntime提供了一个代码生成工具来自动生成CLR绑定代码。</li><li><strong>编辑器扩展绑定</strong> <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">MenuItem</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"ILRuntime/Generate CLR Binding Code by Analysis"</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">GenerateCLRBindingByAnalysis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//用新的分析热更dll调用引用来生成绑定代码</span>    <span class="token class-name">ILRuntime<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>Enviorment<span class="token punctuation">.</span>AppDomain</span> domain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ILRuntime<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>Enviorment<span class="token punctuation">.</span>AppDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name">System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>FileStream</span> fs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>FileStream</span><span class="token punctuation">(</span><span class="token string">"Assets/StreamingAssets/HotFix_Project.dll"</span><span class="token punctuation">,</span> System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>FileMode<span class="token punctuation">.</span>Open<span class="token punctuation">,</span> System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>FileAccess<span class="token punctuation">.</span>Read<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        domain<span class="token punctuation">.</span><span class="token function">LoadAssembly</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//Crossbind Adapter is needed to generate the correct binding code</span>        <span class="token function">InitILRuntime</span><span class="token punctuation">(</span>domain<span class="token punctuation">)</span><span class="token punctuation">;</span>        ILRuntime<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>CLRBinding<span class="token punctuation">.</span>BindingCodeGenerator<span class="token punctuation">.</span><span class="token function">GenerateBindingCode</span><span class="token punctuation">(</span>domain<span class="token punctuation">,</span> <span class="token string">"Assets/ILRuntime/Generated"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    AssetDatabase<span class="token punctuation">.</span><span class="token function">Refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">InitILRuntime</span><span class="token punctuation">(</span><span class="token class-name">ILRuntime<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>Enviorment<span class="token punctuation">.</span>AppDomain</span> domain<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//这里需要注册所有热更DLL中用到的跨域继承Adapter，否则无法正确抓取引用</span>    domain<span class="token punctuation">.</span><span class="token function">RegisterCrossBindingAdaptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">MonoBehaviourAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    domain<span class="token punctuation">.</span><span class="token function">RegisterCrossBindingAdaptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">CoroutineAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    domain<span class="token punctuation">.</span><span class="token function">RegisterCrossBindingAdaptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">TestClassBaseAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    domain<span class="token punctuation">.</span><span class="token function">RegisterValueTypeBinder</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">Vector3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Vector3Binder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>主工程在ILRuntime全部初始化之后调用绑定</strong> <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ILRuntime<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>Generated<span class="token punctuation">.</span>CLRBindings<span class="token punctuation">.</span><span class="token function">Initialize</span><span class="token punctuation">(</span>appdomain<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p><strong>主工程中调用热更工程中的协程</strong></p><ul><li>使用Couroutine时，C#编译器会自动生成一个实现了IEnumerator，IEnumerator<object>，IDisposable接口的类，因为这是跨域继承，所以需要写CrossBindAdapter</object></li></ul></li><li><p><strong>主工程中反射获取dll中的类型</strong></p> <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> it <span class="token operator">=</span> appdomain<span class="token punctuation">.</span>LoadedTypes<span class="token punctuation">[</span><span class="token string">"HotFix_Project.InstanceClass"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name"><span class="token keyword">var</span></span> type <span class="token operator">=</span> it<span class="token punctuation">.</span>ReflectionType<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="热更Code"><a href="#热更Code" class="headerlink" title="热更Code"></a>热更Code</h2></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Unity - 热更新Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HexoQA</title>
      <link href="2021/03/17/hexoqa/"/>
      <url>2021/03/17/hexoqa/</url>
      
        <content type="html"><![CDATA[<h1 id="HexoQA"><a href="#HexoQA" class="headerlink" title="HexoQA"></a>HexoQA</h1><ul><li><strong>Q: hexo d 时 ERROR Deployer not found: git</strong><ul><li><em>A: npm install –save hexo-deployer-git</em></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> QA - Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陀螺仪Note</title>
      <link href="2021/03/15/gyronote/"/>
      <url>2021/03/15/gyronote/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity陀螺仪测试记录"><a href="#Unity陀螺仪测试记录" class="headerlink" title="Unity陀螺仪测试记录"></a>Unity陀螺仪测试记录</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>本篇介绍了 Unity 中提供的陀螺仪接口，在 Android 平台的陀螺仪实际表现。最后介绍以陀螺仪为输入数据的设备环绕查看目标物体的实现方式。</li></ul><h2 id="Unity-中的陀螺仪接口"><a href="#Unity-中的陀螺仪接口" class="headerlink" title="Unity 中的陀螺仪接口"></a>Unity 中的陀螺仪接口</h2><ul><li><strong>接口使用方式：</strong> <pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; 从Input中取陀螺仪的类型数据Gyroscope gyro &#x3D; Input.gyro;&#x2F;&#x2F; 用gyro的各种属性设置或者获取参数来使用陀螺仪&#x2F;&#x2F; 例如：gyro.enabled &#x3D; true; &#x2F;&#x2F; 开启陀螺仪var currGyroAngle &#x3D; gyro.attitude.eulerAngles; &#x2F;&#x2F; 获取当前陀螺仪旋转到了的角度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>以下是陀螺仪的所有属性参数：</strong><table><thead><tr><th align="center">（类型）属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">(Quaternion) <strong>attitude</strong></td><td align="center">返回设备的姿态（即空间方向）。<em>（实测每次开启应用程序后的空间方向零点的坐标不一致。旋转设备方向会改变轴向。）</em></td></tr><tr><td align="center">(bool) <strong>enabled</strong></td><td align="center">设置或获取此陀螺仪的启用状态。<em>（使用陀螺仪时要代码设置打开此属性）</em></td></tr><tr><td align="center">(Vector3) <strong>gravity</strong></td><td align="center">返回以设备的参考框架表示的重力加速度矢量。<em>（可以用来简单检测设备的当前姿态。旋转设备会改变轴向。）</em></td></tr><tr><td align="center">(Vector3) <strong>rotationRate</strong></td><td align="center">返回由设备的陀螺仪测量的旋转速率。<em>（获取设备的旋转偏移量，由于精度问题，真实旋转的角度可能不能严格和获取的数据对应。）</em></td></tr><tr><td align="center">(Vector3) <strong>rotationRateUnbiased</strong></td><td align="center">返回由设备的陀螺仪测量的无偏转速。<em>（相对rotationRate数据更稳定建议使用）</em></td></tr><tr><td align="center">(float) <strong>updateInterval</strong></td><td align="center">设置或获取陀螺仪间隔（以秒为单位）。 <em>（设置获取设备间隔，控制陀螺仪灵敏度。）</em></td></tr><tr><td align="center">(Vector3) <strong>userAcceleration</strong></td><td align="center">返回用户给予设备的加速度。 <em>（可以获取各个轴向的加速度，精度一般。）</em></td></tr></tbody></table></li></ul><h2 id="设备轴向"><a href="#设备轴向" class="headerlink" title="设备轴向"></a>设备轴向</h2><ul><li><strong>设备轴向</strong>（Portrait,PortraitUpsideDown,LandscapeLeft,LandscapeRight）以Portrait作为标准方向坐标如下，其他方向是在此基础上做左右旋转得到。<em>不管设备如何朝向，轴向是不会改变的</em></li><li><strong>Portrait 设备竖直正方向</strong><ul><li>设备状态：<ul><li>┏++┓</li><li>┃⇧y┃ 设备向上Y轴</li><li>┗==┛</li><li>┏++┓</li><li>┃⇨x┃ 设备向右X轴</li><li>┗==┛</li><li>┏++┓</li><li>┃◉z┃ 设备向上Z轴</li><li>┗==┛</li></ul></li></ul></li><li><strong>PortraitUpsideDown 设备竖直倒方向</strong><ul><li>Portrait 绕z轴旋转180°</li></ul></li><li><strong>LandscapeLeft 设备左转方向</strong><ul><li>Portrait 绕z轴逆时针90°</li></ul></li><li><strong>LandscapeRight 设备右转方向</strong><ul><li>Portrait 绕z轴顺时针90°</li></ul></li></ul><h2 id="Android-平台"><a href="#Android-平台" class="headerlink" title="Android 平台"></a>Android 平台</h2><ul><li><strong>gyro.attitude.eulerAngles 陀螺仪状态角，的值始终与内容方向一致。</strong><ul><li><strong>具体解释</strong><ul><li>假设设备屏幕朝上放在桌子上，设备内容与现实世界北方方向相同。</li><li> N</li><li>┏++┓</li><li>┃⇧⇧┃</li><li>┗==┛  Portrait, gyro.attitude.eulerAngles = 0°</li><li> S</li><li>当设备方向从Portrait变成PortraitUpsideDown时，设备内容会变化朝向南方，陀螺仪状态角也会与原来相差180°。</li><li> N</li><li>┏==┓</li><li>┃⇩⇩┃</li><li>┗++┛  <em>PortraitUpsideDown</em>, gyro.attitude.eulerAngles = <em>180°</em></li><li> S</li><li>这时要将内容方向与现实世界对齐，要旋转设备180°，让内容与现实世界对齐。陀螺仪角度也会随之归位到开始时的角度。</li><li> N</li><li>┏++┓</li><li>┃⇧⇧┃</li><li>┗==┛  <em>PortraitUpsideDown</em>, gyro.attitude.eulerAngles = <em>0°</em></li><li> S</li><li>变化的是设备的方向被旋转了、设备的朝向模式装变成了PortraitUpsideDown。</li><li><strong>总结</strong><ul><li><strong>陀螺仪状态角</strong> 与 <strong>内容朝向</strong> 相对应。不管设备轴向怎么变化，他们的对应关系不会变。</li><li>设备轴向变化时，可以让旋转设备与轴向变化前相同即可实现，将内容朝向恢复到轴变化前的朝向姿态。</li></ul></li></ul></li></ul></li></ul><h2 id="借助陀螺仪实现设备环绕查看物体功能"><a href="#借助陀螺仪实现设备环绕查看物体功能" class="headerlink" title="借助陀螺仪实现设备环绕查看物体功能"></a>借助陀螺仪实现设备环绕查看物体功能</h2><ul><li><strong>利用陀螺仪状态角,可完成精准的360°环绕查看(旋转移动相机)</strong> <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token namespace">UnityEngine</span><span class="token punctuation">;</span><span class="token comment">// 脚本挂载到相机上</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SurroundView</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token class-name">GameObject</span> targetObj<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token class-name">Gyroscope</span> gyro<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">float</span></span> distance<span class="token punctuation">;</span>   <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>      gyro <span class="token operator">=</span> Input<span class="token punctuation">.</span>gyro<span class="token punctuation">;</span>      gyro<span class="token punctuation">.</span>enabled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      distance <span class="token operator">=</span> Vector3<span class="token punctuation">.</span><span class="token function">Distance</span><span class="token punctuation">(</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">,</span> targetObj<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>      transform<span class="token punctuation">.</span><span class="token function">LookAt</span><span class="token punctuation">(</span>targetObj<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name"><span class="token keyword">var</span></span> targetPos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Vector3</span><span class="token punctuation">(</span>        <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>Math<span class="token punctuation">.</span><span class="token function">Sin</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> gyro<span class="token punctuation">.</span>attitude<span class="token punctuation">.</span>eulerAngles<span class="token punctuation">.</span>x <span class="token operator">/</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> distance<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>Math<span class="token punctuation">.</span><span class="token function">Cos</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> gyro<span class="token punctuation">.</span>attitude<span class="token punctuation">.</span>eulerAngles<span class="token punctuation">.</span>y <span class="token operator">/</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> distance<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>Math<span class="token punctuation">.</span><span class="token function">Sin</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> gyro<span class="token punctuation">.</span>attitude<span class="token punctuation">.</span>eulerAngles<span class="token punctuation">.</span>y <span class="token operator">/</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> distance<span class="token punctuation">)</span><span class="token punctuation">;</span>      transform<span class="token punctuation">.</span>position <span class="token operator">=</span> Vector3<span class="token punctuation">.</span><span class="token function">Lerp</span><span class="token punctuation">(</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">,</span> targetPos<span class="token punctuation">,</span> Time<span class="token punctuation">.</span>deltaTime <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>脚本要点解析：</strong><ul><li><strong>targetPos值的确定:</strong>(设:相机到目标物体距离为a，)<ul><li>GyroX角控制水平环绕，GyroX角只控制XPos，所以单独用GyroX计算。<ul><li><strong>x = sin(GyroX)a</strong></li></ul></li><li>GyroY角控制垂直环绕，GyroY角控制YPos、ZPos，所用这两个的值在一个平面一个角算。<ul><li><strong>y = cos(GyroY)a</strong></li><li><strong>z = sin(GyroY)a</strong></li></ul></li></ul></li></ul></li></ul></li><li><strong>利用陀螺仪旋转速度向量，可完成精度较低的环绕查看(旋转模型)</strong> <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token namespace">UnityEngine</span><span class="token punctuation">;</span><span class="token comment">// 挂载到被控制的物体上</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GyroObj</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">float</span></span> speed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 调节旋转速度</span>    <span class="token keyword">private</span> <span class="token class-name">Gyroscope</span> gyro<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        gyro <span class="token operator">=</span> Input<span class="token punctuation">.</span>gyro<span class="token punctuation">;</span>        gyro<span class="token punctuation">.</span>enabled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        gameObject<span class="token punctuation">.</span>transform<span class="token punctuation">.</span><span class="token function">Rotate</span><span class="token punctuation">(</span>gyro<span class="token punctuation">.</span>rotationRate <span class="token operator">*</span> speed<span class="token punctuation">,</span> Space<span class="token punctuation">.</span>World<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 陀螺仪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidADB常用命令</title>
      <link href="2021/02/10/androidadb-chang-yong-ming-ling/"/>
      <url>2021/02/10/androidadb-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="ADB常用命令"><a href="#ADB常用命令" class="headerlink" title="ADB常用命令"></a>ADB常用命令</h1><ul><li><strong>查看设备连接状态</strong><ul><li>adb devices</li><li>注意：设备要在开发者选项里打开usb调试才能用adb命令查找到</li></ul></li><li><strong>安装</strong><ul><li>adb install -r -d “path/xxx.apk”<ul><li>路径使用的是apk名</li><li>-r -d 强制安装</li></ul></li></ul></li><li><strong>卸载</strong><ul><li>adb uninstall “com.xxx.xxx”<ul><li>路径使用的是包名</li><li>adb shell pm list packages 获取硬件上所有包名</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityAR识别-VuforiaNote</title>
      <link href="2021/02/01/vuforianote/"/>
      <url>2021/02/01/vuforianote/</url>
      
        <content type="html"><![CDATA[<h1 id="VuforaiNote"><a href="#VuforaiNote" class="headerlink" title="VuforaiNote"></a>VuforaiNote</h1><h2 id="对象识别：官方文档阅读顺序捷径"><a href="#对象识别：官方文档阅读顺序捷径" class="headerlink" title="对象识别：官方文档阅读顺序捷径"></a>对象识别：官方文档阅读顺序捷径</h2><ul><li><p><strong>对象扫描</strong> <a href="https://library.vuforia.com/articles/Training/Vuforia-Object-Scanner-Users-Guide.html">Vuforia Object Scanner</a></p></li><li><p><strong>Uniyt中的对象设置</strong> <a href="https://library.vuforia.com/features/objects/object-reco/how-to-use-object-recognition-in-unity.html">How To Use Object Recognition in Unity</a></p></li><li><p><strong>识别数据的动态加载卸载</strong> <a href="https://library.vuforia.com/articles/Solution/objecttracker-api-overview.html">The ObjectTracker</a></p></li><li><p><strong>被跟踪对象身上的状态</strong> <a href="https://library.vuforia.com/articles/Solution/tracking-state.html#example">Interpreting Tracking State API Results</a></p></li><li><p><strong>Image作为例子的c#代码参考示例</strong> <a href="https://library.vuforia.com/articles/Solution/how-to-create-and-load-targets-in-unity.html">How to Create and Load Targets in Unity</a></p><ul><li>演示了 var objectTracker = TrackerManager.Instance.GetTracker<ObjectTracker>(); 这个Tracker 一定要在 VuforiaARController.Instance 的<strong>回调函数</strong>当中才能获取到，在其他地方获取不到。</ObjectTracker></li></ul></li></ul><h2 id="增加切换识别的功能按钮"><a href="#增加切换识别的功能按钮" class="headerlink" title="增加切换识别的功能按钮"></a>增加切换识别的功能按钮</h2><ul><li><strong>在Vuforia中加入切换识别的功能</strong> <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">// 开启识别标签</span><span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">bool</span></span> recognitionTag<span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">HideInInspector</span></span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">bool</span></span> currRecognitionState<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    recognitionTag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    currRecognitionState <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment">// 插入打开关闭识别功能</span>    VuforiaARController<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span><span class="token function">RegisterTrackablesUpdatedCallback</span><span class="token punctuation">(</span>OpenCloseRecognition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OpenCloseRecognition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name"><span class="token keyword">var</span></span> objTracker <span class="token operator">=</span> TrackerManager<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetTracker</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>ObjectTracker<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>recognitionTag <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>currRecognitionState<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"&lt;color=red>objTracker"</span> <span class="token operator">+</span> objTracker<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"&lt;/color>: Start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>objTracker <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            objTracker<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            currRecognitionState <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>recognitionTag <span class="token operator">&amp;&amp;</span> currRecognitionState<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"&lt;color=red>objTracker"</span> <span class="token operator">+</span> objTracker<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"&lt;/color>: Stop"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>objTracker <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            objTracker<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            currRecognitionState <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> AR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模型标准文档</title>
      <link href="2021/01/15/modelstandarddoc/"/>
      <url>2021/01/15/modelstandarddoc/</url>
      
        <content type="html"><![CDATA[<h1 id="模型规范文档"><a href="#模型规范文档" class="headerlink" title="模型规范文档"></a>模型规范文档</h1><h2 id="通用控件"><a href="#通用控件" class="headerlink" title="通用控件"></a>通用控件</h2><h3 id="单位-比例统一"><a href="#单位-比例统一" class="headerlink" title="单位(比例统一)"></a>单位(比例统一)</h3><ul><li>在建模型前先设置好单位，在同一场景中会用到的模型的单位设置必须一样，模型与模型之间的比例要正确，和程序的导入单位一致，即便到程序需要缩放也可以统一调整缩放比例。统一单位为米。</li></ul><h3 id="命名参考"><a href="#命名参考" class="headerlink" title="命名参考"></a>命名参考</h3><ul><li><strong>动画</strong><ul><li>Anim</li></ul></li><li><strong>声音</strong><ul><li>Sound</li></ul></li><li><strong>模型</strong><ul><li>Mode</li></ul></li><li><strong>图片</strong><ul><li>Img</li></ul></li></ul><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ol><li>模型分类<ul><li>同类模型一定要打一个组<ul><li>例如有些东西要高亮，那么组成这些东西的所有模型要组成一个组（Group）</li></ul></li></ul></li><li>所有角色模型最好站立在原点。没有特定要求下，必须以物体对象中心为轴心。</li><li>面数的控制。移动设备每个网格模型控制在300-1500个多边形将会达到比较好的效果。   而对于桌面平台，理论范围1500-4000。如果游戏中任意时刻内屏幕上出现了大量的角色，那么就应该降低每个角色的面数。比如，半条命2对于每个角色使用2500-5000个三角面。</li><li>正常单个物体控制在1000个面以下，整个屏幕应控制在7500个面以下。所有物体不超过20000个三角面。</li><li>整理模型文件，仔细检查模型文件，尽量做到最大优化，看不到的地方不需要的面要删除，合并断开的顶点，移除孤立的顶点，注意模型的命名规范。模型给绑定之前必须做一次重置变换。</li><li>可以复制的物体尽量复制。如果一个1000面的物体，烘焙好之后复制出去100个，那么他所消耗的资源基本和一个物体消耗的资源一样多。（比如对称物体，只做一半）</li></ol><h3 id="贴图文件格式和尺寸"><a href="#贴图文件格式和尺寸" class="headerlink" title="贴图文件格式和尺寸"></a>贴图文件格式和尺寸</h3><ul><li>原始贴图不带通道的jpg，带通道的为32位tga或者 png，移动平台尺寸最大别超过1024，贴图文件尺寸须为2的N次方 （8、16、32、64、128、256、512、1024）最大贴图尺寸不能超过1024x1024，特殊情况下尺寸可在这些范围内做调整。</li></ul><h3 id="贴图材质应用规则"><a href="#贴图材质应用规则" class="headerlink" title="贴图材质应用规则"></a>贴图材质应用规则</h3><ul><li>贴图不能为中文命名，不能有重名；</li><li>材质球命名与物体名称一致；</li><li>同种贴图必须使用一个材质球；</li><li>除需要用双面材质表现的物体之外，其他物体不能使用双面材质；</li><li>材质的ID和物体的ID号必须一致；</li><li>一个物体尽量只是用一个材质球；</li><li>带Alpha通道的贴图存储为png格式，在命名时必须加_al以区分。</li><li>模型需要通过通道处理时需要制作带有通道的纹理，在制作树的通道纹理时，最好将透明部分改为树的主色，这样在渲染是可以使有效边缘部分的颜色正确，通道纹理在程序渲染时占用的资源币同尺寸的普通纹理要多.通道纹理命名时应以_al结尾。</li></ul><h3 id="模型绑定及动画"><a href="#模型绑定及动画" class="headerlink" title="模型绑定及动画"></a>模型绑定及动画</h3><ol><li>骨骼必须为IK、CAT、BIP三类，unity不认虚拟体动画，单个物体骨骼数量不超过60个。</li><li>动画帧率、帧数的控制，一般情况下为每秒10帧，一个动画尽量控制在1秒内完成。</li><li>导出动画，分开2个文件，导出没有动作的模型、骨骼，模型需要带有蒙皮信息。之后调节好做动画后导出的就是只有骨骼的fbx文件。</li><li>动画输出<ul><li>无动画的模型作为一个整体输出</li><li>有动画的模型把动画时间线做好整体输出<ul><li>如果动画有问题或变动再单独输出相应模型的模型和动画</li></ul></li></ul></li></ol><h3 id="模型导出"><a href="#模型导出" class="headerlink" title="模型导出"></a>模型导出</h3><ol><li>将烘焙材质改为标准材质球，通道为1，自发光100%</li><li>所以物体名、材质球名、贴图名保持一致</li><li>合并顶点，清除场景，删除没有用的一切物件</li><li>清材质球，删除多余的材质球（不重要的贴图要缩小）</li><li>按要求导出fbx（检查看是否要打组导出），导出fbx后，再重新导入max中查看一遍fbx的动画是否正确</li><li>导出给程序fbx等格式文件统一存放至export文件夹下的子文件夹anim、model、prop</li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标准文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOS打包发布方式总结</title>
      <link href="2020/08/01/ios-da-bao-fa-bu-fang-shi-zong-jie/"/>
      <url>2020/08/01/ios-da-bao-fa-bu-fang-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="IOS打包发布方式总结"><a href="#IOS打包发布方式总结" class="headerlink" title="IOS打包发布方式总结"></a>IOS打包发布方式总结</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>IOS打包发布一般分为以下几种渠道：<ul><li>AppStore</li><li>数据线连接安装的机器直接安装到机器中</li><li>打包出ipa文件，通过Itunes、各种安装助手、网页等方式安装</li></ul></li><li>Appstore需要Apple的审核上架。<ul><li>审核需要各种手续，相对繁琐</li><li>好处在于上架后用户方便安装使用</li></ul></li><li>数据线直连的方式多用于开发测试或者设备不多时自己或和朋友一起使用</li><li>一般在实际分发时肯定不会连电脑一个一个安装，但是又不想上架AppStore走审核流程，那么就会打包出ipa包进行分发安装<ul><li>用Itunes安装需要连接电脑，不是很方便</li><li>用安装助手相对好一些，但是也要借助电脑</li><li>用网页安装的方式是一个比较友好的大规模分发的方式，只需要用户用safari打开网页，点击安装即可安装成功应用，用户体验较好。这也让市场中诞生了一些用此技术方式进行分发的网站，来帮助简化网页方式安装的部署门槛。</li></ul></li></ul><h2 id="打包ipa通过网页方式发布App"><a href="#打包ipa通过网页方式发布App" class="headerlink" title="打包ipa通过网页方式发布App"></a>打包ipa通过网页方式发布App</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><ul><li>网页用itms-services协议获取配置文件(ipa包、图标等地址在配置文件中)并根据其内容获取包数据，并通过Safari游览器调用ios系统服务安装下载的应用</li></ul><h3 id="工作原理及配置方式"><a href="#工作原理及配置方式" class="headerlink" title="工作原理及配置方式"></a>工作原理及配置方式</h3><ul><li>以下来详细描述各种发布ipa网站的核心工作原理（这些网站会增加一些额外的功能来方便用户和发布者，比如让用户扫描二维码打开网站之类的操作，这些不在本文讨论范围）。</li><li>了解这些工作原理后，可以根据需要搭建自己的内网或公网发布平台，来供内部或外部的应用分发</li></ul><ol><li><p>html中用如下如下协议链接来安装ipa包itms-services://?action=download-manifest&amp;url=<a href="https://appinfo/manifest.plist">https://appInfo/manifest.plist</a></p><ul><li><em>(注：url地址更换成自己的配置文件地址，地址必须用 <strong>https</strong> 协议。)</em></li></ul></li><li><p>ipa包的下载地址、图标下载地址在配置文件里，这里的地址 <strong>可以用http协议。</strong></p></li><li><p>工作流配置方案：</p><ol><li>xcode中打包ipa，会有配置文件生成，得到ipa包和配置文件</li><li>修改配置文件中的ipa包和图标等的下载地址为接下来部署的地址</li><li>配置一个局域网或公网web服务器用来下载ipa包，例如在局域网某机器上配置web服务器，把ipa包复制到此服务器，得到<a href="http://192.168.0.2:8080/appName.ipa%E5%9C%B0%E5%9D%80">http://192.168.0.2:8080/appName.ipa地址</a></li><li>配置一个局域网或公网web服务器用来下载配置文件，这里需要配置https协议的web服务器如同上一步得到<a href="https://192.168.0.2:8080/manifest.plist%E5%9C%B0%E5%9D%80">https://192.168.0.2:8080/manifest.plist地址</a></li><li>用html写个下载页面，里面的a标签中的地址根据上面配置的举例修改成如下地址：itms-services://?action=download-manifest&amp;url=<a href="https://192.168.0.2:8080/manifest.plist%EF%BC%8C%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E5%8F%91%E5%B8%83%E6%AF%94html%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5">https://192.168.0.2:8080/manifest.plist，在服务器中发布比html静态网页</a></li><li>此时用ios设备的Safari游览器访问发布的网页，点击写好的a标签，Safari游览器会调用系统功能来加载安装打包好的ipa包</li><li>补充：<ul><li>此方法根据实际应用场景，配置是外网服务器还是局域网服务器实现网页安装ipa包。</li><li>安装后应用的开发者信任问题依赖打包ipa时使用的是什么权限的开发者账号。</li></ul></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOS </tag>
            
            <tag> 打包发布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神机Mi2刷原生Android9</title>
      <link href="2020/04/04/shen-ji-mi2-shua-yuan-sheng-android9/"/>
      <url>2020/04/04/shen-ji-mi2-shua-yuan-sheng-android9/</url>
      
        <content type="html"><![CDATA[<h1 id="神机Mi2刷原生Android9"><a href="#神机Mi2刷原生Android9" class="headerlink" title="神机Mi2刷原生Android9"></a>神机Mi2刷原生Android9</h1><ul><li>Mi2作为一款2013年的神机，又有外国朋友用源码编译适配到了Android9。</li><li>作者帖子：<a href="https://forum.xda-developers.com/mi-2/general/rom-android-8-0-7-1-xiaomi-mi-2-2c-2s-t3707371">点击进入作者原帖(英文)</a></li></ul><h2 id="快速上手刷机"><a href="#快速上手刷机" class="headerlink" title="快速上手刷机"></a>快速上手刷机</h2><ul><li>外国朋友说了很多，我把最主要的列出来，方便快速刷机体验Android9，具体信息可以去看作者原帖 <em>（原帖中指出了哪些功能测试通过、刷机细节、root方式等，有需要的可以去看）</em></li></ul><ol><li>首先刷入recovery：twrp</li><li>然后按音量上和电源键进入recovery</li><li>在recovery中刷入Android包</li></ol><ul><li>其中所需的软件<a href="https://mega.nz/#F!naRFGQDR!d9Uv-Maw56vyYsphAj00Kw">点击此进入下载</a></li><li>下载清单：<ul><li>twrp-3.2.1-aries.img</li><li>aosp-caf-9.0.0-20190101-aries-arch.zip</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 原生 </tag>
            
            <tag> Mi2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件驱动编程-翻译</title>
      <link href="2020/04/04/shi-jian-qu-dong-bian-cheng-fan-yi/"/>
      <url>2020/04/04/shi-jian-qu-dong-bian-cheng-fan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="事件驱动编程"><a href="#事件驱动编程" class="headerlink" title="事件驱动编程"></a>事件驱动编程</h1><ul><li>原文：Event-Driven-Programming: Introduction, Tutorial, History</li><li>作者：Stephen Ferg</li><li>进度：完成所有章节的初步翻译</li><li>翻译：<a href="https://smalbox.top/">SmalBox</a></li><li>原文版权：<a href="http://creativecommons.org/licenses/by/2.5/">Creative Commons Attribution License</a></li><li>翻译版权：<a href="https://raw.githubusercontent.com/SmalBox/Book/master/LICENSE">Apache-2.0</a></li><li>翻译项目地址：<a href="https://github.com/SmalBox/Book">点击查看项目</a></li><li><em>注：译文无配图，图片请参考原文(<a href="https://github.com/SmalBox/Book/blob/EventDrivenProgramming/event_driven_programming.pdf">点击获取原文</a>)</em></li></ul><hr><h1 id="EventDrivenProgramming-Introduction-Tutorial-History"><a href="#EventDrivenProgramming-Introduction-Tutorial-History" class="headerlink" title="EventDrivenProgramming: Introduction, Tutorial, History"></a>EventDrivenProgramming: Introduction, Tutorial, History</h1><ul><li>《事件驱动编程:介绍，教程，历史》</li></ul><h2 id="In-The-Beginning-Transaction-Analysis-开始-事务分析"><a href="#In-The-Beginning-Transaction-Analysis-开始-事务分析" class="headerlink" title="In The Beginning - Transaction Analysis (开始-事务分析)"></a>In The Beginning - Transaction Analysis (开始-事务分析)</h2><ul><li>我的故事开始于1970年后期。在那些日子里，经典的计算机系统是批处理系统。输入数据还是经典的在带子上的顺序文件。这些文件带子旋转，被其他程序处理,然后写入到到其他文件，文件又被其他程序处理，如此反复。计算机系统的标准模式是一个流水线。原始数据从一个门进入，然后他们被反复的处理，最后结果会从另一个门出来。</li><li>这种思维模式奠定了1970年代“结构化”系统开发方式。结构化方法之父是 拉里·康斯坦丁（Larry L. Constantine）。他的父公司是IBM的系统研究所。最成功的结构化倡导者是 爱德华·尤登（Edward Yourdon） 。到这种程度以致 尤登（Yourdon）和结构化分析和设计方法 几乎成为了同义词。</li><li>在1974年，起初结构化这个术语出现在IBM系统之旅的文章中,它们被G,W,L，叫做结构化设计。在1975年，Larry Constantine 的一名学生 G M，在IBM SRI 发表了一篇“通过复合设计获得可靠软件”的文章。然后在1977和1978年，几乎同时地，几个关于结构化方法的重要的书出现了。它们是“机构化设计”-Ed Yourdon，Larry Constantine，“结构化分析和系统详述”-Tom De Marco,“结构化系统分析”-Chris Gane, Trish Sarson,“结构化系统开发”-Ken Orr。也许最有影响力的是Tom De Marco 的 “结构化分析和系统详述” ，这本书在伦敦出版社发布。</li></ul><h3 id="Dataflow-Diagrams-数据流图"><a href="#Dataflow-Diagrams-数据流图" class="headerlink" title="Dataflow Diagrams (数据流图)"></a>Dataflow Diagrams (数据流图)</h3><ul><li>结构化分析使用“数据流图”（DFDs）去展示计算机系统的逻辑结构。在DFD中,顺序文件中的记录被概念化为，通过管道 或 沿着传送带移动的数据包，成为数据流。数据包在各个一系列工作区中传递被叫做“处理”，他们被筛选、使用、增强或者改变，最后通往下一个工作区。这有一个数据流图，来自 “数据分析和系统详述” 的316页。</li><li>图【transform analysis】</li><li>用这种方式描述的系统被叫做 “transform analysis”</li><li>D M又简短的介绍了第二种分析方式，叫做 “transaction analysis” 并且提供了这张图。</li><li>图【transaction analysis】</li><li>他阐述了“transform”和“transaction”分析的不同如下：<ul><li>“transform analysis” 应用于那些能明确区分出 输入流、处理中心、输出流的应用。在数据流图术语中,“transform” 由线性网格表示。</li><li>“transaction analysis” 应用于有着突发并行数据流特性应用的“事务中心”。</li></ul></li><li>D M 实际上只花了很少的时间来条论“事务分析”。但是在“结构化设计”这本书里的这个主题却受到了跟多的关注。在第11章，Y和C将第一次描述事务分析归功于P。Y和C描述事务分析是“一个更灵活，SAPTAD技术的更复杂更新”。</li><li>“事务分析”建议通过数据流图表示，类似于图11.1，一个“transform”分裂出一个输入流，和若干个输出子流。这就是一个事件驱动的原型图。</li><li>图【11.1】</li><li>他说：一个“事务”是从一些“元素的数据、控制、信号、事件、或者状态的改变”开始，然后发送到事务中心做处理。</li><li>一个“事务中心”必须具备如下条件：<ul><li>以原始的形式（获取和相应）获得事务</li><li>分析每一个事务，确定他的类型</li><li>根据事务类型分发</li><li>完成每一个事务的处理</li></ul></li></ul><h3 id="Structure-Charts-结构图"><a href="#Structure-Charts-结构图" class="headerlink" title="Structure Charts (结构图)"></a>Structure Charts (结构图)</h3><ul><li>一个数据流图展示了一个系统必须执行的逻辑功能，但没有说明执行这些功能的程序设计。在结构化分析和设计中，一个不同的图叫做“结构图”，它用来展示程序设计。在“结构图”中，矩形代表模块（函数或子程序）。矩形按等级排列，呼叫模块在上方，被呼叫模块在下方。</li><li>从事务处理数据流图 转换到的结构图如下：</li><li>图【11.2】</li><li>在这个图中，虚线箭头代表控制流从顶部流入事务中心。事务被“GETTRAN”函数获得。一旦事务被捕获，将被分析判断他的类型（它的事务代码）并向上传递给“事务中心”。之后，将发送给“分发”模块，它将根据事务类型分发给不同的事务处理模块。</li></ul><h2 id="The-Handlers-Design-Pattern-处理程序设计模式"><a href="#The-Handlers-Design-Pattern-处理程序设计模式" class="headerlink" title="The Handlers Design Pattern (处理程序设计模式)"></a>The Handlers Design Pattern (处理程序设计模式)</h2><ul><li>如果Y和C的文章写在今天，他们很有可能将他们的“事务分析”的概念叫做设计模式。我将叫它们“处理程序模式”。</li><li>这有一个“处理程序模式”的图.这个图是接着图11.1的事务分析原始数据流图。</li><li>图【Handlers pattern】</li><li>在图中可以看到：<ul><li>有一个数据流叫做“事件”（Y和C叫它“事务”）</li><li>有一个“分发模块”（Y和C叫它“事务中心”）</li><li>还以一系列的处理程序</li></ul></li><li>“分发模块”的工作是获取每个进来的事件，分析事件决定事件的类型，然后发送事件到可以处理对应类型事件的处理程序中。</li><li>“分发模块”必须处理一连串的输入事件流，所以它的逻辑必须包括一个“事件循环”，所以它可以获取事件、分发它，然后循环回来在输入流中处理下一个事件。</li><li>一些应用（例如，控制硬件的应用）可能把事件流看作是无线有效的。但是对于大多数事件处理应用，事件流是有限的，通过在流的最后用一些特殊的事件(一个文件结尾的标志，或者按ESCAPE键，或在GUI上左键点击关闭按钮)标识。在这些应用中，“分发模块”逻辑必须包含“退出”能力来在事件流末尾被发现去结束事件循环。</li><li>在一些情况下，“分发模块”做出的决定可能不能恰当的处理这个事件，它们会丢弃这个事件或者引发（抛出）一个异常。GUI应用一般对类似鼠标按钮点击之类的事件感兴趣，但是对鼠标运动事件不感兴趣。所以在GUI应用中，事件没有处理程序时，通常会被抛弃。对于大多数其他类型的应用，一个不能被识别的事件在输入流中组成一个错误，一个适当的操作是是引出异常。</li><li>这是经典的分发模块的伪代码，来展示一下所有特性：<ul><li>事件循环</li><li>“退出”操作</li><li>判断事件类型，在类型的基础上选择一个恰当的处理程序。</li><li>对没有相应处理程序的处置。</li><li>图【分发模块 伪代码】</li></ul></li></ul><h3 id="The-Headless-Handlers-Pattern-无头处理程序模式"><a href="#The-Headless-Handlers-Pattern-无头处理程序模式" class="headerlink" title="The Headless Handlers Pattern (无头处理程序模式)"></a>The Headless Handlers Pattern (无头处理程序模式)</h3><ul><li>这里有几个处理程序模式的变形体。其中一个是“无头处理程序”模式。在这个模式中，“分发模块”要么确实，要么不是随时可见。去掉“分发模块”，剩下的全部都是事件处理程序的集合。</li><li>图【Headless Handlers Pattern】</li></ul><h3 id="The-Extended-Handlers-Pattern-扩展处理程序模式"><a href="#The-Extended-Handlers-Pattern-扩展处理程序模式" class="headerlink" title="The Extended Handlers Pattern (扩展处理程序模式)"></a>The Extended Handlers Pattern (扩展处理程序模式)</h3><ul><li>另一种变体是“扩展处理程序”模式。在这种变体中，模式包括一个“事件生成器”组件，这个生成器可以生成“分发程序”可以处理的事件流。</li><li>图【Extended Handlers Pattern】</li></ul><h3 id="The-Event-Queue-事件队列"><a href="#The-Event-Queue-事件队列" class="headerlink" title="The Event Queue (事件队列)"></a>The Event Queue (事件队列)</h3><ul><li>在一些案例中，“分发模块”和处理程序可能不能够在事件来的时候尽快的处理他们。在这些案例中，解决方案是将事件输入流存入缓冲区，在事件生成和事件分发当中将“事件队列”引入事件流。事件可以快速的添加到队列的末尾，“分发模块”也可以以最快的速度从队列的前端取出它们。</li><li>GUI应用通常都有事件队列。重要的事件例如鼠标点击可能需要一些事件来处理。在处理当中，其他的事件如鼠标移动事件就要累加在缓冲区中。当缓冲区再次空闲时，它就可以立即抛弃可忽略的事件-鼠标移动事件，然后快速清空序列。</li></ul><h3 id="Some-Examples-of-the-Handlers-Pattern-处理程序-举例"><a href="#Some-Examples-of-the-Handlers-Pattern-处理程序-举例" class="headerlink" title="Some Examples of the Handlers Pattern (处理程序-举例)"></a>Some Examples of the Handlers Pattern (处理程序-举例)</h3><ul><li>现在我们已经介绍了处理程序模式，我应该给你看一些关于这个模式的例子。这些方法和技术可能很相似，但是可能你从来没有在“事件驱动编程”的角度去思考它们。</li></ul><h3 id="Objects-对象"><a href="#Objects-对象" class="headerlink" title="Objects (对象)"></a>Objects (对象)</h3><ul><li>在90年代，面向对象的技术方法逐渐的使七八十年代的结构化的方法失去了光芒。软件方法论者开始用新的图表标记法做实验，去阐述面向对象的概念。与此同时，“对象图”是这些流行的图之一（由GradyBooch发明）。这有一个对象图表的例子。</li><li>图【object diagram of a STACK object】</li><li>在这个“对象图”中，“Stack”是一个对象类型（或者叫做“类”）。“Push”、“pop”、“peek”是他的方法。想要使用“Stack”类，你需要创建stack对象，然后使用对象的方法去做一些事情。</li><li>图【create and usage stack object】</li><li>我喜欢“对象图”，因为它们清楚的展示了一个对象在“无头程序处理模式”中的示例。一个“对象图”，同样的也是一个基本的“无头处理程序”，除了事件是从左面来的而不是从顶部来的。举个例子，Stack类是可以处理“push”、“push”、“pop”事件的一系列事件处理程序（面向对象中叫做“方法”）的集合</li><li>写到这里，如果你是一个面向对象的程序员，你应该已经知道什么是事件驱动编程了。毫不夸张地说，当你在写对象的方法的时候，你就是在写事件的处理程序。</li></ul><h3 id="System-系统"><a href="#System-系统" class="headerlink" title="System (系统)"></a>System (系统)</h3><ul><li>正如我们所看到的，在“结构化系统分析“中，计算机系统被概念化为工厂。原始的原料流入工厂，在传送机的带子（数据流）上前向流动，穿过工作站（处理）最终结束旅程的产品被从门推出。</li><li>原始原料的提供者是“源（sources）”，最终产品的消费者是“盥洗盆（sinks）”。“sources”和“sinks”是数据流的“终端（terminator）”-（它们是数据流开始和结束的地方）。</li><li>“上下文关系图”用来展示系统在终端上下文中关系的状况。这有一个上下文关系图，来自De Marco 的“结构化分析和系统详述”中第59页。</li><li>图【context diagram】</li><li>在1984年，Stephe McMenamin 和 John Palmer 发表了 “基本系统分析（Essential Systems Analysis）”（ESA）。ESA 建立并扩展了结构分析的早期工作，但是它也介绍了计算机系统的概念模式中基本的变化。</li><li>ESA 认为计算机系统不是一个工厂，是一个激励/反馈的机器。激励是在外部世界中，通过终端发送到系统的事件。系统自己概念化为一系列事件处理程序（基本活动）。当一个事件到达，系统就活动了起来，基本活动开始处理事件，然后系统再次进入睡眠状态（静默），直到下一个事件到来。</li><li>基本活动反馈事件是通过在系统核心的数据存储中读写，和产生输出数据流的方式。系统的数据存储构成了“基本内存（essential memory）”。</li><li>这张图展示了计算机系统的基本部分，他们是概念化的ESA。</li><li>图【Characteristic shape of an event-partitioned DFD】</li><li>基本上，ESA展示了一个简单的计算机系统，是一个巨大的面型对象风格对象。系统的基本活动是对象的方法，基本内存是他的内部数据。这个对象是“无头处理程序模式”的例子，它的方法扮演了处理程序的角色，所以在这里完整的计算机系统是一个“无头处理程序模式”的例子，基本活动扮演了处理程序的角色。</li><li>“处理程序模式”中，最完善的系统概念化是JSD（Jackson System Development），都写在了 Michael Jackson 的“系统开发”（1983）这本书中。JSD 是好方法，以论证的方式第一次真的面向对象分析和设计方法。</li><li>JSD系统的设计用SID（system implementation diagram 系统执行图）展示。这是一个典型的SID，来自“系统开发”的293页。</li><li>图【SID】</li><li>在图的顶部，我们看到的“分发模块”在JSD中叫做“调度程序（scheduler）”。事件流从外部系统到达；它叫做SCIN（“调度输入程序 scheduler input”）。事件被发送到CUST-1或ENQ（事件处理程序）。系统内部数据存储到数据库表中，这个表叫做“状态向量（state vector）”文件（成为SVFILE）。EREPLIES是响应中生产出的答复流，去处理询问事件。</li><li>CUST-1 和 ENQ 不是函数；他们是完整对象。这意味着JSD在两个层面使用了“程序处理模式”。在上层，整个系统以完整的“处理程序模式”为出发点，调度程序作为分发模块，对象做事件处理者。第二层面向对象方式的对象，这些方法函数作为事件的处理程序，处理从调度者或者其他对象来的事件。</li><li>ESA 和 JSD 标志着我们的思想从早期的结构化方法中发生巨大的转变。发生巨大转变的原因是，快速发展的数据库技术的出现。在早期的结构化分析的日子里，“数据库管理系统（DBMSs）”基本上不存在。但是，到ESA和JSD出现的时候，计算机化数据处理快速发展，从批处理系统处理顺序文件到在线系统处理数据库。首先它是链接起来的表 DBMSs （IBM 的 IMS， Cullinane的 Cullinet，和 Cincom 的 Total）。紧接着是反向列表DBMSs（adabas，模式204），接下来是关系数据库（DB2，Ingres，Oracle）。DBMS技术的进步便随着数据库设计方法学的开发。</li><li>随着数据库技术的进步和其大规模的使用，大量的开发者都来使用数据库（不是访问他的软件）最为计算机系统的核心。因此，计算机系统的新模式 -作为一系列事件处理程序周边并提供接口给作为系统核心的数据库- 在那时候是非常棒的产品。</li></ul><h3 id="Client-Server-Architecture-客户端-服务器架构"><a href="#Client-Server-Architecture-客户端-服务器架构" class="headerlink" title="Client-Server Architecture (客户端-服务器架构)"></a>Client-Server Architecture (客户端-服务器架构)</h3><ul><li>在CS（Client-Server）架构中架构中有一个“处理程序模式”的熟悉示例。“server”是硬件或者软件的管线，它给“客户端”提供了服务。服务端的工作是等待来自客户端的“服务请求”，根据提供的请求服务反馈“服务请求”，然后等待更多的请求。服务端的例子包括：打印服务，文件服务，窗口服务，数据库服务，应用服务和web服务。如果你经常在网上冲浪，你是在和服务器互动，每当你访问一个新的地址，你的web游览器发送一个请求到web服务器，你请求的web页会反馈你的请求。</li><li>Wesey Chun 在“Python 编程核心”的16章中提供了一个简短、清晰的解释来描述“客户端-服务器“架构的基础。（我想稍微的修改了一下文本来提高技术的连贯性）。想象一下，Chun 说：<ul><li>一个既不吃也不睡，也不休息的空闲柜员，在一个从来看不到尾的流水线中服务一个又一个顾客。流水线可能会很长或者有时会空闲，但在任何时候，顾客都有可能会出现。当然，这些柜员是多年前幻想出来的，但是现在的自动柜员机（ATMs）是很接近这个模型的。</li><li>当然，这些柜员是在无限运行的服务器。每个客户端都要发送一个请求服务器的“服务请求”。客户端的请求到达服务器，并以先来先服务的方式处理请求。一次交互完成，客户就走了，服务端要么服务下一个客户，要么等待直到下一个随之而来的客户。</li></ul></li><li>这有一个案例，描述了“处理程序模式”这个术语。</li><li>图【client-serer Handlers pattern】</li><li>每个银行顾客代表了一个从客户端发送来的服务请求（事件，事务）。</li><li>客户排队或者等候服务。服务端和不知疲劳的柜员很相似，因为它们都是事件处理程序的集合，都能处理不同的事件请求。并且银行柜员的“无限循环”也就是“分发模块”的事件循环。</li></ul><h3 id="Messaging-Systems-消息系统"><a href="#Messaging-Systems-消息系统" class="headerlink" title="Messaging Systems (消息系统)"></a>Messaging Systems (消息系统)</h3><ul><li>“消息系统”代表了“程序处理模式”的极端版本。“消息系统”的目的是，在发送者和接收者在不同的物理位置或者运行在不同平台上的情况下，从事件的生成者（发送者）获取事件（消息）并处理（接收者）消息。</li><li>在“消息系统”中，消息通常发送给特定的接收者，所以分发函数（决定接收者应该接收什么消息）是很普通的函数。一个熟悉的“消息系统”的例子是邮局。一个发送者发送一个消息（信件或者包裹）到邮局（“消息系统”）。邮局在消息中读取收信者的地址，并且传送信息给收信者。</li><li>图【Messaging System】</li><li>E-mail “消息系统”本质上和邮局的功能差不多。唯一的不同是E-mail的消息是电子编码而不是物理编码。</li><li>可能大多数精密的消息系统是企业的消息系统，使用“面向消息的中间件”或者MOM。在MOM系统中，发送者和接收者是计算机应用，而不是人。MOM系统允许计算机应用在物理分离或者运行在不同的软硬件平台下互相通信。例如，一个大公司的办公区和服务器在地理位置上分散。MON软件允许在公司的LA处的管理入口系统以电子的形式发送给在Chicago服务器上的应用一个指令结束，也可以在纽约服务器上的程序管理报道，全都不需要人干预。</li><li>再加上，对于这种点对点的通讯模式，MOM产品也支持发布/订阅模式。在发布/订阅模式中，接收者成为了通过主题订阅的订阅者，发送者要发送消息到主题中，而不是个人订阅者）。当主题收到消息，这个主题会将消息发送给所有订阅它的接收者。</li><li>图【publish/subscribe model】</li><li>在MOM系统中，电子通信问题（队列问题，发布/订阅模式的执行问题）使系统的处理程序方面变得简单。然而，这么做的目的使帮助理解MOM系统，作为一个极端简单且专用的处理程序模式的例子。</li></ul><h2 id="Frameworks-框架"><a href="#Frameworks-框架" class="headerlink" title="Frameworks (框架)"></a>Frameworks (框架)</h2><h3 id="Object-Oriented-Event-Driven-Programming-面向对象事件驱动编程"><a href="#Object-Oriented-Event-Driven-Programming-面向对象事件驱动编程" class="headerlink" title="Object-Oriented Event-Driven Programming (面向对象事件驱动编程)"></a>Object-Oriented Event-Driven Programming (面向对象事件驱动编程)</h3><ul><li>现在让我们来看一个全景 - “程序处理”模式在现代计算机的不同方面是怎么体现的。然我们在代码层面看“程序处理”模式是怎样工作的。</li><li>考虑到与客户打交道的业务。业主自然想有一个信息系统来存储、恢复、更新他顾客信息的账户。他想要的系统可以处理各种事件：需要添加一个新的客户账户，可以修改账户名、关闭账户，诸如此类。所以系统必须有处理各种类型事件的事件处理程序。</li><li>图【business information system】</li><li>在面向对象编程出现之前，这些事件处理程序作为子程序来执行。这些代码在分发模块的事件循环中，像下面这样：</li><li>图【dispatcher pseudo-code】</li><li>子程序的类似这样：</li><li>图【subroutines pseudo-code】</li><li>现在，使用面向对象技术，事件处理程序作为对象的方法执行。这些代码在分发模块的事件循环中，像下面这样：</li><li>图【dispatcher OO pseudo-code】</li><li>“账户”类和他的方法（事件处理函数），像下面这样：</li><li>图【account class methods】</li><li>使用面向对象技术这种方式没有很激动。基本上来说，我们只是用对象取代了数据库记录；换句话说，数据处理的过程没什么变化。</li><li>但是它变得更有趣……</li></ul><h3 id="Frameworks-框架-1"><a href="#Frameworks-框架-1" class="headerlink" title="Frameworks (框架)"></a>Frameworks (框架)</h3><ul><li>使用面向对象技术可以相对容易的开发普遍的、可复用的类。这是面向对象技术的一个优势。</li><li>举个例子，假设有一个商业的，多用途的业务类产品-“通用业务”。通用业务是一个软件框架，可以直到怎样展示多样的一般化商业功能（打开顾客账号，关闭顾客账号，诸如此类）。显然，因为所有的业务不同，通用业务允许可以根据业务特定的需求定制框架。</li><li>假设接下来，Bob是一个小的业务员，他买了一个通用业务软件。在他使用软件之前，Bob需要根据他的需求定制软件。我们能想到Bob有很多定制化的事情要做：他的名字、他卖的东西的名字、它允许使用哪种信用卡，诸如此类。但是经过讨论，让我们看看Bob最急迫的需求，他想定制通用业务来使用MySQL存储账号信息。</li><li>通用业务是已经写好的。他不能预测到企业将使用哪个DBMS。这意味着通用业务（就算知道怎样打开和关闭用户账号）不知道怎样持久化数据库的账户数据。当然，他也不可能知道企业用什么DBMS（Oracle， Sybase， DB2， MySQL，Postgres），通用业务不知道在账户类的“persist()”方法中该写什么代码。</li><li>这意味着Bob必须自己在他的“persist()”方法中写代码。</li><li>也就是说，通用业务有个问题，它怎么确保像Bob这样的用户会给“persist()”方法写代码呢？</li><li>通用业务给出的解决方法不是提供一个全功能的账户类，而是提供半成品类（仅实现全功能账户类的某些方法）。实现的这部分，我们叫它通用账号类。通用账号类提供一些方法的完整实现，并且给像Bob这样的业务员预留了“插入点”，Bob必须添加他的业务代码。</li><li>“插入点”是代码中的位置，在软件框架中期望事件处理程序插入的地方。事件处理程序本身叫做“插件（plug-ins）”</li><li>包含“插入点”的半成品类的技术学名叫做“抽象类”。不同语言提供不同的方式定义插入点。例如，java提供了关键字“abstract”和叫做“abstract methods”的插入点。</li><li>抽象方法不是真的方法。而是方法的占位符；一个可以插入具体方法的地方。包含抽象方法的Java类叫做抽象类。抽象类不能实例化。使用抽象类的唯一方法是创建一个子类开扩展它，然后在子类中定义具体方法（实现抽象类中每一个抽象方法）。Java强制执行此要求。Java不能编译通过企图实例化抽象类的程序。</li><li>这意味着，Bob使用通用业务的通用账号类的方法是他自己创建一个具体的类来扩展它，并且实现抽象方法。如果通用账号类如下：</li><li>图【an abstract lass GenericAccount】</li><li>Bob的账号类如下：</li><li>图【extends GenericAccount】</li><li>Python,一个动态语言，以不同的方式支持“插入点”和抽象类。在Python中，实现一个“插入点”最简单（其他实现抽象方法的方式在附录A中）的方法是定义一个什么都不做的方法，但是提出异常（raise exception）。如果方法没有完全实现，并且有程序调用它，那么就会触发运行时异常。这有一个python写的抽象方法的例子：</li><li>图【python abstract method】</li><li>一条软件的通用术语是这样的工作方式（定义“插入点”，然后需要插件补充）是“框架”。如果你Google搜索术语“框架”以你会获得这样的一些定义。每个定义都包含框架的一部分。一个框架是：<ul><li>用于支撑或者封闭其他的一些东西的骨架结构。</li><li>一个广泛的概述、大纲或者框架，可想向其中添加细节。</li><li>一个可扩展的软件环境，可以根据特定需求定制。</li><li>一系列类，为一些应用的问题提供通用的解决方案。一个框架通常精炼以通过专业化或其他类或类型解决特定问题。</li><li>一个组件，它允许通过写插件模块（框架扩展）的方式扩展其功能性。扩展的开发者通过从框架中定义的类接口写自己的类。</li><li>软件主体设计成高复用模式，加上特定功能的插件以适应特定的系统的功能性需求。当安装了插件，系统将围绕插件表现出相应的行为。</li></ul></li><li>这个框架模式的基本概念是“处理程序模式”。“框架扩展”或者“插件”是“事件处理”模块。</li><li>图【framework and entensions(handlers)】</li></ul><h3 id="SAX-an-example-of-a-framework-框架举例-SAX"><a href="#SAX-an-example-of-a-framework-框架举例-SAX" class="headerlink" title="SAX - an example of a framework (框架举例-SAX)"></a>SAX - an example of a framework (框架举例-SAX)</h3><ul><li>框架有各种形状尺寸，从大到小都有。开看一下真实的框架是怎么使用的，然我们来看一个小框架：SAX（实际上，SAX不是一个框架。他可以在框架中实现的API。但是为了保持事情简单，我们就当它是个框架）。</li><li>XML越来越流行。只有一个结果，就是很多开发者第一时间在SAX（一个简单的XML API）框架中遇到了事件驱动编程。SAX是事件驱动的XML语法分析器。它的工作是打开（解析）XML成可理解的片段。例如，SAX分析器可以分析以下字符串：</li><li>图【XML string】</li><li>解析成如下三个片段：</li><li>图【three pieces】</li><li>使用SAX解析器，你给他一大块XML字符串。它解析XML文本成不同的片段，然后调用适当的预先确定的插件（事件处理程序）去处理片段。</li><li>SAX为解析各种XML的特征，诸如打开和关闭标签（startElement，endElement），标签中间的文本，注释，处理指令等等，制定了预定义的插入点。</li><li>SAX框架提供了“解析器（Parser）”类和一个抽象类“内容处理器（ContentHandler）”。使用它，首先要创建ContentHandler的子类，并且写一个具体的方法（事件处理模块）去覆写抽象方法。这有个用python写的简单例子。它在控制台打印XML的标签名和标签中的数据。（完整的python SAX例子可以在附件B）。</li><li>图【over-ride abstract methods】</li><li>你扩展“内容处理程序”类和指定事件处理程序：<ul><li>使用SAX的 make_parser 工厂函数解析器对象。</li><li>实例化“CustomHandler”类创建一个“myContentHandler”对象</li><li>告诉解析器对象使用“myContentHandler”对象处理XML内容</li><li>将XML文本传给解析器，让事件处理模块去工作</li></ul></li><li>这有用Pyhton怎样完成的过程：</li><li>图【python parse XML in file】</li></ul><h3 id="Why-programming-with-a-framwork-is-hard-为什么用框架编程很难"><a href="#Why-programming-with-a-framwork-is-hard-为什么用框架编程很难" class="headerlink" title="Why programming with a framwork is hard (为什么用框架编程很难)"></a>Why programming with a framwork is hard (为什么用框架编程很难)</h3><ul><li>到处理只由输入XML文本给解析器（没有更多了）构成的程序的最后一步了。对于一个面向过程背景的程序员，对事件驱动编程会很困惑。在面向过程编程中，控制的主要流程在主程序之内。附属程序或者模块仅仅是公用程序或者帮助调用展示低等级的任务。主程序的控制流通常很长并且复杂，它的复杂让应用有特定的逻辑结构。程序具有形状，并程序员可以看到该形状。</li><li>但是当面向过程的程序员开始使用框架编程，他失去了所有的控制权。没有了清晰的控制流（主程序除了开始了框架的事件循环什么也没做）。并且一旦事件循环开始了，隐藏在框架中的代码就驱动开始动作。该程序剩余的部分仅仅是帮助程序模块（事件处理程序）的集合。总之，程序结构看起来被彻底搞砸了。（框架和公共库是不同的。当使用公共库时，程序员可以完全控制程序流程，当他们需要公共库时调用它们，主动权在程序员。但是在框架中，是在框架需要时，框架负责调用程序员写的事件处理程序模块。主动权在框架。这是谁负责的问题。）</li><li>所以面向过程的程序员经常发现，在它们第一次遇到事件驱动和框架驱动编程时觉得完全不能理解！经验和熟悉会逐步减少这种感觉，这是毫无疑问的（从面向过程编程转移到事件驱动编程时一个很大的心里范式的转变）。这就是Robin Dunn 和 Dafydd Rees 在文章开始时描述的范式转变。</li></ul><h2 id="GUI-programming-GUI编程"><a href="#GUI-programming-GUI编程" class="headerlink" title="GUI programming (GUI编程)"></a>GUI programming (GUI编程)</h2><h3 id="Why-GUI-programming-is-hard-为什么GUI编程很难"><a href="#Why-GUI-programming-is-hard-为什么GUI编程很难" class="headerlink" title="Why GUI programming is hard (为什么GUI编程很难)"></a>Why GUI programming is hard (为什么GUI编程很难)</h3><ul><li>现在我们看到了框架时如何工作的，来让我们看一下最常用的框架和事件驱动编程：GUIs（图形用户界面 graphical user interfaces）</li><li>GUI编程时困难的，们个人都这么认为。</li><li>首先，只需的指定GUI的外观就需要大量工作。每个窗口小部件（每个按钮、标签、菜单、输入框、列表框等等）都必须告诉它应该长什么样（形状、大小、前景色、背景色、边框样式、字体等等），他应该能确定他自己的位置，比如怎样在GUI大小改变时做出适配，怎样适应整个GUI的层次结构。仅仅是指出GUI怎么展现就有大量的工作。（这就是为什么框架中会有IDEs和屏幕画家。它们的工作就是减轻GUI编程的负担）</li><li>第二（与本文主题最相关），GUI编程很难是因为在GUI中有各种事件要处理。几乎每个GUI中的窗口小部件（每个按钮、多选框、单选框、数据输入区域、列表框（包括列表中每个项目）、文本框（包括水平和垂直滑块）、菜单栏、菜单栏图表、下拉菜单、下拉菜单中的每一项 等等很多）。几乎每个都是事件生成器，都能生成各种类型的事件。这还没完，硬件输入设备也是事件生成器。鼠标可以生成左键点击、右键点击、左键双击、右键双击、按钮按下事件（为了初始化拖拽操作）、鼠标移动事件、按钮抬起事件（为了结束拖拽操作）等一些其他事件。键盘上每个字母、数字、可敲击的按键和功能按键（包括单独和与SHIFT、ALT、CONTROL组合的按键）都可以生成事件。有大量的事件被送入“分发”模块的事件循环，GUI程序员必须为每个GUI用户可能生成的事件写好事件处理程序。</li><li>第三，事实上每个GUI工具包都以框架的形式提供给程序员。GUI框架（像SAX框架）的目的是减轻GUI程序员的负担。举个例子，GUI框架提供事件循环和事件队列来缓解程序员的工作。但是，正如我们看到的SAX，使用框架就意味着大块的程序控制流被隐藏在框架的封装机器当中，并且对与GUI程序员不可见。这意味着GUI程序员必须掌握范式的转变，转移到事件驱动编程。</li><li>这有很多事要处理。这还不是全部，这又“观察者”模式需要掌握……</li></ul><h3 id="The-Observer-Pattern-观察者模式"><a href="#The-Observer-Pattern-观察者模式" class="headerlink" title="The Observer Pattern (观察者模式)"></a>The Observer Pattern (观察者模式)</h3><ul><li>观察者模式在GUI框架的事件驱动编程中使用的很广泛。所以我们用迂回的方式来解释观察者模式。等到这个话题结束，我们将返回到GUI编程上面来，并给出观察者模式是怎样在GUI编程中使用的。</li><li>第一次命名和描述观察者模式是在有名的“Gang of Four”的书“设计模式”中（出自 Gamma，Helm， Johonson， Vlissides （Addison-Wesley， 1995））。 观察者模式的基本想法Dafydd Rees引用了导言中的原理。这个原理是“好莱坞原理”：“不要来找我，我会叫你”。当然这个名字来自于演戏或者电影的演员试镜中。导演（电影中掉选角色的人），不想受到想演他的戏还没得到角色的演员找他的困扰，所以他告诉大家，“不要来找我们，我会回来找你”。</li><li>好莱坞原理更长的版本是：<ul><li>“不要来找我们，给我们你的电话，当我们想给你一份工作的时候我们会找你”。</li></ul></li><li>这就是观察者模式的本质。</li><li>在观察者模式中，有一个主体和多个观察者实体。在试演场景中，导言就是主体，演员就是观察者。当事件发生（导演对他们感兴趣）的时候观察者想要主体通知它们，所以它们在主体那里注册（留下能找到他们的方式说明）。当感兴趣的事情（比如选好了演员）发生时，主体就会通知它们。为了完成这项工作，主体要保存一个列表，列表中记录了所有注册观察者的名字和地址。当有趣的事情发生时，他会通过他的观察者列表去通知在这类事件中注册此类事件的哪个观察者。</li><li>观察者模式也叫做“发布/订阅”模式。回想一下订阅报纸的例子。在“发布/订阅”模式中，主体就是信息或出版物的发布者。观察者就是出版物的订阅者。注册的过程叫做订阅，通知的过程叫做发刊。“发布/订阅”是个合适的名字，适用于长时间内重复发生通知/发布的情况，相同的通知发送给多个订阅者，并且订阅者可以取消订阅。</li><li>观察者模式是事件处理模式中的特殊例子，原因是我觉得更应该叫做订阅程序处理模式。</li><li>下一页使用python实现的观察者模式。在这个例子中，还继续使用好莱坞的主题，观察者是演员。主体是一个天才代理人叫做HotShots。演员在天才代理人那里注册，当有一个演员角色的试镜，代理人会通知演员。自从代理人不断地给演员发通知，这个例子就有了发布/订阅模式的味道。</li><li>（如果你是Java程序员，请不要担心，事实上我们是想减少定义CastingCall和Observer类。这在像python这种动态语言中是可能的，现在这里是为了保持代码简短。在Java中，你需要声明类和它们的实例变量的细节）。</li><li>图【Python showing Observer pattern】</li><li>正如你在代码中看到的那样，天才代理人（主体）是它自己的事件处理程序。具体的说，他的“notify”方法是“CastingCall”事件的事件处理程序。</li><li>天才代理人通过发送“CastingCall”到它自己的“notifyActors”方法来处理“CastingCall”。“notifyActors”方法通过通过代理人的订阅人/观察者/演员列表找到相应人选并且发送通知给合适的订阅者。</li><li>在真实的应用中，通知的过程将包括与每个演员（事件处理程序）联系，演员会通过选角的方式来回应。然而，在这个简单的例子中，通知的过程只包含了打印一个信息来说明这个演员被通知了。</li><li>如果你运行这个程序，会得到如下输出：</li><li>图【Python showing Observer pattern Output】</li></ul><h3 id="Event-Objects-事件对象"><a href="#Event-Objects-事件对象" class="headerlink" title="Event Objects (事件对象)"></a>Event Objects (事件对象)</h3><ul><li>这个程序有个功能，你应该特别注意。它使用了CastingCall对象的时候带着参数（实例化变量）“source”和“role”。在这里，CastingCall对象是事件对象（控制事件的对象）。</li><li>事件对象是事件驱动编程中非常好的工具。在面向对象的编程语言中，事件或者事务都是极端受限的。在一些案例中，如果你想发送一个事件到以事件处理器中，你发送的所有都是一个包含事务代码的字符串。但是面向对象技术通过允许我们创建和忽略事件对象完全的改变了它。事件对象的本质是将我们需要的时间信息打包起来。</li><li>一个事件对象当然也可以携带触发它事件种类的名字。但是，依赖与应用，它可以携带更多信息。在这个HotShots天才代理的案例中，事件对象包含选角色的“source”和role信息。</li><li>在其他应用中，我们可能想放入大量完整的信息到我们的事件对象中。考虑一下著名的Model-View-Controller（MVC）模式。观察者模式就是MVC的核心。在MVC中，Model是一个管理数据和一些应用域的对象（它是观察者模式中的主体）。Views在Model中作为观察者注册。当Controller改变了Model，Model就会通知订阅它的观察者（Views）这个（Model）改变了。</li><li>最简单的MVC版本被叫做“pull”（拉取）版本。在这个版本中，事件对象（当Model变化时，Model向Views发送的通知）几乎不包含什么信息。Model的描述没有改变，他只是通知Views发生了某种变化。当Views收到了这样的通知，它们必须从Model拉取信息。这样，它们必须询问Model当前状态的信息，并且从这些信息中刷新它们自己的状态。</li><li>大多数复杂的MVC版本叫做“push”（推送）版本。在这个版本中，Model 推送变化信息给Views。事件对象发送给Views，对象包含了大量复杂的信息（Model产生的一个完整详尽的变化描述）。当Views收到了这些信息，它就拥有了所有信息，他会根据这些信息更改他自己。</li><li>MVC的“push”和“pull”版本的根本区别简单来说就是放入事件对象包中的信息总数不同。</li></ul><h3 id="The-Registered-Handlers-pattern-in-GUI-applications-GUI应用程序中的“注册处理程序”模式"><a href="#The-Registered-Handlers-pattern-in-GUI-applications-GUI应用程序中的“注册处理程序”模式" class="headerlink" title="The Registered Handlers pattern in GUI applications (GUI应用程序中的“注册处理程序”模式)"></a>The Registered Handlers pattern in GUI applications (GUI应用程序中的“注册处理程序”模式)</h3><ul><li>现在你已经熟悉了基本的 观察者/注册 处理程序模式，来让我们看看这个模式在GUI编程中是如何使用的。</li><li>这有另一个程序的代码。在结构上，这段代码和Hotshots天才代理的代码很像，但是名字用了处理程序模式的专用术语，事件是GUI事件。</li><li>在这个例子中，“主体”是分发模块（工作在GUI中的事件循环）。</li><li>为了保持代码简短，程序只包含观察者（“demoHandler”函数是双击鼠标左键的事件处理函数）。</li><li>展示这个处理程序的动作，程序生成一个模仿鼠标左键双击的事件（LeftMouseDoubleClick 事件）。</li><li>图【Python showing Registered Handlers pattern】</li><li>如果你运行这个代码，会得到如下输出：<ul><li>图【Handling LeftMouseDoubleClick from mouse】</li></ul></li><li>在如下语句中：<ul><li>图【demoDispatcher.registerObserver( demoHandler, MOUSE_LEFT_DOUBLE)】</li></ul></li><li>和这句：<ul><li>图【observer.eventHandler = argEventHandler】</li></ul></li><li>程序在传递“demoHandler”函数对象的引用。它这是将函数作为“全功能对象”（支持所有操作，基本的包括：作为参数传递、从函数返回、赋值给其他变量）。这不是所有的编程语言都支持的，也就是意味着，在不同的编程语言中，实现观察者/注册处理程序模式的方式会很不一样。</li></ul><h3 id="Registering-Event-Handlers-in-Python-“Binding”-Pyhton中的注册事件处理程序-“绑定”"><a href="#Registering-Event-Handlers-in-Python-“Binding”-Pyhton中的注册事件处理程序-“绑定”" class="headerlink" title="Registering Event-Handlers in Python - “Binding” (Pyhton中的注册事件处理程序-“绑定”)"></a>Registering Event-Handlers in Python - “Binding” (Pyhton中的注册事件处理程序-“绑定”)</h3><ul><li>这些是“注册处理程序”模式后的基本思想。现在让我们看一下在Python和Java的GUI应用中“注册处理程序”模式是什么样的。</li><li>开源动态语言如：Python、Perl 和 Ryby 通常提供多样的开源GUI框架接口开支持GUI编程。在Python中，也提供了一些这样的接口。最流行的是tkinter（向Tcl/Tk提供的接口）和wxPython（向wxWidgets提供的接口）。</li><li>使用这些接口的基本概念是非常相似的。在接下来的讨论中，我会用Python和tkinter的例子，来阐述在GUI编程中“注册处理程序”模式的样子。</li><li>在Python和tkinter中，所有的GUI事件都术语一个单独的类：“event”。事件处理程序带着GUI窗口小部件（按钮之类的）注册到程序中，为了处理特定类型的事件，比如鼠标点击，按键按下。在PYthon中，注册一个事件处理程序的过程叫做“binding”（）绑定。</li><li>这有个简单的例子。假设我们的程序已经有了一个事件处理程序（一个函数或者方法）叫做“OKButtonEventHandler”。它的工作是处理发生在GUI中的“OK”按钮上的事件。</li><li>注意，在Python中没有特别或者神奇的事情发生，Python中没有叫做“OkButtonEventHandler”的程序（只要我们想，我们可以将这个程序的名字叫做“Floyd”或者“Foobar”都可以）。我们将要看到是Python和Java中唯一不同的地方。</li><li>接下来的代码片段创建了在观察者模式中的“subject 主体”窗口小部件。这个主体是一个GUI窗口小部件（一个按钮），它可以展示文本“OK”。这个OK按钮对象是一个Tkiner.Button类的实例对象。</li><li>图【OkButton = Tkinter.Button(parent, text=”Ok”)】</li><li>在调用Button类的构造函数中，“parent”参数链接了按钮对象到其所有者的GUI对象上（可能是框架或者窗口）。</li><li>Tkinter小部件提供了一个叫做“bind 绑定”的方法来将事件绑定到窗口小部件上。更精确的说，“bind”方法提供了一种绑定或者说结合三个不同的事情：<ul><li>一个事件类型（例如，鼠标左键点击，或者在键盘按下回车键）。</li><li>一个窗口小部件（例如，在GUI上一个特定的按钮窗口小部件）。</li></ul></li><li>例如，我们想在窗口的“关闭”按钮上绑定一个鼠标左键单击的函数或者方法：“closeProgram”。想要的效果是，当用户鼠标点击“关闭”按钮时，调用“closeProgram”关闭窗口。</li><li>这有一个代码片段，绑定了一个OKButtonEventHandler程序和键盘事件（“&lt;Return&gt;”）的组合到OKButton窗口小部件：</li><li>图【OkButton.bind(“&lt;Return&gt;”, OkButtonEventHandler)】</li><li>该语句将作为观察者的OkButton窗口小部件和OkButtonEventHander函数注册到键盘事件“&lt;Return&gt;”中（当Ok按钮对象获得键盘焦点时发生的事件）。</li><li>这有另一段代码片段（可能就在同一个程序中发生，就在上一个代码之后）。它绑定了OkButtonEventHandler程序和鼠标左键点击事件到Ok按钮窗口小部件：</li><li>图【OkButton.bind(“&lt;Button-1&gt;”, OkButtonEventHandler)】</li><li>当这两个事件中的任何一个发生了，事件将事件对象作为参数发送给OkButtonEventHandler函数。OkButtonEventHandler函数可以（如果他想）询问事件对象，并且决定是否触发一个按键按下或者鼠标点击事件。</li></ul><h3 id="Registering-Event-Handlers-in-Java-“listeners”-Java中的注册事件处理程序-“监听”"><a href="#Registering-Event-Handlers-in-Java-“listeners”-Java中的注册事件处理程序-“监听”" class="headerlink" title="Registering Event-Handlers in Java - “listeners” (Java中的注册事件处理程序-“监听”)"></a>Registering Event-Handlers in Java - “listeners” (Java中的注册事件处理程序-“监听”)</h3><ul><li>Java也支持GUI事件处理程序注册技术，但是它的方式和Python的有些不一样。</li><li>Java提供了多种GUI编程的选择（AWT和Swing）。这允许程序员可以用两种方式创建GUI的视觉层，并且监听GUI事件。</li><li>对于GUI的事件处理方面，java.awt.event包提供了许多不同的事件对象类型：<ul><li>ActionEvent        InvocationEvent</li><li>AdjustmentEvent    ItemEvent</li><li>ComponentEvent     KeyEvent</li><li>ContainerEvent     MouseEvent</li><li>FocusEvent         MouseWheelEvent</li><li>InputEvent         PaintEvent</li><li>InputMethodEvent   TextEvent</li></ul></li><li>这些事件的类型每个都包含适合它类型的变量和方法。例如，“MouseEvent”对象包含鼠标事件的变量个方法，“KeyEvent”对象包含键盘事件的变量个方法。举个例子：<ul><li>“MouseEvent.getButton()”传递了鼠标按钮引发的事件。</li><li>“MouseEvent.getClickCount()”传递了触发鼠标点击的数量的事件</li><li>“MouseEvent.getPoint()”告诉在GUI组件中鼠标光标位置的x，y坐标。</li><li>“KeyEvent.getKeyChar()”告诉了键盘按下了哪个按键。</li></ul></li><li>java.awt.event包也提供了通用了事件监听接口和专门监听接口集合来扩展它。专门监听接口如：<ul><li>ActionListener       MouseListener</li><li>ContainerListener    MouseMotionListener</li><li>FocusListener        MouseWheelListener</li><li>InputMethodListener  TextListener</li><li>ItemListener         WindowFocusListener</li><li>KeyListener          WindowListener</li></ul></li><li>这些专门的监听接口围绕着不同的事件类型建立。这些处理相同类型的事件对象（一个监听接口是方法（事件处理程序）的集合）。例如，在鼠标监听接口中的方法处理鼠标事件，“KeyListener”接口的方法处理“KeyEvent”事件，诸如此类。</li><li>在接口中，事件处理程序具有描述性的硬编码名称。例如，“MouseListener”接口提供五个事件处理程序方法：<ul><li>mouseClicked(MouseEvent e)</li><li>mouseEntered(MouseEvent e)</li><li>mouseExited(MouseEvent e)</li><li>mousePressed(MouseEvent e)</li><li>mouseReleased(MouseEvent e)</li></ul></li><li>GUI由多个GUI组件（窗口小部件）组成，例如面板、列表、按钮等。当GUI程序运行起来，窗口小部件是GUI事件（鼠标点击、按键等）的来源。</li><li>就观察者而言，窗口小部件是模式的“主体”。因此，每个窗口小部件必须提供一些让观察者注册的方法。在Java中，这通过每个Java的GUI类（JPanel、Button、JList等）提供注册观察者对象的方法的方式完成。JPanel提供了一个“addMouseListener()”方法来注册鼠标事件的观察者；JButton提供“addActionListener()；诸如此类。</li><li>建立GUI程序，一个Java程序必须做如下任务：<ul><li>创建和定位GUI和窗口小部件的视觉化组件。</li><li>创建一个或多个监听对象（在适合的监听接口中，对象实现了所有的事件处理程序的方法）。</li><li>使用窗口小部件的“add[xxx]Listener()”来注册监听对象和适合的主体窗口小部件。</li></ul></li><li>当GUI事件（例如鼠标点击事件）在主体窗口小部件发生时，在注册监听对象中，窗口小部件调用“mouseClicked()”事件处理程序方法，并将鼠标点击事件传递给它。</li><li>这有个基于Sun公司教程的代码示例“怎样写一个鼠标监听”：</li><li>图【How to Write a Mouse Listener】</li><li>在代码中，“inputArea”对象是事件生成器。“mouseClicked()”方法是事件处理程序。它也是注册处理程序/观察者模式的例子。在观察者模式中“inputArea”是主体，如下这行：</li><li>图【inputArea.addMouseListener(this)】</li><li>在“inputArea”中注册的“this”（DemoGUI）是观察者。</li><li>有趣的是，则个例子展示了Java中是怎么样完成多继承的。在这个例子中，DemoGUI类是GUI窗口小部件也是监听者。它是一个从JPanel继承的JPanel，所以对于inputArea窗口小部件来说它是GUI容器对象。并且他还是监听者（它实现了“MouseListener”接口中的方法（如“MouseClicked”））。</li><li>注意在Java中，事件处理程序方法通过listener接口实现方法的定义，所以名字（如“mouseClick”）是由接口来决定的，所以在起名字的问题上程序员没有选择。Python中的容器，我们可以看到，程序员可以以他们认为合适的任何方式给事件处理方法起名字。</li></ul><h3 id="Callback-programming-回调编程"><a href="#Callback-programming-回调编程" class="headerlink" title="Callback programming (回调编程)"></a>Callback programming (回调编程)</h3><ul><li>当你读GUI框架的文档的时候，你会注意到观察者/事件处理程序叫做“callback”，因为主体窗口小部件会“回调”它们去处理事件。所以你经常看到这种编程类型叫做“回调编程”。</li></ul><h3 id="GUI-programming-summary-GUI编程-概要"><a href="#GUI-programming-summary-GUI编程-概要" class="headerlink" title="GUI programming - summary (GUI编程-概要)"></a>GUI programming - summary (GUI编程-概要)</h3><ul><li>这里我们全身心的投入到GUI应用中事件驱动编程的论题中。或者应该说，我们讨论的是GUI编程的上下文环境中的处理程序模式。</li><li>从根本上来说，GUI编程和其他那些我们见过的处理程序模式的例子没有太多不同。GUI编程和其他处理程序模式的形式不同在于，它大多总是牵扯到“观察者模式”。这就是为什么：GUI城边大多总是包含注册或绑定的过程（事件处理程序（观察者）捆绑到（注册到）事件生成器（主体））。</li><li>注册的过程开起来就是基础的事件处模式上的一个小变化（这只是一个结合事件处理程序和事件生成者的特殊方式）。</li></ul><h2 id="Maintaining-State-维持状态"><a href="#Maintaining-State-维持状态" class="headerlink" title="Maintaining State (维持状态)"></a>Maintaining State (维持状态)</h2><ul><li>许多事件驱动应用程序时无状态的。者意味着当应用程序处理完成了一个事件，应用程序没有被事件改变。</li><li>与无状态应用对立的时有状态应用。有状态的应用程序可以通过事件来改变应用的进程。具体来说，有状态程序可以记住或保持事件之间的信息，它们所记住的信息（它们的状态信息）可以通过事件来改变。</li><li>锤子是个无状态的工具，如果你要钉钉子，锤子就和你钉钉子之前没区别，锤子还是之前那样。订书机时有状态的工具，如果你用它钉一些纸，钉的这个动作就会改变它的状态（在钉这个动作之后，订书机就会比之前少一个订书钉）。</li><li>在大多数基本Web游览的类型中，一个Web服务器收到一个展示的特定页的请求，返回请求页，在结束之后什么都没记住。这就是无状态的应z。大多数有经验的网页会展示访问次数（“自从2000年1月1日，这个页面已经被访问了876532次”）。要做到这个，这个应用的背后网页必须记住被访问的次数，并且在每次网页被访问时增长次数。这个应用就是有状态的。</li></ul><h3 id="Rejection-invalid-transactions-拒绝无效事务"><a href="#Rejection-invalid-transactions-拒绝无效事务" class="headerlink" title="Rejection invalid transactions (拒绝无效事务)"></a>Rejection invalid transactions (拒绝无效事务)</h3><ul><li>在之前的讨论中，我们注意到面向对象编程是一种事件驱动编程。在大多数案例中，面向对象编程包括的对象都是有状态的。比如一个“栈”在它的实例化变量中维持着它的状态，在下图中这个区域标记成“internal data 内部数据”。</li><li>图【Stack object diagram】</li><li>当我们实例化Stack类去创建stack对象时，stack开始为空。</li><li>现在假设下列事件序列发生：<ul><li>一个“push(X)”事件到达。X是添加到栈中，改变栈的状态。</li><li>一个“pop()”事件到达。X从栈中移除（再次改变栈状态）并且返回。栈现在空了。</li><li>另一个“pop()”事件到达。</li></ul></li><li>现在我们遇到了一个问题。栈不能满足此需求。它不能移除并返回栈顶元素，因为栈顶没有元素了；栈是空的。</li><li>这个例子阐述了重要的有状态应用的特性。一般来说，有状态应用定义了（至少隐式的）可接受“状态+事务”类型对的列表。在列表中的每一对，当应用处于指定状态时，应用可以处理指定类型的事务。但是如果到达的事务在当前的状态中不可接受，事务必须被拒绝。</li><li>这有很多相似的这种例子：<ul><li>一般来说，一个成年人如果他想结婚，他就可以结婚，但是如果他已经结婚了，那么就不能再结婚了（X的配偶由文化决定）。</li><li>一般来说，你可以从你的银行账户存取钱，但是你不能从你的账户中取出更多的钱。</li><li>一般来说，你可以兑换你的飞行常客里程以免费飞行，但是航空公司不允许你再繁忙旅行的“断电时段”兑换，比如感恩节前一天。</li><li>一般来说，数据库应用可以再数据中中更新一条记录，但是它不能更新被作者应用锁定的记录。</li></ul></li><li>应用程序由多种方法来相应无效的事务。当然最简单的就是忽略它。但是，一般来说,最好的相应方式是提出一个异常，并让被提交事务的模块处理异常。</li><li>依赖于使用语言的能力，应用提出一个通用异常并伴随一条描述错误的信息，或者可以对指定的问题类型，定义指定的异常。一个栈的实例可以定义为：<ul><li>“StackEmptyException” 栈空异常，当栈是空的并且受到“Pop()”请求时提出此异常。</li><li>“StackOverflowException” 栈溢出异常，当栈满了，并且收到了“Push()”请求时提出此异常。</li></ul></li></ul><h3 id="State-Machines-状态机"><a href="#State-Machines-状态机" class="headerlink" title="State Machines (状态机)"></a>State Machines (状态机)</h3><ul><li>在一些案例中，状态机是有效的思考具有生命周期对象（有状态的计算机应用）的方法。在它的生命周期中，有状态对象通过相应事务（事件）来在不同状态之间切换。</li><li>对象的这种行为叫做“有限状态机 Finite State Machine”（FSM）或者“定向有限状态机 Directed Finite Automaton”（DFA）。描述有限状态机的典型方式是用“状态事务图 State Transition Diagram”（STD）。在STD中，圆圈代表状态，用事务走向的事件名标记的箭头代表了事务。</li><li>这有个STD的例子，它代表了一个人的生活和婚姻历史（由文化规定，同一时间只能由一个配偶）。</li><li>图【STD for life and marriage history of a person】</li><li>在STD中，状态是：“SINGLE 单身”、“MARRIED 已婚”、“DEAD 死亡”。当一个人开始他的生活，它是单身的（开始的状态是SINGLE）。他可能还没有结婚就死亡了，或者他结婚了。他可能在结婚之后死亡，或者通过离婚或丧偶重新回到单身。DEAD是“终点状态”（没有事件事务从这里出去）。</li><li>这个Person类的伪代码如下：</li><li>图【Person class】</li><li>在上述我们讨论的状态中，我们使用“state 状态”和“state information”状态信息指人的所有有状态信息，是对象实例化变量的完整集合。但是当讨论到STD和FSM时，我们在有限状态机中使用“state”这个词去指特定的没有关联的状态。</li><li>遗憾的是，还没有标准术语来区分“state”这个单词的两种意思。Michael Jackson 使用术语“state vector 状态向量”来指第一种情况（“vector”变量列表包含一个对象的状态信息）。程序员经常使用“status”（如“status_flag”,“status_indicator”）来指第二种情况。</li><li>在本文余下部分，一般上下文会指出我用的是哪种“state”。当有可能产生混淆时，我会使用“state vector”（或者“state_information”）和“status”去让事情保持清晰。</li></ul><h3 id="Coding-a-Finite-State-Machine-1-编写一个有限状态机1"><a href="#Coding-a-Finite-State-Machine-1-编写一个有限状态机1" class="headerlink" title="Coding a Finite State Machine 1 (编写一个有限状态机1)"></a>Coding a Finite State Machine 1 (编写一个有限状态机1)</h3><ul><li>有很多不同的技术来编码实现一个有限状态机。在给出的例子中，你选择那种技术取决于你的应用类型和你所用语言的特性。正是因为这些，我会给你介绍你个典型的FSM程序实现的例子。</li><li>这有个有限状态机的状态转换图，它的目的是分解文字的输入流到文字组和空白组。</li><li>图【Break Input Stream STD】</li><li>在接下来的几页有实现此FSM的源码。在看源码之前，我要指出几点关于它的事。</li><li>首先，这是一个解析程序。它会读取文字的输入流，分解它到文字组（tokens 标志令牌），通过类型来标记“tokens 标志令牌”。解析（这是在标记化编译阶段和处理标记语言如HTML和XML完成的）是一个经典的阐述实现有限状态机的程序。</li><li>第二，它使用了经典的设计模式来编码有限状态机。对于许多应用，当处理一个事务时，FSM程序必须要做如下三件事：<ul><li>与离开当前状态相关的活动</li><li>改变当前状态到新状态</li><li>与进入新状态相关的活动</li></ul></li><li>我在活动应该发生的地方写了注释。</li><li>最后，这个程序膳食了我们在处理程序模式中期望看到的特性。输入流时事件队列。从输入流中读取一个字符是从事件队列中取出一个事件。一个时间循环检查每个字符、事件、事务去决定它是否是文字还是空白，然后分发它们到合适的处理程序。当然也会编码一个“EndOfEvents”（输入流最后）事件，在此事件到来时，将结束事件循环。</li><li>如下就是使用Python编写的源码实现。</li><li>图【Implements FSM】</li><li>在这个非常简单的例子中，程序解析如下字符串：</li><li>图【”Suzy Smith Loves    John Jones”】</li><li>生成如下输出：</li><li>图【Implements Output】</li></ul><h3 id="Coding-a-Finite-State-Machine-2-编写一个有限状态机2"><a href="#Coding-a-Finite-State-Machine-2-编写一个有限状态机2" class="headerlink" title="Coding a Finite State Machine 2 (编写一个有限状态机2)"></a>Coding a Finite State Machine 2 (编写一个有限状态机2)</h3><ul><li>作为一个实际问题，一会发现你使用了如下概念：<ul><li>输入一个状态state（status）</li><li>保持状态信息state information（the state vector）</li><li>离开一个状态state（status）</li><li>拒绝当前状态下无效的事务</li></ul></li><li>在你选择去写的多种事件驱动程序里。<ul><li>在GUI程序中，窗口小工具经常需要记住它们的状态。如果一个用户点击了复选框，GUI应用需要知道复选框当前的状态（选中，未选中）为了在两种状态中切换。</li><li>在线应用需要记住所有种类的状态信息。如果一个用户登录一个安全的应用，用错误的密码连续提交三次，用户有可能被锁定。</li><li>在Web应用中，程序经常需要记住它们的状态。如果一个购物车应用用户提交没有登录他账单信息的订单，要将错误反馈给他，并且拒绝提交事件。</li><li>在分析一个编程语言时，是否接受特殊字符（如波浪字符、问号）在原文中出现。它可能在注释或者当出现在引号中没出现在其他地方时可以接受。</li></ul></li><li>在SAX处理XML中，事件驱动应用类型的状态问题非常明显。实际上，SAX分析器提供的了startElement”和“endElement”方法实际上是“startState 开始状态”和“endState 结束状态”。当你遇到某些类型的开始标签（如”&lt;h1&gt;”），你实际上在进入一个状态。在文档中发生在这个状态上下文中所有之后的元素直到你遇到相应的末尾标签（如“&lt;h1&gt;”）。</li><li>这有一个用Python写的SAX程序代码片段，用来检查确保在输入中不包含“&lt;br&gt;”标签或者头标签嵌套在其他头标签里的情况。</li><li>图【CustomizedHandler class】</li><li>对比这个代码结构和解析文字和空格的代码。</li><li>解析程序非常简单，所以一旦我们进入“handlerSpace”或“handLetter”函数中，解析程序知道他要处理事务所需的一切。这对于这个程序还不够。一旦我么进入了“startElement”或“endElement”方法，我们要进一步检查我们处理的标签种类。</li><li>但是一旦我们知道我们处理事件的种类，处理就变得非常简单。从根本上来说，它包含设置和检查“status information 状态信息”（inHeadingStatus）和“state-vector 状态向量信息”（currentHeadingTag），并且基于当前状态允许或拒绝事务。</li></ul><h3 id="Way-to-remember-state-记住状态的方法"><a href="#Way-to-remember-state-记住状态的方法" class="headerlink" title="Way to remember state (记住状态的方法)"></a>Way to remember state (记住状态的方法)</h3><ul><li>许多有状态的应用只需在程序运行时记住它们的状态即可。一些应用没有记住它们状态信息的问题，它们只需要在内存中存储即可。例如，在我们的解析程序中，我们使用了state和outstring global变量。在我们的SAX内容处理程序中，我们使用的“inHeadingStatus”和“currentHeadingTag”内容处理程序对象的实例变量。</li><li>但是其他有状态的应用需要推迟执行，也就是说，它们需要在内存以外存储信息。如这个应用：<ul><li>存储状态信息的责任交到一些可以续存储的媒介中，例如存储在硬盘上的一个文件或数据库。当它启动的时候，它从数据库中恢复它的状态信息，在结束之前再将状态信息存回（持久化）数据库。</li></ul></li><li>或者这样：<ul><li>委托它的调用者负担起存储状态信息的责任。开始时，它从它的调用者收到状态信息，在它结束时再返回状态信息给它的调用者。</li></ul></li><li>Web应用程序是这种有状态应用程序的好例子，因为它们经常使用这两种例子来存储状态信息。考虑“nozama.com”这个网站，一个虚构的经典的用户和Web游览器模式的Web购物应用：<ul><li>打开“nozama.com”Web页</li><li>他通过反复游览“Nozama”产品分类选择产品，一个一个的将产品放到购物车中。</li><li>输入他的账单和购物信息</li><li>提交他的订单</li></ul></li><li>在任何给定时间，可能同时有成百上千的用户使用购物程序。Nozama必须交替从不同购物程序阶段的不同客户的请求中取出并处理。遗憾的是，简单的Web技术为Nozama提供购物者的直接链接。</li><li>Nozama和类似的应用需要一种识别与特定客户端对话的方法。如一个叫做session的对话。Nozama需要管理创建、保持和存储session信息过程的方法。</li><li>这有怎么做的方法。</li><li>当一个用户打开Nozama网站，Nozama创建一个临时的session对象。用户通过购物程序，Nozama添加用户给出的信息（选择的产品、账单、购物信息）到他的session对象的状态信息。最后当用户提交他的订单时session的生命周期结束。</li><li>Nozama通过给每个session一个sessionID，存储session的state vector（他的状态信息）到数据库来跟踪sessions，其中sessionID时state vector的关键。</li><li>一旦启动一个session，在所有网页中Nozama包括session ID将它发送给用户，通过用户以某种方式编码，并且Nozame作为每个页面请求的一部分返回。当Nozama收到一个包含session ID的请求，它使用session ID作为密钥从数据库中去恢复session的vector information。在Nozama处理完用户的请求后，它会在数据库中更新和替换state vector，并且返回一个响应给用户。</li><li>图【Nozama schematic】</li><li>要记住我们说的，有状态应用要记住它的状态信息，可以用存储到可持久化的媒介上，或者用调用它的调用者代理存储。Nozama使用了这两种策略。他在硬盘的数据库中存储了用户的实际状态信息。但是在这个案例中，它同样的也给了它的调用者（客户端游览器）状态信息。客户端游览器负责记录一次的状态信息：session ID。</li><li>还有一种策略是Nozama通过把整个session状态发送到游览器，让游览器记住他。如果Nozama这样做了，它就不用在数据库中存储信息，它就会变得更简单。但是前后端传输的state vector信息包会变大，导致降低相应时间。</li><li>代替策略确实有一个明显的优势，如果用户在完成购物前放弃购物，则在数据库中则没有孤立的session信息。对比数据库的策略，Nozama必须实现一个检测session超时放弃的通知。当一段时间（比如30分钟）之后，session的状态信息将无法访问，Nozama将考虑到将session终止，并且从数据库中删除状态信息。</li></ul><h2 id="Conlusion-结尾"><a href="#Conlusion-结尾" class="headerlink" title="Conlusion (结尾)"></a>Conlusion (结尾)</h2><ul><li>接下来我们总结一下这篇简短的介绍事件驱动编程（处理程序模式和它的变体）和相关的编程问题的文章。</li><li>正如你所看到的，理解事件驱动编程是能够完成许多软件开发任务（面向对象编程、面向对象系统分析和设计、用SAX解析器解析XML、GUI编程、Web编程、甚至是词法分析）的关键。</li><li>祝你的事件驱动编程顺利。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 事件驱动 </tag>
            
            <tag> GUI编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花牌记分器</title>
      <link href="2020/01/28/hua-pai-ji-fen-qi/"/>
      <url>2020/01/28/hua-pai-ji-fen-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="花牌记分器-V0-2-1"><a href="#花牌记分器-V0-2-1" class="headerlink" title="花牌记分器 V0.2.1"></a>花牌记分器 V0.2.1</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><ul><li>花牌记分器用于2-6人的花牌记分</li><li>主要帮助统计玩家分数，核对本轮数据</li><li>以html实现，可在线使用，也可下载离线使用</li><li><a href="https://nas.smalbox.top/HuaPaiScore/HuaPai.html">点击使用花牌记分器</a></li></ul><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ol><li>填写<strong>玩家名字</strong></li><li>根据实际得分情况，填写本轮得分<ul><li>例如：-10，10，+50</li></ul></li><li>点击 <strong>‘结算得分’</strong> 记分器会自动<strong>核算本轮得分是否正确</strong><ul><li>当发现本轮得分错误，在<strong>消息盒子</strong>中会提示</li><li>当本轮得分正确无误，记分器会将得分<strong>核算到累计得分中</strong></li></ul></li></ol>   <br>      - 点击 **‘重置’** 可重置**累计得分**和**本轮得分**]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 花牌 </tag>
            
            <tag> 统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode 问题及解决方案</title>
      <link href="2019/12/12/vscode-wen-ti-ji-jie-jue-fang-an/"/>
      <url>2019/12/12/vscode-wen-ti-ji-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h1 id="VScode-问题及其解决方案"><a href="#VScode-问题及其解决方案" class="headerlink" title="VScode 问题及其解决方案"></a>VScode 问题及其解决方案</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>在使用VScode中遇到的一些问题，在此帖中进行记录，持续更新……</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a><strong>Q&amp;A</strong></h2><h3 id="Q1-VScode在Mac下Vim插件长按hjkl键无法持续移动"><a href="#Q1-VScode在Mac下Vim插件长按hjkl键无法持续移动" class="headerlink" title="Q1: VScode在Mac下Vim插件长按hjkl键无法持续移动"></a>Q1: VScode在Mac下Vim插件长按hjkl键无法持续移动</h3><ul><li><strong>A1:</strong><ul><li>在Mac终端下执行以下命令:</li><li>``` bash<br>$ defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false<pre class="line-numbers language-none"><code class="language-none">- 重启VScode即可- 若要恢复，执行以下命令- &#96;&#96;&#96; bash  $ defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="Q2-配置VScode终端字体"><a href="#Q2-配置VScode终端字体" class="headerlink" title="Q2: 配置VScode终端字体"></a>Q2: 配置VScode终端字体</h3><ul><li><strong>A2:</strong><ol><li><strong>Linux下配置VScode终端字体：</strong><ul><li>在Ubuntu 18.04.1LTS 下的解决方案（亲测可用），其他版本linux做参考。</li><li>``` bash<h1 id="下载安装字体"><a href="#下载安装字体" class="headerlink" title="下载安装字体"></a>下载安装字体</h1>$cd /usr/share/fonts/truetype/<br>$sudo git clone <a href="https://github.com/abertsch/Menlo-for-Powerline.git">https://github.com/abertsch/Menlo-for-Powerline.git</a><h1 id="刷新字体"><a href="#刷新字体" class="headerlink" title="刷新字体"></a>刷新字体</h1>$sudo fc-cache -f -v<pre class="line-numbers language-none"><code class="language-none">- 回到  VScode的用户设置.json  中加入以下代码- &#96;&#96;&#96; bash  &quot;terminal.integrated.fontFamily&quot;: &quot;Menlo for Powerline&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><strong>Mac下配置VScode终端字体：</strong><ul><li>在Mac 10.13.6下的解决方案（亲测可用），其他版本做参考。</li><li>``` bash<h1 id="下载安装字体-1"><a href="#下载安装字体-1" class="headerlink" title="下载安装字体"></a>下载安装字体</h1>$cd /Library/Fonts<br>$sudo git clone <a href="https://github.com/abertsch/Menlo-for-Powerline.git">https://github.com/abertsch/Menlo-for-Powerline.git</a><pre class="line-numbers language-none"><code class="language-none">- 在vscode中设置字体：- &#96;&#96;&#96; bash  &quot;terminal.integrated.fontFamily&quot;: &quot;Menlo for Powerline&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><strong>Windows下配置VScode终端字体：</strong><ul><li>win10 系统下测试有效。</li><li>先<a href="https://github.com/abertsch/Menlo-for-Powerline">下载字体</a>，下载好的字体点击打开安装</li><li>在vscode中设置字体：</li><li><pre><code class="bash">&quot;terminal.integrated.fontFamily&quot;: &quot;Menlo for Powerline&quot;</code></pre></li></ul></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VScode </tag>
            
            <tag> Q&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity导出Android工程</title>
      <link href="2019/11/25/unity-dao-chu-android-gong-cheng/"/>
      <url>2019/11/25/unity-dao-chu-android-gong-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="unity导出apk-amp-导出工程到AndroidStudio二次开发"><a href="#unity导出apk-amp-导出工程到AndroidStudio二次开发" class="headerlink" title="unity导出apk &amp; 导出工程到AndroidStudio二次开发"></a>unity导出apk &amp; 导出工程到AndroidStudio二次开发</h1><p>本文将Uniyt导出Android工程的过程中需要注意的事项进行了阐述，对导出Android工程有其他疑问，可评论或邮箱联系我。</p><h2 id="0-项目准备"><a href="#0-项目准备" class="headerlink" title="0. 项目准备"></a>0. 项目准备</h2><ul><li><p><strong>unity 中配置 Android环境</strong></p><ul><li>Edit -&gt; Preferences</li><li>External Tools -&gt; Adnroid 中选择好SDK JDK（默认安装Openjdk） NDK</li><li><em>（在可以用unity hub的版本里，直接可安装好这三个模块，其中jdk和ndk可以用默认的，sdk可以选择AndroidStudio中安装）</em></li><li><em>(如果想要在 unity 中代理，须在在系统环境变量中添加HTTP_Proxy <a href="http://127.0.0.1:端口号">http://127.0.0.1:端口号</a> 和 HTTPS_Proxy <a href="https://127.0.0.1:端口号">https://127.0.0.1:端口号</a>)</em></li></ul></li><li><p><strong>AndroidStudio中配置环境(在<a href="https://developer.android.google.cn/">Android中文网</a>下载AndroidStudio，建议3.1版本便于下载SDK)</strong></p><ul><li>File -&gt; Settings</li><li><strong>搜索 HTTP Proxy 设置代理</strong><ul><li>Manual proxy configuration 中 设置 127.0.0.1 端口为本地外网开放端口</li><li>点击 check connection 输入 android.com 检测是否代理成功</li></ul> <em>（设置代理成功可以下载sdk，更新包，在同步包时可以避免Gradle工具无法连接服务器，下载缓存而报错）</em></li><li><strong>搜索 Android SDK 安装设置SDK</strong><ul><li>在 SDK Plantforms 中选择要安装的SDK和SDK工具</li><li>在 SDK Update Sites 中选择Force https://… sources to be fetched using http://… 和 disable SDK diff patching</li><li>Apply后开始下载SDK</li></ul></li></ul></li></ul><h2 id="1-选择平台"><a href="#1-选择平台" class="headerlink" title="1. 选择平台"></a>1. 选择平台</h2><ul><li>File -&gt; BuildSettings 选择切换 android 平台</li></ul><h2 id="2-项目设置-玩家设置"><a href="#2-项目设置-玩家设置" class="headerlink" title="2. 项目设置-玩家设置"></a>2. 项目设置-玩家设置</h2><ul><li>Edit -&gt; ProjectSetting -&gt; Player</li><li>填写 Company Name , Product Name</li></ul><h2 id="3-分辨率设置"><a href="#3-分辨率设置" class="headerlink" title="3. 分辨率设置"></a>3. 分辨率设置</h2><ul><li>启动是否全屏，是否渲染外部安全区域等</li><li>画面缩放</li><li>宽高比</li><li>默认方向</li><li>允许自动旋转的方向</li><li>其他设置</li></ul><h2 id="4-启动时的画面logo"><a href="#4-启动时的画面logo" class="headerlink" title="4. 启动时的画面logo"></a>4. 启动时的画面logo</h2><ul><li>可以在 Splash Image 中选择好启动标志和动画（免费个人版受到限制，无法取消unity自带logo）</li></ul><h2 id="5-其他设置"><a href="#5-其他设置" class="headerlink" title="5. 其他设置"></a>5. 其他设置</h2><ul><li><strong>Ohter Settings</strong><ul><li>选择 Auto Graphics API *(如不选择，默认Vulkan、OpenGLES3、OpenGLES2的顺序，某些设备会标识硬件不支持)</li></ul></li><li>填写好 Package Name <strong>注意：包名中不能有数字和特殊符号</strong></li><li>选择好 Minimum API Level 和 Target API Level （automatic（highest installed））</li><li>Scripting Backend 用 mono</li><li>install Location 选择 Automatic <em>(默认是 Prefer External , 会导致某些sd卡有问题的虚拟机或者真机无法安装)</em></li></ul><h2 id="6-发布设置-签名打包"><a href="#6-发布设置-签名打包" class="headerlink" title="6. 发布设置 签名打包"></a>6. 发布设置 签名打包</h2><ul><li><strong>Publishing Settings</strong><ul><li><strong>首次没有签名key，选择创建新的keystore</strong><ul><li>选择 Browse Keystore 在资源管理器中选择存储在哪里</li><li>在 Keystore password 中输入要创建key的密码，然后下面确认密码</li><li>在 Key 中 Alias 选择 Create a new key</li><li>在弹出框中填写好 Alias , Password , Confirm </li><li>点击 Create key</li><li>在 Password 中填写密码</li></ul></li><li><strong>在有签名时，选择 Use Existing Keystore</strong><ul><li>选择 Browse Keystore 找到key</li><li>填写 Keystore password , confirm keystore password </li><li>选择 Alias 中key的名字 以及 对应的密码</li></ul></li></ul></li></ul><h2 id="7-unity-直接生成apk"><a href="#7-unity-直接生成apk" class="headerlink" title="7. unity 直接生成apk"></a>7. unity 直接生成apk</h2><ul><li>Texture Compression ETC(default)</li><li>ETC2 fallback 32-bit</li><li>Build System Gradle <em>(在19之前的版本有这个选项可以选择internal，19的版本没有这个选项，只能使用Gradle)</em></li><li>点击 Build 选择apk要存储的位置，开始生成apk</li></ul><h2 id="8-unity-导出工程-AndroidStudio-二次开发"><a href="#8-unity-导出工程-AndroidStudio-二次开发" class="headerlink" title="8. unity 导出工程 AndroidStudio 二次开发"></a>8. unity 导出工程 AndroidStudio 二次开发</h2><ul><li>选择 Gradle , ExportProject , DevelopmentBuild</li><li>点击 Export ，导出项目</li><li><strong>用AndroidStudio打开项目</strong><ul><li>AS会问，用AS的SDK还是项目的，推荐选择AS中的SDK，方便后续适配开发</li><li>AS会问，Gradle是用的项目的还是下载最新的，推荐点cancel，使用项目的Gradle</li><li>在代理设置好，网络畅通的情况下，项目会由Gradle自动同步生成Android项目</li><li>在AS中创建好目标配置的虚拟机，就可以点击 Run 运行项目到目标硬件机器</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Android </tag>
            
            <tag> Export </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抢救群晖系统简述</title>
      <link href="2019/07/14/qiang-jiu-qun-hui-xi-tong-jian-shu/"/>
      <url>2019/07/14/qiang-jiu-qun-hui-xi-tong-jian-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="抢救群晖系统简述"><a href="#抢救群晖系统简述" class="headerlink" title="抢救群晖系统简述"></a>抢救群晖系统简述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>群晖（Synology）在接电的时候崩出了火花，导致硬盘短路跪了，系统也莫名跪了。好在组的raid1，有一块硬盘是好的，还能抢救。</p><p>抢救的关键是要知道崩了的系统的机型版本，否则引导不起来系统。</p><ul><li><p>抢救思路</p><ol><li>用<strong>虚拟机</strong>安装一个<strong>同型号</strong>、<strong>同版本</strong>的群晖系统</li><li>虚拟机进入<strong>PE</strong>，在PE中对刚安装的群晖系统进行备份</li><li>用PE <strong>U盘</strong> 进入群晖机器，将备份的系统恢复到群晖机器中</li><li>制作新的群晖<strong>引导U盘</strong></li></ol></li><li><p>我的硬件背景</p><ul><li>产品型号：DS3617xs</li><li>系统版本：6.1-15047</li><li>硬盘阵列：raid1</li></ul></li></ul><h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a><strong>软件下载</strong></h2><ul><li><strong>软件清单：</strong> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├── DS367xs-15047-6_1-安装包引导│   ├── DS3617xs-15047-安装包│   │   └── DSM_DS3617xs_15047.pat│   └── ds3617_61-引导│       └── synoboot.img├── PE│   ├── PE镜像│   │   └── Win10PE_Ver.3.6.iso│   └── u盘PE及恢复软件│       ├── ATIH2019.23.3.1.x64.PE.exe│       └── WePE_64_V2.0.exe└── 抢救群晖系统-工具    ├── DiskImage_1_6_WinAll_Setup.exe    ├── SynologyAssistantSetup-6.0-7319群晖助手.exe    ├── chipeasy1.630芯片无忧.exe    └── win32_disk_imager启动盘制作工具.zip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>所需软件都<strong>分别打包</strong>，可<strong>按需下载</strong></li><li><strong>下载地址</strong><ul><li>链接: <a href="https://pan.baidu.com/s/1rrzoI7m4eZVnSyiKmewmRw">https://pan.baidu.com/s/1rrzoI7m4eZVnSyiKmewmRw</a> </li><li>提取码: ka9b</li></ul></li></ul><h2 id="启动前准备"><a href="#启动前准备" class="headerlink" title="启动前准备"></a><strong>启动前准备</strong></h2><ol><li><strong>创建磁盘</strong><ul><li>管理员权限运行cmd或powershell输入：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">diskpart <span class="token comment"># 进入diskpart工具</span>create vdisk <span class="token assign-left variable">file</span><span class="token operator">=</span>c:<span class="token punctuation">\</span>synoboot.vhd <span class="token assign-left variable">maximum</span><span class="token operator">=</span><span class="token number">50</span> <span class="token assign-left variable">type</span><span class="token operator">=</span>expandable <span class="token comment"># file后路径填一个本机可用路径即可</span>attach vdisk <span class="token comment"># 选中创建的路径</span>create partition primary <span class="token comment"># 创建主分区</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><strong>引导写入磁盘</strong><ul><li>用Roadkil’s Disk Image软件将引导写入1创建的磁盘</li></ul></li><li><strong>调整虚拟机bios进入系统</strong><ul><li>打开电源时进入固件，在boot中调整启动项。保存重启进入系统。</li></ul></li></ol><h2 id="系统备份"><a href="#系统备份" class="headerlink" title="系统备份"></a><strong>系统备份</strong></h2><ol><li>加入一个光驱，选择一个PE iso镜像。调整启动项，重启进入PE</li><li>在PE中用Acronis True Image Home for PE备份系统（2.4g的那个分区）</li></ol><h2 id="系统还原"><a href="#系统还原" class="headerlink" title="系统还原"></a><strong>系统还原</strong></h2><ol><li>进入要还原的NAS的PE。用Acronis True Image Home for PE还原系统到对应位置</li></ol><h2 id="制作U盘引导"><a href="#制作U盘引导" class="headerlink" title="制作U盘引导"></a><strong>制作U盘引导</strong></h2><ol><li>用ChipGenius先查看U盘的 vid uid</li><li>格式化U盘，然后用Win32DiskImager将引导刷入U盘</li><li>修改grub.cfg中 vid uid 的值<ul><li>挂载引导盘符<ul><li>以管理员权限运行cmd或powershell输入：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">diskpart <span class="token comment"># 启动diskpart工具</span>list disk <span class="token comment">#  列出系统中拥有的磁盘</span><span class="token keyword">select</span> disk <span class="token number">0</span>  <span class="token comment"># 选择EFI引导分区所在的磁盘，请根据实际情况选择</span>list partition  <span class="token comment"># 列出所选磁盘拥有的分区</span><span class="token keyword">select</span> partition <span class="token number">1</span>  <span class="token comment"># 选择EFI引导分区，类型为系统的分区，就是EFI引导分区</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">id</span><span class="token operator">=</span>ebd0a0a2-b9e5-4433-87c0-68b6b72699c7  <span class="token comment"># 设置磁盘ID</span>assign <span class="token assign-left variable">letter</span><span class="token operator">=</span>p  <span class="token comment"># 为所选分区分配盘符，请分配空闲盘符</span>remove <span class="token assign-left variable">letter</span><span class="token operator">=</span>p  <span class="token comment"># 修改完成后，移除盘符（如果不移除，重启计算机以后，会自动移除）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li>修改grub.cfg<ul><li>以管理员权限运行cmd或powershell输入：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">notepad<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在打开的记事本中，点击打开。在跳出的文件管理器中操作efi中的grub.cfg文件。将其中的 vid uid 值改成u盘的值</li></ul></li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>抢救对机型、系统版本非常严格，如果不对很有可能引导失败</li><li>本文给出了对应机型所需要的工具，如果非本机型，可自行下载更换<strong>引导镜像</strong>、<strong>安装包</strong>，其他步骤不变</li><li>本文是<strong>简述版</strong>，<strong>无图</strong>，<em>（<strong>抢救过程中有问题，可评论或邮件联系我</strong>）</em></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 群晖Synology </tag>
            
            <tag> 抢救系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>群晖无损扩充硬盘空间raid1</title>
      <link href="2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/"/>
      <url>2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/</url>
      
        <content type="html"><![CDATA[<h1 id="群晖无损扩充硬盘空间raid1"><a href="#群晖无损扩充硬盘空间raid1" class="headerlink" title="群晖无损扩充硬盘空间raid1"></a>群晖无损扩充硬盘空间raid1</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>群晖（Synology）原本的500G raid1 硬盘阵列坏了一块硬盘，准备换一块新硬盘，但是500g的硬盘和1t硬盘只有10来元的差价，果断入手1t的。那么问题来了，原来的500G可以无损扩充吗，事实证明是可以的，<strong>（重点是！黑白晖都可直插无损修复扩展）</strong>。</p><p>接下来演示怎样无损扩展。</p><h2 id="步骤概要"><a href="#步骤概要" class="headerlink" title="步骤概要"></a><strong>步骤概要</strong></h2><ol><li>换上1T硬盘，与原来的 500G硬盘 组500G的raid1</li><li>换上另一块1T硬盘，与第一块 500G硬盘 组500G的raid1</li><li>将500G的raid1扩容到1T的raid1</li></ol><h2 id="恢复到硬盘1"><a href="#恢复到硬盘1" class="headerlink" title="恢复到硬盘1"></a><strong>恢复到硬盘1</strong></h2><ol><li>将坏掉的硬盘换成新的1T硬盘，然后网页进入nas界面，点击<strong>存储空间管理员</strong><br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne1.png" alt="restoreToNewHardDiskOne1"></li><li>在系统概况中看到绿色的未使用的硬盘，即说明硬盘安装无误，点击<strong>存储空间</strong><br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne2.png" alt="restoreToNewHardDiskOne2"></li><li>在存储空间中能看到存储状态，点击<strong>按建议在RAID Group设置下单机此处可继续</strong><br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne3.png" alt="restoreToNewHardDiskOne3"></li><li>在RAID Group 中，点击<strong>管理</strong><br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne4.png" alt="restoreToNewHardDiskOne4"></li><li>点击<strong>修复</strong><br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne5.png" alt="restoreToNewHardDiskOne5"></li><li>在选择硬盘界面，将左面的硬盘拖入右面<br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne6.png" alt="restoreToNewHardDiskOne6"><br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne7.png" alt="restoreToNewHardDiskOne7"></li><li>进行硬盘检查，默认是否，建议点击是，检查硬盘<br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne8.png" alt="restoreToNewHardDiskOne8"></li><li>之后会进行数据同步修复<br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne9.png" alt="restoreToNewHardDiskOne9"><br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne10.png" alt="restoreToNewHardDiskOne10"></li><li>如图，一个500G 一个1T 硬盘，存储空间500G， 即成功恢复到第一块硬盘<br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne11.png" alt="restoreToNewHardDiskOne11"></li></ol><h2 id="恢复到硬盘2"><a href="#恢复到硬盘2" class="headerlink" title="恢复到硬盘2"></a><strong>恢复到硬盘2</strong></h2><ol><li>将第二块1T硬盘换入到nas中，恢复步骤同上一步，会进行<strong>数据同步</strong><br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskTwo1.png" alt="restoreToNewHardDiskTwo1"></li><li><strong>一致性校验</strong><br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskTwo2.png" alt="restoreToNewHardDiskTwo2"></li><li>如图即恢复到2块1T硬盘组500G raid1的状态<br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskTwo3.png" alt="restoreToNewHardDiskTwo3"></li></ol><h2 id="扩充容量"><a href="#扩充容量" class="headerlink" title="扩充容量"></a><strong>扩充容量</strong></h2><ol><li>在存储空间中，点击编辑<br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/capacityExpansion1.png" alt="capacityExpansion1"></li><li>将<strong>配置容量</strong>选择<strong>最大化</strong>，点击确定<br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/capacityExpansion2.png" alt="capacityExpansion2"></li><li>显示<strong>扩充文件系统中</strong><br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/capacityExpansion3.png" alt="capacityExpansion3"></li><li>如图，扩充完成<br> <img src="/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/capacityExpansion4.png" alt="capacityExpansion4"></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>群晖的raid1还是很方便好用的，只要换上硬盘相互备份即可。*(黑白晖都可直插无损修复扩展)*</li><li>群晖的系统我是装到硬盘里了。能让我这样直接抽盘换盘恢复备份，即说明，群晖的2.4G的系统分区也是在每个盘都有备份的。不管是哪个盘挂了，都能随意抽换恢复，体验很好。</li><li><em>（<strong>在恢复过程中有不清楚的，可以评论或发邮件联系我</strong>）</em></li></ul>]]></content>
      
      
      <categories>
          
          <category> DIY </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 群晖Synology </tag>
            
            <tag> raid1 </tag>
            
            <tag> 无损扩容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DIY笔记本收纳支架</title>
      <link href="2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/"/>
      <url>2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="DIY笔记本收纳支架"><a href="#DIY笔记本收纳支架" class="headerlink" title="DIY笔记本收纳支架"></a>DIY笔记本收纳支架</h1><p><img src="/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/notebookStand.jpg" alt="notebookStand.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近想用超级本(厚度1.8cm，13.3寸)的雷电接口，做到插一根线即可做移动主机的想法。然后发现，需要一个笔记本支架让本子优雅的立在桌面上。</p><p>然而，淘宝一下发现主流的两种，一种铝制的占大多数，一种木质的。价格都在百元左右。嗯～，考虑到重量、便携程度、和 <em>钱包厚度</em> ，决定自己搞一个吧。</p><p>所以需求就是：</p><ol><li>重量要轻</li><li>足够便携</li><li>成本要低</li><li>尽量美观</li></ol><p>头图已经上成品了，下面就介绍一下具体制作过程。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h2><ul><li>亚克力板2mm厚一块（板面大小：14cm * 12cm 以上）</li><li>螺丝&amp;螺母<ul><li>直径3mm，长度12mm 螺丝6颗</li><li>直径3mm，长度40mm 螺丝2颗</li><li>3mm螺母12颗</li></ul></li><li>电烙铁（头换成刀片，用割刀也可以，主要用来切割板材）</li><li>电钻 直径3mm和4mm的钻头</li><li>热熔胶</li><li>直径4mm的热缩管</li></ul><h2 id="开始制作"><a href="#开始制作" class="headerlink" title="开始制作"></a><strong>开始制作</strong></h2><ol><li><p><strong>在亚克力板上划线 准备切割</strong></p><ul><li>尺寸是：14cm * 1cm 一条，一共12条。<br><img src="/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/drawAcrylicBoard.jpg" alt="drawAcrylicBoard.jpg"></li></ul></li><li><p><strong>切割好板材，准备拼装打孔</strong></p><ul><li>如图将亚克力板切割好，准备合起来组装打孔。<br><img src="/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/cuttingAcrylicBoard.jpg" alt="cuttingAcrylicBoard"></li></ul></li><li><p><strong>组装、切割底脚、打孔</strong></p><ul><li>每三片组成一个支架腿</li><li>其中两个腿，中间那片向里缩进1cm</li><li>另两个腿，中间那片向外突出1cm</li><li>对齐后，分别在底脚处、其上2cm处、接头处钻孔，具体如图</li><li>将底角螺丝拧上</li><li>把地脚45度切出一个斜切面，并用热熔胶涂平（做稳定处理）<br><img src="/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/combinationOfDrilling.jpg" alt="combinationOfDrilling"></li></ul></li><li><p><strong>开始组装</strong></p><ul><li>拧上接头<br><img src="/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/assemble1.jpg" alt="assemble1"><br><img src="/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/assemble2.jpg" alt="assemble2"></li><li>剪好热缩管，做防滑垫<br><img src="/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/assemble3.jpg" alt="assemble3"><br><img src="/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/assemble4.jpg" alt="assemble4"></li></ul></li><li><p><strong>两种形态</strong></p><ul><li>两种模式只需要将接头螺丝拧下，将支架腿以45度插入或180度插入即可切换两种模式</li><li><strong>支架模式</strong><br> <img src="/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/supportForm1.jpg" alt="supportForm1"><br> <img src="/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/supportForm2.jpg" alt="supportForm2"></li><li><strong>收纳模式</strong><br> <img src="/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/storageForm.jpg" alt="storageForm"></li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>在能满足放置超级本的需求下，做到了极致轻便，价格足够便宜。</li><li>外观和手感需要后期打磨，可以用1500、5000、10000目的砂纸打磨，手感会很好。</li><li><em>（<strong>初版原创设计，如果有兴趣改进，可以邮箱联系我</strong>）</em></li></ul>]]></content>
      
      
      <categories>
          
          <category> DIY </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 支架 </tag>
            
            <tag> 笔记本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mi5魔改8000mAh大电池</title>
      <link href="2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/"/>
      <url>2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="mi5魔改8000mAh大电池"><a href="#mi5魔改8000mAh大电池" class="headerlink" title="mi5魔改8000mAh大电池"></a>mi5魔改8000mAh大电池</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>mi5原装的3000mAh电池实在是撑不住现在这些软件耗电大户，无奈原装电池救不了他，那就找点魔改的电池来终结一天N充的血崩续航。</p><h2 id="系统选择"><a href="#系统选择" class="headerlink" title="系统选择"></a><strong>系统选择</strong></h2><ul><li>mi5 的续航在miui10上崩的是体无完肤。虽然18年下半年的最后几个开发版加入了2D人脸解锁功能，但是也不足以让这个发热功耗差的系统再留在这了。</li><li>在论坛里借鉴了各路推荐，最后经过对比，miui8的最后一个android6的版本是发热续航流畅控制的最好的版本。</li><li><strong>MIUI版本号：8.1.6.0 稳定版</strong></li><li><strong>Android版本号：6.0.1</strong></li></ul><h2 id="开始魔改"><a href="#开始魔改" class="headerlink" title="开始魔改"></a><strong>开始魔改</strong></h2><ol><li><strong>先来看看工具</strong>，淘宝买的电池附送的工具。<br><img src="/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/tool.jpg" alt="tool"><ul><li>能用上的工具：<ul><li>铲子铲电池</li><li>螺丝刀</li><li>卡针</li><li>吸盘</li><li>上下后盖</li></ul></li></ul></li><li><strong>电池</strong>，因为电池很厚，盖不上原厂后盖，就需要一个保护套当后盖，最后成品有后盖的图。<br><img src="/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/battery.jpg" alt="battery"><ul><li>这里是8000mAh的电池，他家的电池发货比较慢，客服回复也慢，但是东西不错。</li></ul></li><li><strong>吸盘吸开原装玻璃后盖</strong><br><img src="/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5Back.jpg" alt="mi5Back"></li><li><strong>用螺丝刀把上主板的扣板卸下</strong><br><img src="/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackInner1.jpg" alt="mi5BackInner1"></li><li><strong>断开电池接口，撕下电池易拉胶，用撬板取下电池</strong><br><img src="/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackInner2.jpg" alt="mi5BackInner2"><br><em>(注：这里的锡箔纸是我之前给手机改散热时弄上去的。锡箔纸下涂了硅脂，将主板热量导出去。)</em></li><li><strong>撕下电池下面的两个易拉胶贴，按入电池槽，接上电池接口</strong><br><img src="/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackNewBattery.jpg" alt="mi5BackNewBattery"></li><li><strong>扣上主办盖子</strong><br><img src="/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackNewBattery2.jpg" alt="mi5BackNewBattery2"></li><li><strong>盖上工具中的上下后盖</strong><br><img src="/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackNewCover.jpg" alt="mi5BackNewCover"></li><li><strong>用热熔胶将电池附近露出的缝隙部分填满</strong><br><img src="/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackNewCoverGlue.jpg" alt="mi5BackNewCoverGlue"></li><li><strong>扣上保护后盖</strong><br><img src="/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackCover.jpg" alt="mi5BackCover"></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><ul><li><strong>重量</strong><ul><li>原机裸机：129g</li><li>钢化膜+魔改后整体：228g</li><li>重量大概就是iphone XS MAX 加上保护套的重量差不多</li></ul></li><li><strong>厚度</strong><ul><li>原机厚度：7.25mm</li><li>魔改后厚度：10.5mm</li><li>因为保护壳有收边弧度，所以拿起来厚度还可以接受</li></ul></li><li><strong>续航</strong><ul><li>使用AccuBattery测试电池容量在7100mAh+</li><li>实测日常轻度使用2天12小时剩余20%</li><li>实测中度使用可两天充一次电</li><li>实测一直玩游戏“街头篮球”50分钟消耗10%，估算满电能玩8小时18分钟左右游戏</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li><strong>优点</strong><ul><li>超强续航，安全感爆棚。真正解决一天N充。</li></ul></li><li><strong>缺点</strong><ul><li>重量、厚度都有所增加，不过在能接受的范围内。</li><li>安全性有所降低，后盖只用保护壳保护，在防摔防水上会有一定的妥协。我是用了热熔胶封住缝隙，粘住手机边框和后壳来增加了稳定性。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> DIY </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手机 </tag>
            
            <tag> 电池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记本超频内存条的&#39;小秘密&#39;</title>
      <link href="2019/05/10/bi-ji-ben-chao-pin-nei-cun-tiao-de-xiao-mi-mi/"/>
      <url>2019/05/10/bi-ji-ben-chao-pin-nei-cun-tiao-de-xiao-mi-mi/</url>
      
        <content type="html"><![CDATA[<h1 id="笔记本超频内存条的’小秘密’"><a href="#笔记本超频内存条的’小秘密’" class="headerlink" title="笔记本超频内存条的’小秘密’"></a>笔记本超频内存条的’小秘密’</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近内存便宜，给 thinkpad S1 2017 升级16g内存。选择内存的过程中发现一些商家没有明说的’小秘密’，特此来分享一下。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><ul><li>机器原装的是 DDR4 8g 2666频率 的内存条。</li><li>要选择一个 DDR4 16g 2666频率 的内存条。</li></ul><h2 id="“小秘密”"><a href="#“小秘密”" class="headerlink" title="“小秘密”"></a><strong>“小秘密”</strong></h2><ul><li>先上京东自营看了一圈，发现价格在480-800之间。</li><li>价格从低到高的牌子是：协德、威刚、十铨、金士顿、联想、三星、海力士、芝奇。</li><li>抛除牌子的原因，这几百块的差距是哪来的，就涉及到了商家宣传的手段了。<ul><li><strong>重点来了！！！</strong></li><li><em>都是同为2666的条子，便宜的条子在宣传上都是打着“游戏”、“发烧”为字眼的“超频条”。什么一键超频听起来高大上，实际上是需要主板支持 <strong>XMP（Intel Extreme Memory Profiles）</strong> 功能，在主板中打开这个功能内存可以自动超频。</em></li><li><em>那么问题来了，<strong>什么样的笔记本主板支持这个XMP呢？</strong>。一般来讲，<strong>游戏笔记本</strong>可能会支持这个功能，其他的一般笔记本超级本之类的主板都不会给开放这个功能的。</em></li><li>所以想买插上直接超频到2666的条子，那就考虑一下贵一点，比如三星、联想原厂之类的。这些条子使用了 <strong>PNP（Plug-and-Play）</strong> 技术，可以即插即用，直接超频。当然缺点是这类条子一般都比 <strong>使用XMP技术的条子贵20%左右</strong>。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li>无脑买条，直接上使用PNP技术的，无各种超频噱头的2666条子，小贵点。</li><li>游戏本可以根据主板bios是否支持XMP技术，来选择XMP条子，确实省钱。</li><li>不支持XMP技术主板的笔记本，根据需求选择。<ul><li>如果要超频，只能选择PNP的条子。</li><li>如果比在乎超频，还想低价，选择XMP条子，频率使用默认的2133也未尝不可。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> DIY </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记本 </tag>
            
            <tag> 内存条 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记本(K680e)改侧键开机</title>
      <link href="2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/"/>
      <url>2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="笔记本-K680e-改侧键开机"><a href="#笔记本-K680e-改侧键开机" class="headerlink" title="笔记本(K680e)改侧键开机"></a>笔记本(K680e)改侧键开机</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>想把神船本当主机用，无奈开机键在本子C面，必须要打开盖子才能开机，实在是太麻烦。于是准备将开机键改装到本子的侧面，这样就能实现在合着盖子的情况下，按侧面的按钮开机，让神船本成为移动主机。</p><ul><li><strong>改装思路</strong><ol><li>本子的开机键附近有一个<strong>安全锁孔</strong>，可以利用他的空间做开机按钮</li><li>用万用表找到开机键要<strong>短接</strong>的两个触点</li><li>将触点<strong>用导线引出</strong>，加装一个开关做外接开关</li><li>做一个<strong>开关按键</strong></li><li>用<strong>热熔胶</strong>固定开关</li><li><strong>理线</strong>还原机器</li></ol></li></ul><h2 id="成品"><a href="#成品" class="headerlink" title="成品"></a><strong>成品</strong></h2><ul><li>先看一下成品吧<br> <img src="/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/finishedProduct.jpg" alt="finishedProduct"></li><li>图中<strong>白色按钮</strong>就是新的<strong>侧开关键</strong>，使用方法和本机开关一样，点击开机，长按断电关机。</li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><ol><li><p>根据改装思路找到<strong>安全锁孔</strong>，如图：<br><img src="/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHole.jpg" alt="safeHole"><br><img src="/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHoleInner.jpg" alt="safeHoleInner"></p></li><li><p>拆机，找到<strong>开机键</strong>的小开关</p><ul><li>开关有<strong>四个</strong>触角接到PCB板上，<em>（这里用<strong>万用表的电阻挡测量</strong>其中两个触角，找到接上触点没有偏转，但是按下开关有偏转的两个触点，我的是<strong>对角线</strong>的两个触点，可以先试试）</em></li><li>根据找到的<strong>触点</strong>，用导线将两个触点接出来。<em>（因为触点太小，所以焊锡很难接的牢固，下图看到我接的很丑，就是因为很难接牢，重复了好多次。最后还是用了101胶点了两下确定牢固）</em></li><li><strong>下图是接好的样子：</strong><br><img src="/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/weldButton.jpg" alt="weldButton"></li></ul></li><li><p>找一个<strong>开关</strong></p><ul><li>手头上有一个坏掉的鼠标，就想着把鼠标的<strong>按键开关</strong>做开机开关</li><li><strong>如图这个绿色鼠标开关：</strong><br> <img src="/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/mouse.jpg" alt="mouse"></li><li>由于这个开关有三个脚，所以用万用表的点阻挡测试开关那两个脚是需要的。原理同测试本子开关一样，<strong>连接上表不转，按住开关，表转，说明这俩个脚就是要用的引脚</strong></li><li><strong>如图将两个引脚连接上：</strong><br> <img src="/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/mouseButton.jpg" alt="mouseButton"></li></ul></li><li><p>做一个<strong>按钮</strong></p><ul><li>由于我手里有3D打印其他东西的废料，所以就就地取材，直接用电烙铁将它切成要用的形状。</li><li>当然如果有别的成块的塑料之类的东西也可以尝试。</li><li>具体方法是将<strong>电烙铁的头</strong>卸下，换上<strong>美工刀</strong>的一段<strong>刀片</strong>，给电烙铁通电加热，将塑料切所要的形状，最后给按钮烫出一个<strong>小底托</strong>即可。</li><li><em>（<strong>可以用任何别的东西代替，我也可以提供3D打印的按钮，这里我图快，就凑合了一个，没有打印</strong>）</em></li><li><em>（<strong>注意！！！长度控制在放到孔中基本上和机器外边缘平齐，防止误触！！！</strong>）</em></li><li><strong>按钮如图：</strong><br> <img src="/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/button.jpg" alt="button"></li></ul></li><li><p>将按钮装进<strong>安全孔</strong></p><ul><li><strong>如图将按钮装进安全孔的样子：</strong><ul><li>外部<br> <img src="/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHoleButton.jpg" alt="safeHoleButton"><br> <img src="/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHoleButton2.jpg" alt="safeHoleButton2"></li><li>内部<br> <img src="/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHoleButtonInner.jpg" alt="safeHoleButtonInner"></li></ul></li></ul></li><li><p>将<strong>开关</strong>装进<strong>安全孔</strong></p><ul><li>先将鼠标上拆下来的开关放进去看看大小位置，<em>（<strong>注意！！！按钮不要长出机器边缘，否则容易误触</strong>）</em></li><li><strong>如图：</strong><br> <img src="/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/clickButton.jpg" alt="clickButton"></li><li>用热熔枪将开关固定到合适的位置，<em>（<strong>注意不要将活动的外面按钮粘住</strong>）</em></li><li><strong>如图：</strong><br> <img src="/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/holdClickButton.jpg" alt="holdClickButton"></li></ul></li><li><p><strong>理线</strong></p><ul><li>这个就根据机型内部具体情况进行理线了，大多数机器内部都还是有一定空隙，可以将线藏进去。</li></ul></li><li><p><strong>扣盖子还原</strong></p><ul><li>这部分因机型而异了。</li><li>我在还原的时候发现我占用了一个侧边的螺丝孔，所以边缘的一个螺丝上不了了，但是只要理线合理，缝隙还是可以接受的。</li><li>因为占用的是安全锁孔，所以盖子上肯定有一个塑料挡着，这时就需要将其多余的地方用镊子掐掉，掐掉的是非受力点，所以对本子是没有他打损伤的。外观是完全看不到的。</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li><p><strong>优点</strong></p><ol><li>可以<strong>合盖开机</strong></li><li><strong>手感清脆</strong>，取决于找到的开关</li></ol></li><li><p><strong>缺点</strong></p><ol><li>占用了一个<strong>安全锁</strong>位置</li><li>占用了一个边角<strong>螺丝位</strong></li><li>原开机按钮失灵了（可能是点胶的时候粘住了），好在原来的按钮也不好用，失灵了也还好，毕竟<strong>侧键更好用</strong>。</li></ol></li><li><p>借鉴神船本的改装经验，可以给<strong>其他本子</strong>改装侧边开机键。一般笔记本中的空隙还是可以容纳得下引出来的线的。</p></li><li><p>如果可以淘到<strong>更小的开关</strong>，就可以不破环或者较少对本子的破坏完成改造。</p></li><li><p>按钮可以用其他东西替代，如果能买到类似安全锁孔的按钮那就是最完美的了。实在没有，用3d打印机打印也是可以的，我这回着急弄，就没有打印，直接切的料。<em>（<strong>如果有需要可以邮箱联系我定制3D打印开关</strong>）</em></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> DIY </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记本 </tag>
            
            <tag> diy </tag>
            
            <tag> 改侧开机键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HelloHexo</title>
      <link href="2019/01/01/hello-world/"/>
      <url>2019/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hello </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初始化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>screen代替nohup运行后台进程</title>
      <link href="2018/11/08/screen-dai-ti-nohup-yun-xing-hou-tai-jin-cheng/"/>
      <url>2018/11/08/screen-dai-ti-nohup-yun-xing-hou-tai-jin-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="screen代替nohup运行后台进程"><a href="#screen代替nohup运行后台进程" class="headerlink" title="screen代替nohup运行后台进程"></a>screen代替nohup运行后台进程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>在linux中常用nohup和&amp;配合将程序放在后台运行，但是当远程用ssh登陆时会遇到退出远程后进程就被杀掉了。</p><p>这里用screen来守护进程不会被杀掉。</p><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a><strong>具体流程</strong></h2><ol><li>创建一个screen会话<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$screen</span> -S screenName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>启动脚本，服务之类的任何想要后台运行的东西</li><li>退出screen会话<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$screen</span> -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>如果想恢复会话（重新连接）<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$screen</span> -r screenName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>查看是否有screen会话及其状态<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$screen</span> -ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p><em>（此方法适用于bash，zsh等终端。可使用 man screen 查看详细信息）</em></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nohup </tag>
            
            <tag> screen </tag>
            
            <tag> 后台运行程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频编码与封装</title>
      <link href="2018/10/28/shi-pin-bian-ma-yu-feng-zhuang/"/>
      <url>2018/10/28/shi-pin-bian-ma-yu-feng-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="视频编码与封装"><a href="#视频编码与封装" class="headerlink" title="视频编码与封装"></a>视频编码与封装</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  通常所说的<strong>视频格式</strong>，其实是视频文件的<strong>封装格式</strong>，而为什么在 final cut pro 中就能流畅的剪辑影片，同样的或者硬件配置更强大的pc机上往往就没有那么流畅的预览影片呢。</p><p>  这除了apple在系统层面做了优化，还有最为重要的就是<strong>视频的编码格式</strong>。</p><p>  来了解视频文件的构成从而让视频剪辑更为流畅。</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul><li>视频文件的构成</li><li>不可忽视的音频</li><li>视频编码方式</li><li>视频编码格式</li><li>视频封装格式</li><li>视频播放的码率</li><li>高效的剪辑工作流（最终目标）</li></ul><h2 id="视频文件的构成"><a href="#视频文件的构成" class="headerlink" title="视频文件的构成"></a><strong>视频文件的构成</strong></h2><p>要了解视频的编码前，需要先了解一下视频文件中到底包含了什么。</p><ol><li>视频中的<strong>图像</strong></li><li>对应的<strong>音频</strong></li><li>一些媒体信息<ul><li><strong>帧率</strong>（例如：H.264）</li><li><strong>码率</strong>（例如：25fps） </li><li><strong>字幕文件</strong></li><li><strong>拍摄机器等信息</strong></li></ul></li><li><strong>封装格式</strong>（例如；mov、mp4、mkv、ogg）</li></ol><h2 id="不可忽视的音频"><a href="#不可忽视的音频" class="headerlink" title="不可忽视的音频"></a><strong>不可忽视的音频</strong></h2><p>视频中的音频相对图像来说简单一些，但是他的作用是不可忽视的，好的音质能让视频观感大幅提升（例如：国内的恐怖片如果没了音频基本上就是个闹剧了）。好的音频节奏和图像的配合才是好的视频。</p><p>音频主要上还是两种</p><ol><li><strong>有损音频</strong><ul><li>常用格式有 mp3、acc</li></ul></li><li><strong>无损音频</strong><ul><li>常用格式欧 wav、aiff</li></ul></li></ol><p><em>在网络上常规的音频设置为：48khz/192kbps</em></p><h2 id="视频编码的方式"><a href="#视频编码的方式" class="headerlink" title="视频编码的方式"></a><strong>视频编码的方式</strong></h2><p><strong>这部分就是重点了！！！</strong></p><p>前言部分讲述的让视频剪辑更为流畅的核心就在于此了。</p><p>一个视频文件是通过不同的图像编码方式将其图像编码，再加上他的音频，字幕文件，拍摄机器等其他信息组建完成，最后通过不同的封装格式呈现给大家。</p><p>大家看到的不同的视频文件比如mp4，mov都是封装格式，而决定能否流畅的是其中的编码格式。</p><p>编码方式分两种：</p><ol><li><strong>帧内编码（运算少，文件大）</strong></li><li><strong>帧间编码（运算多，文件小）</strong></li></ol><ul><li><p><strong>帧内编码</strong></p><ul><li>帧内编码是将<strong>每一帧的画面进行压缩</strong>，然后组成的视频。所以采用帧内编码格式的视频在剪辑的预览中，肯定是更加流畅。带来的副作用是由于每一帧都在所以视频文件就会比较大，这也就是为什么在视频编辑的时候为什么要大内存大原因了。</li><li>了解了帧内编码的特性，不难看出，帧内编码更适合在<strong>剪辑的时候使用</strong>，能加快剪辑时预览的速度（也就是所谓的不卡）。</li></ul></li><li><p><strong>帧间编码</strong></p><ul><li><p>帧间编码是保留一部分帧，<strong>空缺下来的帧通过在播放时解码器的运算来生成</strong>。这样做的后果就是预览时会增大处理的负荷，在剪辑中最直接的表现就是需要耐心的等待渲染才能预览。好处就是指存储了一部分的帧，能有效的减小视频文件的大小。</p></li><li><p>帧间编码格式的最大优点就是<strong>文件小</strong>，所以最适合在视频编辑完成后的生成导出。</p></li></ul></li></ul><h2 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a><strong>编码格式</strong></h2><p>了解了编码方式就能够看出，想要高效的<strong>剪辑</strong>就需要<strong>帧内编码</strong>，想要<strong>视频传播</strong>则需要<strong>帧间编码</strong>。</p><p>常用的编码格式：</p><table><thead><tr><th align="center">编码格式</th><th align="center">编码方式</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">h.264(mpeg4)</td><td align="center">帧间编码</td><td align="center">网络传播最佳</td></tr><tr><td align="center">mpeg2(dvd)</td><td align="center">帧间编码</td><td align="center">过时</td></tr><tr><td align="center">h.265(hevc)</td><td align="center">帧间编码</td><td align="center">未普及</td></tr><tr><td align="center">proes(apple)</td><td align="center">帧内编码</td><td align="center">高效&amp;优良</td></tr><tr><td align="center">dhxhd/hr(avid)</td><td align="center">帧内编码</td><td align="center">win支持最佳</td></tr><tr><td align="center">cineform(gropro)</td><td align="center">帧内编码</td><td align="center">最佳</td></tr></tbody></table><h2 id="封装格式"><a href="#封装格式" class="headerlink" title="封装格式"></a><strong>封装格式</strong></h2><p>封装格式是最常说的，他就在文件的<strong>尾缀</strong>上。</p><p>常用的封装格式有：</p><p>|封装格式|对编码的支持|<br>|:-:|:-:|:-:|<br>|Mov（apple）| 优良 |<br>|mp4（动态图像专家组）|  最佳 |<br>|mkv/ogg（开源）| 软件支持不足 |<br>|wmv（Microsoft）| 兼容性低下 |<br>|AVCHD（松下/索尼）| 结构复杂（通过文件的方式组织）|<br>|avi | 旧，不支持新编码 |</p><h2 id="播放码率"><a href="#播放码率" class="headerlink" title="播放码率"></a><strong>播放码率</strong></h2><p>码率通常以秒为时间单位，一秒内包含的数据就是码率能够提供的信息。</p><p>理论上分辨率越高的视频就会越清晰。但是当视频分辨率越高，但是码率比较低的时候，低分辨率的视频则会显示的更加清晰。因为低码率带来的信息量比较低，高分辨率的视频的每一帧相较于低分辨率的视频会更加模糊，所以会显得低分辨率的画质会更好一些。</p><p>当然了，这种现象会随着码率的提高，低分辨率低视频在达到它清晰的极限时，高分辨率的视频画质就会超越低分辨率低视频。</p><p>视频码率通常的单位为 <strong>mbps</strong>（Million bits per second），<strong>MBs</strong>。</p><p>音频码率通常为<strong>kbps</strong>。</p><p>换算单位是：</p><ul><li>8bits = 1byte</li><li>1mbps = 0.125bit/s</li></ul><h2 id="高效的剪辑工作流（最终目标）"><a href="#高效的剪辑工作流（最终目标）" class="headerlink" title="高效的剪辑工作流（最终目标）"></a><strong>高效的剪辑工作流（最终目标）</strong></h2><p>经过以上的对比分析，最佳的<strong>视频剪辑方式</strong>是用<strong>mov</strong>格式的视频素材进行<strong>剪辑调色</strong>等工作，而最后<strong>成片</strong>导出为<strong>mp4</strong>格式放到网络上。</p><table><thead><tr><th align="center"></th><th align="center">剪辑/调色</th><th align="center">网络传输</th></tr></thead><tbody><tr><td align="center">编码方式</td><td align="center">帧内编码</td><td align="center">帧间编码</td></tr><tr><td align="center">编码格式</td><td align="center">prores/cineform</td><td align="center">H.264</td></tr><tr><td align="center">封装格式</td><td align="center">mov</td><td align="center">mp4</td></tr></tbody></table><p>知道了视频的编码与封装就不用纠结是mac还是win的问题了，只要<strong>选对了编码</strong>那编辑起来都是行云流水的。<em>（另外adobe的encoder真的很厉害）</em></p><p><em>有任何关于本文内容的问题，可以在下方评论，或者邮件联系联系我。</em></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频编码 </tag>
            
            <tag> 视频封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Gitment及常见问题解决</title>
      <link href="2018/10/24/an-zhuang-gitment-ji-chang-jian-wen-ti-jie-jue/"/>
      <url>2018/10/24/an-zhuang-gitment-ji-chang-jian-wen-ti-jie-jue/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Gitment评论模块-amp-常见问题解决"><a href="#安装Gitment评论模块-amp-常见问题解决" class="headerlink" title="安装Gitment评论模块 &amp; 常见问题解决"></a>安装Gitment评论模块 &amp; 常见问题解决</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>本文记录了本博客添加gitment评论模块的过程，并对配置过程中碰到的问题与其解决方案作出阐述。<br>因每个hexo选择的主题不一样，所以主题的文件结构会有所不同，具体操作也会有所不同，所以本文也尽可能的写出配置思路，来帮助不同主题的hexo博主配置自己主题的gitment评论模块。</p><p>对gitment的介绍就不多说了，就是利用GitHub的issue来做评论，能同步issue里的留言。具体详细可以去看项目介绍：<a href="https://github.com/imsun/gitment">Gitment项目地址</a>.</p><blockquote><p>大致描述一下gitment的配置：</p></blockquote><ul><li><p>首先是两个配置文件，一个css文件一个js文件。gitment的开发者用远程连接的方式将两个文件引入hexo中。但是实际操作中会遇到问题（最后常见问题中会写解决方案），其中的js文件中需要访问作者自己搭建的服务器，但是现在作者的服务器不好使了，会导致全都配置好了，但是报错。所以要下载到本地的自己项目中，然后在项目中自己引用这两个文件（具体操作本文安装部分会写到）。</p></li><li><p>其次就是由于主题不同，有的主题的作者在开始设计主题的时候就为用户写好了gitment的配置代码，只需用户在主题的_config.yml中开启并填写好配置参数即可。有的主题没有预制好gitment的配置代码，就需要用户自己去在样式模板中添加gitment代码。</p></li></ul><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a><strong>概览</strong></h2><ol><li>安装gitment到主题</li><li>注册OAuth application</li><li>配置gitment到hexo主题中</li><li>初始化评论</li><li>常见问题解决</li></ol><h3 id="1-安装gitment到主题"><a href="#1-安装gitment到主题" class="headerlink" title="1.安装gitment到主题"></a><strong>1.安装gitment到主题</strong></h3><p>由于有的hexo主题预置gitment模块，有的没有，所以分两种情况来说。</p><ol><li><strong>主题已经集成了gitment模块 看这里～</strong></li></ol><ul><li>需要博主自己查看一下自己的主题结构，找到 <strong>themes</strong> 下的 <strong>_config.yml</strong> 文件，在文件中找到gitment模块的相关参数，然后在 <strong>enable</strong> 选项后面写上 <strong>true</strong> 即可完成安装过程。</li></ul><p>  如图所示： <img src="/2018/10/24/an-zhuang-gitment-ji-chang-jian-wen-ti-jie-jue/gitmentConfig.png" alt="gitmentConfig"></p><ol start="2"><li><strong>主题没有集成gitment模块 根本配置在这里～</strong></li></ol><ul><li>如果在自己的 <strong>themes</strong> 的 <strong>_config.yml</strong> 中没有看到 <strong>gitment</strong>相关选项，就要自己配置。</li><li>这时就要用到gitment作者的安装方法了。前言中说到的两个文件一个css一个js，只要将这两个文件引入自己主题的母板中就完成了安装。由于作者的提供是js文件中需要改动，所以这里要将提供是文件下载下来到自己的博客中，根据自己的文件结构防治css和js文件。然后在模板文件中引用两个文件。</li><li><a href="https://imsun.github.io/gitment/style/default.css">css文件下载地址</a></li><li><a href="https://imsun.github.io/gitment/dist/gitment.browser.js">js文件下载地址</a></li></ul>  <pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--(将以下添加到模板文件中（这个引用路径是一个例子，根据自己的目录引用)--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/libs/gitment/default.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/libs/gitment/gitment.browser.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><em>（注：本质上安装就是在主题模板文件中引入一个css和一个js文件。集成gitment模块的主题只不过是做到了代码分离，让需要配置的参数在_config.yml中统一配置。gitment作者给出的方法是在给没有集成的主题中的根本引入办法。如果你能看懂主题作者的组织结构，那完全可以给自己的主题集成gitment模块。因主题结构不一样我就不详细举例了。）</em></p><h3 id="2-注册OAuth-application"><a href="#2-注册OAuth-application" class="headerlink" title="2.注册OAuth application"></a><strong>2.注册OAuth application</strong></h3><p>因为gitment是利用了github的issue，所以要注册OAuth application，来获取配置参数为接下来的配置做准备。</p><p><a href="https://github.com/settings/applications/new">点击此处</a>来注册，一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 <a href="https://smalbox.top)./">https://smalbox.top）。</a></p><p>注册后会给两个字符串 <strong>Client ID</strong> 和 <strong>Client Secret</strong> , 这两个下面配置的时候要用。</p><h3 id="3-配置Gitment到hexo主题中"><a href="#3-配置Gitment到hexo主题中" class="headerlink" title="3.配置Gitment到hexo主题中"></a><strong>3.配置Gitment到hexo主题中</strong></h3><p>同样的，也是一种预置gitment和自己配置分两种来说。</p><ol><li><strong>主题已经集成了gitment模块 看这里～</strong> </li></ol><ul><li>只需在 <strong>_config.yml</strong> 中找到刚才开启gitment的那里，下面有四个参数要添加。</li></ul><p>  如图所示：<img src="/2018/10/24/an-zhuang-gitment-ji-chang-jian-wen-ti-jie-jue/gitmentConfiged.jpeg" alt="gitmentConfiged"></p><ol start="2"><li><strong>主题没有集成gitment模块 根本配置在这里～</strong></li></ol><ul><li>在刚才添加的母版中继续添加如下代码：</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">var</span> gitment <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gitment</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  owner<span class="token operator">:</span> <span class="token string">'你的 GitHub ID'</span><span class="token punctuation">,</span>  repo<span class="token operator">:</span> <span class="token string">'存储评论的 repo'</span><span class="token punctuation">,</span>  oauth<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    client_id<span class="token operator">:</span> <span class="token string">'你的 client ID'</span><span class="token punctuation">,</span>    client_secret<span class="token operator">:</span> <span class="token string">'你的 client secret'</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>gitment<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将以上的代码中的四个参数按照提示填好即可。</li></ul><h3 id="4-初始化评论"><a href="#4-初始化评论" class="headerlink" title="4.初始化评论"></a><strong>4.初始化评论</strong></h3><p>理论上按照以上配置完发布即可看到评论区了。只不过每一个帖子下面的评论区都要初始化才能开始评论。</p><p>根据gitment作者的说法，只要到用博主的github账号登录后点击初始化就可以使用了。</p><h3 id="5-常见问题解决"><a href="#5-常见问题解决" class="headerlink" title="5.常见问题解决"></a><strong>5.常见问题解决</strong></h3><ul><li>评论点击登录，登录GitHub之后跳转回来的时候不能正常跳回刚才贴纸那页。每次跳到主页。</li></ul><p><strong>解决办法：</strong> 在注册OAuth application时的回调地址有问题，尝试写绑定的域名，而不是用 “https://用户名.github.io”</p><ul><li>报错 “[object ProgressEvent]”</li></ul><p><strong>原因：</strong> 在母版中调用的js文件中，有访问gitment作者的服务器代码，而作者的服务器不好使了。</p><p><strong>解决办法：</strong> 自己搭建一个服务器（需要有一个vps来辅助搭建服务器，当然下面我也会提供一个我搭建好的服务器）</p><ol><li>在服务器中clone作者的服务器源码</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/SmalBox/gh-oauth-server.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>进入项目，下载依赖，并启动</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token operator">&amp;&amp;</span> <span class="token function">nohup</span> <span class="token function">npm</span> start <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>(注：如果运行失败，可能是nodejs没有安装好，请安装nodejs。然后再重新运行命令,如果成功,在项目目录下的nohup.out文件中的最后，会提示正在监听3000端口。这里需要用nginx将证书搞定，用https访问，否则默认http还是会报错。证书的问题我就不啰嗦了，证书参考<a href="https://www.bugprogrammer.me/2018/05/19/phpnginxmysql.html#more">这个帖子的 11.后续优化 部分</a>,端口转发请参考<a href="https://segmentfault.com/a/1190000002797606">这个帖子</a>)</em></p><ol start="3"><li>替换js文件中的作者服务器为自己服务器</li></ol><p>在作者的js文件中搜索以下字符串：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">https://gh-oauth.imsun.net<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将其替换成刚才搭建服务器的地址即可。</p><p><strong>OK大功告成，可以去测试一下了。可以在本站的下面回复评论测试。</strong></p><p><strong>如果有任何问题，可以在下面评论或者通过邮件联系我。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组装小红点机械键盘 tex yoda 2 &amp; 定制键盘盖</title>
      <link href="2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/"/>
      <url>2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/</url>
      
        <content type="html"><![CDATA[<h1 id="组装小红点机械键盘-TexYoda2-amp-定制键盘盖"><a href="#组装小红点机械键盘-TexYoda2-amp-定制键盘盖" class="headerlink" title="组装小红点机械键盘 TexYoda2 &amp; 定制键盘盖"></a>组装小红点机械键盘 TexYoda2 &amp; 定制键盘盖</h1><p><img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2night.jpg" alt="TexYoda2night"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><blockquote><p>最近淘到了TexYoda2的diy套件，自己动手组装了一下。并且由于指点杆极其脆弱，又做了一个防尘盖来保护键盘(由于太过小众TB也没有，只好自己动手做了)，特此记录。</p></blockquote><blockquote><p>实际体验，在win下，默认移动速度太快，需要调到最低的速度，并配合设置里的鼠标速度来调节。在mac下也要跳到最低的移动速度，而且键盘的<strong>鼠标中键是原生好使的</strong>，可以实现滚动。</p></blockquote><h3 id="组装键盘"><a href="#组装键盘" class="headerlink" title="组装键盘"></a><strong>组装键盘</strong></h3><blockquote><p>组装键盘需要准备的工具：</p></blockquote><ol><li>TexYoda2套件</li><li>cherry轴（64个）</li><li>电烙铁+吸锡器</li></ol><h4 id="TexYoda2套件"><a href="#TexYoda2套件" class="headerlink" title="TexYoda2套件"></a>TexYoda2套件</h4><blockquote><p>先来看看大包裹。嗯～，顺丰就是靠谱，可以捏大泡泡了。</p></blockquote><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Pkg.jpg" alt="TexYoda2Pkg"></p><blockquote><p>拆包，看看这朴素的盒子，不错，这很环保。</p></blockquote><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Box.jpg" alt="TexYoda2Box"></p><blockquote><p>OK,来打开看看套件什么样子。</p></blockquote><blockquote><p>首先第一层是ABS键帽，看着挺不错的样子，相对于第一代，第二代键帽可以透光，有正刻侧刻。GBH是打磨过的，为小红点让道。对了键帽里的 esc 键可以替换成一个 tex logo 的键帽很不错。</p></blockquote><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Keycap.jpg" alt="TexYoda2Keycap"></p><blockquote><p>拿开键帽，一个折叠式的隔层，画着操作说明，嗯这个盒子做的不错。</p></blockquote><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2AssemblyInstructions.jpg" alt="TexYoda2AssemblyInstructions"></p><blockquote><p>打开隔层，来看看第二层。键盘壳、主板、定位板、鼠标三键主板放在一起，还有一个装各种配件的盒子，一个指点杆模块，几张贴纸。</p></blockquote><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Box2.jpg" alt="TexYoda2Box2"></p><blockquote><p>先来看一下指点杆套件，嗯～，很细，要小心，听说是粘上去了，很脆弱。附送了三种类型的帽子，现在的thinkpad都是默认小红毯的，可能是大多数人都喜欢小红毯吧，不过我试了三种，感觉还是凹的用起来最省力，不过他是最高的一个，打字很快的时候有时候会碰到他，但是还好几乎没什么大影响。</p></blockquote><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Trackpoint1.jpg" alt="TexYoda2Trackpoint1"></p><blockquote><p>再给指点杆一个特写</p></blockquote><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Trackpoint2.jpg" alt="TexYoda2Trackpoint2"></p><blockquote><p>TexYoda2的主板是黑色的，相较于1代绿色的看起来高端一点的样子。外壳是cnc加工的，细节重量手感都非常好。二代虽然取消了 usb hub 功能，但是把接口换成了type-c，很好用，实测手机type-c线也可以给它用，他的线也可以给手机用。主板和钢板的留口可以允许多种键盘布局，非常方便。</p></blockquote><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Shell1.jpg" alt="TexYoda2Shell1"></p><blockquote><p>再来两张特写</p></blockquote><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Shell2.jpg" alt="TexYoda2Shell2"></p><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Shell3.jpg" alt="TexYoda2Shell3"></p><blockquote><p>主板背面有键盘物理跳线开关。二代支持全键盘自定义，和12个自定义宏，并且可以同时保存3套键盘布局在键盘中。简直不要太方便啊。win mac linux 各准备一套键位或者给游戏留一套键位也可以。</p></blockquote><blockquote><p>二代的键盘是有存储能力的，应该是512kb。在TexoYoda2的官方网站就可以定制键位，然后下载下来，存储到键盘中。打开条线6，键盘就可像一个U盘一样被读取，然后存入网站配置并下载好的文件即可。网站上可以定制三种布局，分别对应条线的1 2 3，打开相应条线即可使用其布局。至于4 5 是干什么用的，目前还没搞清楚。</p></blockquote><blockquote><p>设置布局的网站在这里：<a href="https://yoda2.tex-design.com.tw/#layout">https://yoda2.tex-design.com.tw/#layout</a></p></blockquote><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Shell4.jpg" alt="TexYodaShell4"></p><blockquote><p>最后来看看这一大堆的附件，有一个数据线，是90度接口的很不错。一个 tex 的理线带。 一包 led 灯。鼠标三件的定位板。鼠标三键灯键帽（这三个貌似是pbt材质的，不透光磨砂质感）。一套卫星轴套件。两个金属键盘脚撑，和防滑垫。</p></blockquote><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Accessories1.jpg" alt="TexYoda2Accessories1"></p><blockquote><p>第一次安装卫星轴，找口看了半天，发现里面的那个最下面是有个小口可以让金属棒翘着插进去的。有不一样的豁口，所以插进去不会差错。</p></blockquote><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2SatelliteAxis1.jpg" alt="TexYoda2SatelliteAxis1"></p><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2SatelliteAxis2.jpg" alt="TexYoda2SatelliteAxis2"></p><h4 id="cherry轴"><a href="#cherry轴" class="headerlink" title="cherry轴"></a>cherry轴</h4><blockquote><p>我选配的轴是：</p></blockquote><ul><li>鼠标三键： 线性银轴</li><li>空格： 黑轴</li><li>其他： 茶轴 </li></ul><blockquote><p>至于是三脚还是五脚轴，我选的是三脚轴，毕竟便宜嘛。主板是支持五脚轴的，有钱可以上五脚。</p></blockquote><h4 id="焊接"><a href="#焊接" class="headerlink" title="焊接"></a>焊接</h4><blockquote><p>焊接就不上图了，无非就是把轴放到钢板里，放上主板，先焊轴后焊灯。需要注意点就是灯的长脚是正极，对应好板子上的正极即可。焊接灯的时候把针脚弯一点，不让灯掉下去就可以。</p></blockquote><blockquote><p>焊完接电脑测试，win平台有 Keyboardtestutility 这个软件可以用来测试键盘是否焊接好了。</p></blockquote><blockquote><p>测试软件：<a href="https://pan.baidu.com/s/1oBvK3LtMniiyZxkCWEtMQA">KeyboardTestUtility</a>  密码:tqrx</p></blockquote><blockquote><p>一切都没问题了，就可以上指点杆了，很简单穿过主板，接上排线。把鼠标三键的主板上的接口接到主板上。可以上盖了。</p></blockquote><h4 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h4><blockquote><p>安装键帽，这个，按上去就好了。根据不同的习惯，可以调整键帽的安装。比如alt和win之类的。</p></blockquote><blockquote><p>最后给指点杆上扣一个金属帽子，拧上螺丝，一定要轻，螺丝不松就行，不用太紧。</p></blockquote><blockquote><p>来个安装好的图</p></blockquote><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Feature2.jpg" alt="TexYoda2Feature2"></p><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Feature3.jpg" alt="TexYoda2Feature3"></p><h3 id="键盘盖"><a href="#键盘盖" class="headerlink" title="键盘盖"></a><strong>键盘盖</strong></h3><blockquote><p>一开始我只是想怎么保护指点杆，毕竟它那么脆弱。尤其是在放到包里的时候，挤压随时会对他产生致命的威胁。经过考虑觉得还是要一个盖子来全方位的保护键盘正面不被挤压。</p></blockquote><blockquote><p>没想到万能的TB在这个问题上也翻了车。除了hhkb那个官方的300块的盖子以外，几乎很少有键盘配盖子。很多人对盖子，大多是没啥用的态度。无奈TexYoda也是小众，盖子就更小众了。只好自己定制一个了。</p></blockquote><blockquote><p>当然让这一切成为可能的关键就是，<strong>3d打印机</strong>(<em>如果有需要，我可以提供打印机，帮助解决这一步。具体可以通过邮箱联系我</em>)。</p></blockquote><blockquote><p>盖子用料及工具：</p></blockquote><ol><li>一块2mm厚的亚克力板</li><li>直径3mm，长6mm的螺丝及其螺丝帽 * 16组</li><li>给家具用的贴膜一张</li><li>3d打印机极其耗材（我用的是PLA）</li><li>电烙铁+美工刀改装的电热刀（如果有其他更强大的切割亚克力板的工具可以都上）</li><li>电钻</li></ol><blockquote><p>盖子顶部 <strong>宽度 12cm 长度 28cm</strong> ，<strong>侧面 长度 28cm 高度 1.9cm</strong> 。</p></blockquote><ul><li>亚克力板先按照尺寸用电热刀切好。</li><li>下载模型:<a href="https://pan.baidu.com/s/1aiAOrdUdaHInRGBiMHjZXA">点击下载模型</a>  密码：grod</li><li>将盖子的左右极其中间的固定架用3d打印机打好。</li><li>将打好的固定架和亚克力板组装好，亚克力板肯定会长一点，这时候用电热刀进行细微的切割让其正确安装。</li><li>插好后用电钻在固定的地方开孔，并在开孔后在孔的边缘多磨掉一圈，好让螺丝嵌入到固定架中，而不是螺丝头突出来。（当然了这步开孔可以在设计古井家的时候就把孔开好，不过我懒了一下，直接用电钻搞定哈哈。）</li><li>开孔完成后，将边缘打磨好，可以开始贴膜了。</li><li>这步应该是比较考验技巧的时候，商家说用洗洁精泡泡水在被贴的表面清洁，并多撒点好贴膜，防止膜一下子就沾上。实际呢，我发现洗洁精的水，容易在亚克力板上留下痕迹，很难看，最后我是用易挥发的酒精完成的，虽然还是有一些气泡吧。</li><li>最后最后，安装好所有的固定架，完活～</li></ul><blockquote><p>成品：</p></blockquote><p>  <img src="/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Feature1.jpg" alt="TexYoda2Feature1"></p>]]></content>
      
      
      <categories>
          
          <category> DIY </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小红点 </tag>
            
            <tag> yex yoda 2 </tag>
            
            <tag> 定制键盘盖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>earphone1</title>
      <link href="2018/09/26/earphone1/"/>
      <url>2018/09/26/earphone1/</url>
      
        <content type="html"><![CDATA[<h1 id="earphone1"><a href="#earphone1" class="headerlink" title="earphone1"></a>earphone1</h1><p><img src="/2018/09/26/earphone1/earphone1.png" alt="earphone1"></p>]]></content>
      
      
      <categories>
          
          <category> 画点啥 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hand painted </tag>
            
            <tag> earphone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitNote</title>
      <link href="2018/09/23/gitnote/"/>
      <url>2018/09/23/gitnote/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-command-note"><a href="#Git-command-note" class="headerlink" title="Git command note"></a>Git command note</h1><h2 id="Install-initialize-user-name-and-user-email"><a href="#Install-initialize-user-name-and-user-email" class="headerlink" title="Install: initialize user name and user email."></a>Install: initialize user name and user email.</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config --global user.name <span class="token string">"Your Name"</span>$ <span class="token function">git</span> config --global user.email <span class="token string">"email@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="1-Create-git"><a href="#1-Create-git" class="headerlink" title="1.Create git"></a>1.Create git</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> learnBox <span class="token comment">#创建目录作为仓库</span>$ <span class="token builtin class-name">cd</span> learnBox <span class="token comment">#进入目录</span>$ <span class="token builtin class-name">pwd</span> <span class="token comment">#显示仓库位置</span>$ <span class="token function">git</span> init <span class="token comment">#创建仓库（仓库根目录下有.git的隐藏目录，用ls -ah可以看到）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-Add-amp-Commit-file"><a href="#2-Add-amp-Commit-file" class="headerlink" title="2.Add &amp; Commit file"></a>2.Add &amp; Commit file</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt <span class="token comment">#添加文件到仓库</span>$ <span class="token function">git</span> commit -m <span class="token string">"add readme.txt"</span> <span class="token comment">#提交以上添加，填写修改信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-Check-the-status-amp-difference"><a href="#3-Check-the-status-amp-difference" class="headerlink" title="3.Check the status &amp; difference"></a>3.Check the status &amp; difference</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> status <span class="token comment">#查看仓库状态</span>$ <span class="token function">git</span> <span class="token function">diff</span> readme.txt <span class="token comment">#查看具体修改了哪些</span>$ <span class="token function">git</span> log <span class="token comment">#从近到远查看提交日志</span>$ <span class="token function">git</span> log --pretty<span class="token operator">=</span>oneline <span class="token comment">#简化日志每个只显示一行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-Reset"><a href="#4-Reset" class="headerlink" title="4.Reset"></a>4.Reset</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> reset --hard HEAD^ <span class="token comment">#退回上一个版本 '^'退回一个 '~100'退100个</span>$ <span class="token function">git</span> reset --hard <span class="token operator">&lt;</span>version id<span class="token operator">></span> <span class="token comment">#版本号写前几位即可，git自己会找</span>$ <span class="token function">git</span> reflog <span class="token comment">#记录执行过的命令</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="5-Stage-index"><a href="#5-Stage-index" class="headerlink" title="5.Stage(index)"></a>5.Stage(index)</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">使用 <span class="token string">"git add"</span> 命令将工作区文件添加到stage暂存区。使用 <span class="token string">"git commit"</span> 命令将stage暂存区中文件添加到分支。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="6-Manage-modify"><a href="#6-Manage-modify" class="headerlink" title="6.Manage modify"></a>6.Manage modify</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">先add添加到stage，后commit到分支。$ <span class="token function">git</span> <span class="token function">diff</span> HEAD -- readme.txt <span class="token comment">#查看工作区和版本库中最新版本区别</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="7-Undo-changes"><a href="#7-Undo-changes" class="headerlink" title="7.Undo changes"></a>7.Undo changes</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span><span class="token punctuation">)</span>无add无commit：$ <span class="token function">git</span> checkout -- <span class="token operator">&lt;</span>file<span class="token operator">></span><span class="token number">2</span><span class="token punctuation">)</span>有add无commit：$ <span class="token function">git</span> reset HEAD <span class="token operator">&lt;</span>file<span class="token operator">></span>$ <span class="token function">git</span> checkout -- <span class="token operator">&lt;</span>file<span class="token operator">></span><span class="token number">3</span><span class="token punctuation">)</span>有add有commit：$ <span class="token function">git</span> reset --hard HEAD^<span class="token comment">#退回上一版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-Remove-file"><a href="#8-Remove-file" class="headerlink" title="8.Remove file"></a>8.Remove file</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> <span class="token operator">&lt;</span>file<span class="token operator">></span> <span class="token comment">#删除工作区的文件</span>$ <span class="token function">git</span> <span class="token function">rm</span> <span class="token operator">&lt;</span>file<span class="token operator">></span> <span class="token comment">#如果真的想删，删除版本库里的文件</span>$ <span class="token function">git</span> checkout -- <span class="token operator">&lt;</span>file<span class="token operator">></span> <span class="token comment">#误删了工作区文件，用版本库恢复删除文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Remote-repository"><a href="#Remote-repository" class="headerlink" title="Remote repository"></a>Remote repository</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen -t rsa -C <span class="token string">"email@example.com"</span> <span class="token comment">#创建ssh协议公钥和私钥</span><span class="token comment">#进入到GitHub中添加ssh key 即可远程推送</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="9-Add-and-remove-remote-repository"><a href="#9-Add-and-remove-remote-repository" class="headerlink" title="9.Add and remove remote repository"></a>9.Add and remove remote repository</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote <span class="token function">add</span> origin https://github.com/SmalBox/learngit.git$ <span class="token function">git</span> remote <span class="token function">add</span> origin git@github.com:SmalBox/learngit.git<span class="token comment">#GitHub上的提示添加远程库.这两种都可以</span>$ <span class="token function">git</span> remote <span class="token function">rm</span> <span class="token operator">&lt;</span>remote name<span class="token operator">></span> <span class="token comment">#移除远程库</span>$ <span class="token function">git</span> push -u origin master <span class="token comment">#将本地库推送到GitHub</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-Clone-from-remote-repository"><a href="#10-Clone-from-remote-repository" class="headerlink" title="10.Clone from remote repository"></a>10.Clone from remote repository</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone git@github.com:SmalBox/repositoryName.git <span class="token comment">#从远程克隆到本地</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Manage-branch"><a href="#Manage-branch" class="headerlink" title="Manage branch"></a>Manage branch</h2><h2 id="11-Create-amp-Combine-branch"><a href="#11-Create-amp-Combine-branch" class="headerlink" title="11.Create &amp; Combine branch"></a>11.Create &amp; Combine branch</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token comment">#查看分支结构</span>$ <span class="token function">git</span> branch <span class="token operator">&lt;</span>name<span class="token operator">></span> <span class="token comment">#创建分支</span>$ <span class="token function">git</span> checkout <span class="token operator">&lt;</span>name<span class="token operator">></span> <span class="token comment">#切换分支</span>$ <span class="token function">git</span> checkout -b <span class="token operator">&lt;</span>name<span class="token operator">></span> <span class="token comment">#创建并切换分支</span>$ <span class="token function">git</span> merge <span class="token operator">&lt;</span>name<span class="token operator">></span> <span class="token comment">#合并某分支到当前分支</span>$ <span class="token function">git</span> branch -d <span class="token operator">&lt;</span>name<span class="token operator">></span> <span class="token comment">#删除某分支</span>$ <span class="token function">git</span> branch -D <span class="token operator">&lt;</span>name<span class="token operator">></span> <span class="token comment">#强行删除某分支，例如强行删除未合并的分支</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout -b dev <span class="token comment">#创建并切换 到dev分支</span>$ <span class="token function">git</span> branch <span class="token comment">#查看 分支</span>$ <span class="token function">git</span> checkout master <span class="token comment">#切换 到master分支</span>$ <span class="token function">git</span> merge dev <span class="token comment">#把dev分支 合并 到master分支</span>$ <span class="token function">git</span> branch -d dev <span class="token comment">#删除 dev分支</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-Conflict-fixed"><a href="#12-Conflict-fixed" class="headerlink" title="12.Conflict fixed"></a>12.Conflict fixed</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#当两个分支修改同一个文件，合并时产生冲突。</span><span class="token comment">#在当前分支修改冲突文件，再add和commit之后重新合并。</span>$ <span class="token function">git</span> log --graph --pretty<span class="token operator">=</span>oneline --addrev-commit <span class="token comment">#查看分之合并图</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="13-Branch-strategy"><a href="#13-Branch-strategy" class="headerlink" title="13.Branch strategy"></a>13.Branch strategy</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> merge --no-ff -m <span class="token string">"merge with no-ff"</span> dev <span class="token comment">#不使用Fast</span>forward合并，创建一个commit记录。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="14-Bug-branch-Stach"><a href="#14-Bug-branch-Stach" class="headerlink" title="14.Bug branch(Stach)"></a>14.Bug branch(Stach)</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> stash <span class="token comment">#把暂时没完成的分支储藏起来</span>$ <span class="token function">git</span> stash list <span class="token comment">#列出存储的各个版本</span>$ <span class="token function">git</span> stash pop <span class="token comment">#恢复储藏，并删除stach记录</span>$ <span class="token function">git</span> stash apply stash@<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span> <span class="token comment">#恢复到stash0</span>$ <span class="token function">git</span> stash drop <span class="token comment">#删除stash内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-Collaboration"><a href="#15-Collaboration" class="headerlink" title="15.Collaboration"></a>15.Collaboration</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote <span class="token comment">#查看远程仓库信息(name)</span>$ <span class="token function">git</span> remote -v <span class="token comment">#查看远程仓库详细信息</span>$ <span class="token function">git</span> push <span class="token operator">&lt;</span>git name<span class="token operator">></span> <span class="token operator">&lt;</span>branch name<span class="token operator">></span> <span class="token comment">#推送分支 例如：git push origin master</span>$ <span class="token function">git</span> checkout -b dev origin/dev <span class="token comment">#创建本地dev链接远程仓库中的dev</span>$ <span class="token function">git</span> pull <span class="token comment">#推送失败，远程分支新，用此试图合并</span>$ <span class="token function">git</span> <span class="token function">git</span>  branch --set-upstream-to<span class="token operator">=</span><span class="token operator">&lt;</span>remote name<span class="token operator">></span>/<span class="token operator">&lt;</span>branch name<span class="token operator">></span> <span class="token comment">#无跟踪信息时，说明本地分支与远程分支没有建立关系，用此建立</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="16-Tag"><a href="#16-Tag" class="headerlink" title="16.Tag"></a>16.Tag</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token operator">&lt;</span>name<span class="token operator">></span> <span class="token comment">#给当前分支打标签,标签打在最新提交的commit上</span>$ <span class="token function">git</span> tag <span class="token comment">#查看当前分支的标签</span>$ <span class="token function">git</span> tag <span class="token operator">&lt;</span>name<span class="token operator">></span> <span class="token operator">&lt;</span>commit id<span class="token operator">></span> <span class="token comment">#给某一个版本的commit打标签</span>$ <span class="token function">git</span> tag -a <span class="token operator">&lt;</span>tag name<span class="token operator">></span> -m <span class="token string">"description"</span> <span class="token operator">&lt;</span>commit id<span class="token operator">></span> <span class="token comment">#带有说明的标签</span>$ <span class="token function">git</span> tag -s <span class="token operator">&lt;</span>tag name<span class="token operator">></span> -m <span class="token string">"description"</span> <span class="token operator">&lt;</span>commit id<span class="token operator">></span> <span class="token comment">#私钥签名一个标签</span>$ <span class="token function">git</span> show <span class="token operator">&lt;</span>tag name<span class="token operator">></span> <span class="token comment">#查看标签信息</span>$ <span class="token function">git</span> tag -d <span class="token operator">&lt;</span>tag name<span class="token operator">></span> <span class="token comment">#删除标签</span>$ <span class="token function">git</span> push <span class="token operator">&lt;</span>remote name<span class="token operator">></span> <span class="token operator">&lt;</span>tag name<span class="token operator">></span> <span class="token comment">#推送某一标签到远程仓库</span>$ <span class="token function">git</span> push <span class="token operator">&lt;</span>remote name<span class="token operator">></span> --tags <span class="token comment">#推送全部标签到远程</span><span class="token comment">#删除远程标签，要先删除本地标签，再推送远程。格式如下：</span>$ <span class="token function">git</span> tag -d <span class="token operator">&lt;</span>tag name<span class="token operator">></span> <span class="token comment">#删除本地标签</span>$ <span class="token function">git</span> push <span class="token operator">&lt;</span>remote name<span class="token operator">></span> :refs/tags/<span class="token operator">&lt;</span>tag name<span class="token operator">></span> <span class="token comment">#推送远程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="17-Alias"><a href="#17-Alias" class="headerlink" title="17.Alias"></a>17.Alias</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> config --global alias.co checkout <span class="token comment">#设置全局简写</span>$ <span class="token function">git</span> config --global alias.st status $ <span class="token function">git</span> config --global alias.ci commit$ <span class="token function">git</span> config --global alias.br branch$ <span class="token function">git</span> config --global alias.lol <span class="token string">"log --pretty=oneline"</span>$ <span class="token function">git</span> config --global alias.glol <span class="token string">"log --graph --pretty=oneline --abbrev-commit"</span><span class="token comment">#全局的配置文件在用户目录下名为：.gitconfig中记录。每个仓库的配置文件在仓库下的.git文件下config文件中记录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="18-Setting-up-a-proxy"><a href="#18-Setting-up-a-proxy" class="headerlink" title="18.Setting up a proxy"></a>18.Setting up a proxy</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 设置只对github代理</span>$ <span class="token function">git</span> config --global http.https://github.com.proxy socks5://127.0.0.1:本地代理端口号<span class="token comment"># 取消代理</span>$ <span class="token function">git</span> config --global --unset http.proxy$ <span class="token function">git</span> config --global --unset http.https://github.com.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="19-Git-Large-File-Storage"><a href="#19-Git-Large-File-Storage" class="headerlink" title="19.Git Large File Storage"></a>19.Git Large File Storage</h2><p>去 Git Large File Storage <a href="https://git-lfs.github.com/">官网</a>下载安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 提供Git对大文件存储支持</span><span class="token comment"># 在每个git版本库下执行一下命令以提供大文件存储功能</span>$ <span class="token function">git</span> lfs <span class="token function">install</span>$ <span class="token function">git</span> lfs track <span class="token string">"*.psd"</span>$ <span class="token function">git</span> <span class="token function">add</span> .gitattributes$ <span class="token function">git</span> commit -m <span class="token string">"添加对psd文件的支持"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在git版本库的目录下修改 .gitattributes 即可快速添加支持文件<br>例如在 .gitattributes 添加如下配置文件:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Image formats:</span>*.tga <span class="token assign-left variable">filter</span><span class="token operator">=</span>lfs <span class="token assign-left variable">diff</span><span class="token operator">=</span>lfs <span class="token assign-left variable">merge</span><span class="token operator">=</span>lfs -text*.png <span class="token assign-left variable">filter</span><span class="token operator">=</span>lfs <span class="token assign-left variable">diff</span><span class="token operator">=</span>lfs <span class="token assign-left variable">merge</span><span class="token operator">=</span>lfs -text*.tif <span class="token assign-left variable">filter</span><span class="token operator">=</span>lfs <span class="token assign-left variable">diff</span><span class="token operator">=</span>lfs <span class="token assign-left variable">merge</span><span class="token operator">=</span>lfs -text*.jpg <span class="token assign-left variable">filter</span><span class="token operator">=</span>lfs <span class="token assign-left variable">diff</span><span class="token operator">=</span>lfs <span class="token assign-left variable">merge</span><span class="token operator">=</span>lfs -text*.gif <span class="token assign-left variable">filter</span><span class="token operator">=</span>lfs <span class="token assign-left variable">diff</span><span class="token operator">=</span>lfs <span class="token assign-left variable">merge</span><span class="token operator">=</span>lfs -text*.psd <span class="token assign-left variable">filter</span><span class="token operator">=</span>lfs <span class="token assign-left variable">diff</span><span class="token operator">=</span>lfs <span class="token assign-left variable">merge</span><span class="token operator">=</span>lfs -text<span class="token comment"># Audio formats:</span>*.mp3 <span class="token assign-left variable">filter</span><span class="token operator">=</span>lfs <span class="token assign-left variable">diff</span><span class="token operator">=</span>lfs <span class="token assign-left variable">merge</span><span class="token operator">=</span>lfs -text*.wav <span class="token assign-left variable">filter</span><span class="token operator">=</span>lfs <span class="token assign-left variable">diff</span><span class="token operator">=</span>lfs <span class="token assign-left variable">merge</span><span class="token operator">=</span>lfs -text*.aiff <span class="token assign-left variable">filter</span><span class="token operator">=</span>lfs <span class="token assign-left variable">diff</span><span class="token operator">=</span>lfs <span class="token assign-left variable">merge</span><span class="token operator">=</span>lfs -text<span class="token comment"># 3D model formats:</span>*.fbx <span class="token assign-left variable">filter</span><span class="token operator">=</span>lfs <span class="token assign-left variable">diff</span><span class="token operator">=</span>lfs <span class="token assign-left variable">merge</span><span class="token operator">=</span>lfs -text*.obj <span class="token assign-left variable">filter</span><span class="token operator">=</span>lfs <span class="token assign-left variable">diff</span><span class="token operator">=</span>lfs <span class="token assign-left variable">merge</span><span class="token operator">=</span>lfs -text<span class="token comment"># Unity formats:</span>*.sbsar <span class="token assign-left variable">filter</span><span class="token operator">=</span>lfs <span class="token assign-left variable">diff</span><span class="token operator">=</span>lfs <span class="token assign-left variable">merge</span><span class="token operator">=</span>lfs -text*.unity <span class="token assign-left variable">filter</span><span class="token operator">=</span>lfs <span class="token assign-left variable">diff</span><span class="token operator">=</span>lfs <span class="token assign-left variable">merge</span><span class="token operator">=</span>lfs -text<span class="token comment"># Other binary formats</span>*.dll <span class="token assign-left variable">filter</span><span class="token operator">=</span>lfs <span class="token assign-left variable">diff</span><span class="token operator">=</span>lfs <span class="token assign-left variable">merge</span><span class="token operator">=</span>lfs -text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="20-Git-remove-untracked-files"><a href="#20-Git-remove-untracked-files" class="headerlink" title="20.Git remove untracked files"></a>20.Git remove untracked files</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 移除未被跟踪的文件</span>$ <span class="token function">git</span> clean <span class="token punctuation">[</span>-d<span class="token punctuation">]</span> <span class="token punctuation">[</span>-f<span class="token punctuation">]</span> <span class="token punctuation">[</span>-i<span class="token punctuation">]</span> <span class="token punctuation">[</span>-n<span class="token punctuation">]</span> <span class="token punctuation">[</span>-q<span class="token punctuation">]</span> <span class="token punctuation">[</span>-e <span class="token operator">&lt;</span>pattern<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span>-x <span class="token operator">|</span> -X<span class="token punctuation">]</span> <span class="token punctuation">[</span>--<span class="token punctuation">]</span> <span class="token operator">&lt;</span>paths<span class="token operator">></span><span class="token punctuation">..</span>.<span class="token comment"># 常用参数：</span><span class="token comment"># -n 试运行</span><span class="token comment"># -f 删除当前目录未跟踪文件，不删除文件夹</span><span class="token comment"># -df 删除未跟踪 文件和文件夹</span>$ <span class="token function">git</span> -ndf <span class="token comment"># 试运行</span>$ <span class="token function">git</span> -df <span class="token comment"># 运行清理</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul><li><strong>Q1: Git push到远程时，遇到 “fatal: TaskCanceledException encountered” 错误</strong><ul><li><strong>A1:</strong><ul><li>在终端输入：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config –global credential.helper store<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在.gitconfig文件中，可以看到多了一项：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>credential<span class="token punctuation">]</span>helper <span class="token operator">=</span> store<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ul></li><li><strong>Q2: windows Git Bash 输入python无响应</strong><ul><li><strong>A2:</strong><ul><li>安装Git Bash 的时候有提示，MinTTY不支持交互操作，如Python和Node, 用winpty + program就可以运行了</li><li>有三种方法：<ol><li>利用winpty接口<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">winpty python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>显示使用python -i<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python -i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>用git的alias按键映射，映射上述两方案<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 在 /etc/bash.bashrc 这个文件中加入</span><span class="token builtin class-name">alias</span> <span class="token assign-left variable">python</span><span class="token operator">=</span><span class="token string">'winpty python'</span><span class="token comment">#然后重启bash，因为它每次重启时会读取bashrc文件来进行初始配置。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol></li></ul></li></ul></li><li><strong>Q3: Git HEAD detached from XXX</strong><ul><li><strong>A3:</strong><ul><li><a href="https://www.jianshu.com/p/fdd3c2d020d7">解决源帖</a></li><li>解决方案简述<ul><li>新建个临时分支temp <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch temp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>切换到要恢复的分支master <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>合并临时分支temp到恢复分支master <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> merge temp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>删除临时分支temp <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch -d temp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
