{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/hexo-theme-matery/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/avatar.png","path":"medias/avatar.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","path":"medias/logo.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","path":"medias/cover.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.png","path":"medias/reward/alipay.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"source/images/pageHeadImg/earphone1.png","path":"images/pageHeadImg/earphone1.png","modified":1,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"source/images/pageHeadImg/git.png","path":"images/pageHeadImg/git.png","modified":1,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"9b17890ea5dbcf56a281d6976db6cdcdd7f2bdc9","modified":1574498673243},{"_id":"themes/hexo-theme-matery/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1574612724582},{"_id":"themes/hexo-theme-matery/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1574498673581},{"_id":"themes/hexo-theme-matery/README.md","hash":"6bb9bbe1c6ea691e58f250de21bb729e956313ad","modified":1574612724582},{"_id":"themes/hexo-theme-matery/_config.yml","hash":"a5e545f58be5c01a975708b239220aac1359b89f","modified":1574612724583},{"_id":"themes/hexo-theme-matery/README_CN.md","hash":"a94324950e0299bcfcbc106cf2ca65c93e1fe843","modified":1574612724583},{"_id":"source/_data/friends.json","hash":"8c9353c3f203bb43b689a653e88007dcaf8b8fdf","modified":1577974255684},{"_id":"source/about/index.md","hash":"fd0954e7b89aab4174d57ca116db94219260b9af","modified":1574612724484},{"_id":"source/_posts/DIY笔记本收纳支架.md","hash":"373795dee9df4a2ddb137ae041c6e31b5020ce2a","modified":1575998093737},{"_id":"source/_posts/VScode-问题及解决方案.md","hash":"36654f00a5cd0e3930d025174ea06f4f7e64897c","modified":1577974255685},{"_id":"source/_posts/Unity导出Android工程.md","hash":"0fc44ddb271c930eab5380ec0ce47f3a0686afdd","modified":1586010027976},{"_id":"source/_posts/earphone1.md","hash":"1a7cb394484018736593e09784a9b742686e364d","modified":1574612724438},{"_id":"source/_posts/gitNote.md","hash":"5f57cbe78afdb90e54d447743ff1aa38ff4eb1f6","modified":1578048153494},{"_id":"source/_posts/hello-world.md","hash":"029f91fccbe8f87c0f3ea10c4042300d2fa7edc0","modified":1574498673248},{"_id":"source/_posts/mi5魔改8000mAh大电池.md","hash":"3b483481992a1fdee84f70ec115ae42eaf47d733","modified":1574612724438},{"_id":"source/_posts/screen代替nohup运行后台进程.md","hash":"f88ea9775a6f1957d8f159d585878ec40a03495d","modified":1574612724454},{"_id":"source/_posts/事件驱动编程-翻译.md","hash":"0ba3cd43736eb514b8eaf7643d961f554b1af4a6","modified":1586010110631},{"_id":"source/_posts/安装Gitment及常见问题解决.md","hash":"4840371d0dee6e0a9faf89a79a077a3026c27203","modified":1577974255686},{"_id":"source/_posts/抢救群晖系统简述.md","hash":"3fb5b8967058eae6652772e0903c147b4391c62d","modified":1586005596609},{"_id":"source/_posts/笔记本-K680e-改侧键开机.md","hash":"278441d35b9167571ee090eaaf1f229bb8c48ccb","modified":1574612724455},{"_id":"source/_posts/笔记本超频内存条的-小秘密.md","hash":"dd672d72bf43774494f0da7a8cc6cebd400fe3b1","modified":1574612724470},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖.md","hash":"889a8f91b6512dacf2586ca910775c1e9a0eb6d0","modified":1574612724470},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1.md","hash":"4515ee10ba6c7b892b39abd8d282fd6aca1c0c0c","modified":1586010094425},{"_id":"source/_posts/视频编码与封装.md","hash":"1c960091cc4987ec1da69396f9281ef014e6b01c","modified":1574612724483},{"_id":"source/_posts/花牌记分器.md","hash":"49ee54562e0a628959b67827a74f580d2e9269b2","modified":1586006840601},{"_id":"source/categories/index.md","hash":"806e4f1adc75e16bb9ec7b1fcb252e10bc5dcad2","modified":1574612724484},{"_id":"source/friends/index.md","hash":"a8278b56dc33dde214541358151b19e7056d198d","modified":1574612724484},{"_id":"source/tags/index.md","hash":"5920a459ac2f9db439bf49bb66c53eca6e86902a","modified":1574498673581},{"_id":"themes/hexo-theme-matery/languages/default.yml","hash":"53950d4a931c7beaf368a7be8d3e010ebeabedd5","modified":1574612724584},{"_id":"themes/hexo-theme-matery/languages/zh-CN.yml","hash":"d8df0fcfa465bc5977cbd04ff9b4b560378d16ff","modified":1574612724584},{"_id":"themes/hexo-theme-matery/layout/about.ejs","hash":"0a8942e2fa070d7d08ef0779267e1e05ff8e3065","modified":1574612724599},{"_id":"themes/hexo-theme-matery/layout/archive.ejs","hash":"410d85c8a8dbf8f66ce0c201eabeb107c1087544","modified":1574612724599},{"_id":"themes/hexo-theme-matery/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1574612724599},{"_id":"themes/hexo-theme-matery/layout/friends.ejs","hash":"6758845f243de140bfd8cd1c2c962d967f9f09ff","modified":1574612724600},{"_id":"themes/hexo-theme-matery/layout/category.ejs","hash":"c3651f9a24dfd38323508ae6ab2232bddacee718","modified":1574612724600},{"_id":"themes/hexo-theme-matery/layout/index.ejs","hash":"a8a8e1aca0d016b6da3c76b250f7f416f00384c3","modified":1574612724601},{"_id":"themes/hexo-theme-matery/layout/layout.ejs","hash":"f99d28f7c3382caf4321641f2d79582aac0b0c90","modified":1574612724601},{"_id":"themes/hexo-theme-matery/layout/post.ejs","hash":"9ecae79690293cacdccc172118f1fe481705b1f2","modified":1574612724601},{"_id":"themes/hexo-theme-matery/layout/tag.ejs","hash":"ac3837ecb32926e4c51c7c57cd0778242a4af7eb","modified":1574612724602},{"_id":"themes/hexo-theme-matery/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1574612724602},{"_id":"themes/hexo-theme-matery/source/favicon.png","hash":"13a18c04d013350477482850f8485384f298e21a","modified":1574498673592},{"_id":"source/_posts/安装Gitment及常见问题解决/gitmentConfiged.jpeg","hash":"0cd093ed8ef7d6bdac7952dd7c506d452afb2401","modified":1574498673250},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/capacityExpansion4.png","hash":"16b95f31a66e55f2624a991508644438b14c62da","modified":1574612724473},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne1.png","hash":"5dac4e8224e95236e9eaa7cccfc925d3f14d53d7","modified":1574612724474},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne4.png","hash":"ee9a41c038e3413348902aa0446b132535838d23","modified":1574612724477},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne5.png","hash":"261d75ab24d3ad4e0d7503878789e2b1d7d0c3ef","modified":1574612724478},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne6.png","hash":"93ba9a46c0392e9f255121c2805da8fb00d90da9","modified":1574612724479},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne7.png","hash":"0dff4d6201f4189b6729ab5b62eee64d7e8c49c2","modified":1574612724479},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne8.png","hash":"de19c51deee3548b47df5f0029d14f4d2f733497","modified":1574612724480},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne9.png","hash":"0012d453374127ca40d1950d3d5a199a1369a149","modified":1574612724480},{"_id":"themes/hexo-theme-matery/layout/_partial/back-top.ejs","hash":"cb99dc352397ec5d0765794d7b8884972e61973b","modified":1574612724585},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover-content.ejs","hash":"0d64a97d67e95e03858be6f7ee2478c1d0dd3c6b","modified":1574612724585},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover.ejs","hash":"d5a7b9bb96e04c0a3485dd873748f19c50a6a04f","modified":1574612724585},{"_id":"themes/hexo-theme-matery/layout/_partial/disqus.ejs","hash":"42dda8e67f7f09d148347887e52f18aea546df26","modified":1574498673584},{"_id":"themes/hexo-theme-matery/layout/_partial/footer.ejs","hash":"3b9ccbadafd05c279a046f1a6fea65e9149bb764","modified":1574612724586},{"_id":"themes/hexo-theme-matery/layout/_partial/gitalk.ejs","hash":"4c658c0e2a6c666667199d1402aab4bcf9236b89","modified":1574612724586},{"_id":"themes/hexo-theme-matery/layout/_partial/github-link.ejs","hash":"fd4034bca2eb3987dcf113e6477260bee97eb1e7","modified":1574612724587},{"_id":"themes/hexo-theme-matery/layout/_partial/gitment.ejs","hash":"d8c40dbc8106b5bc53ceb727ad968c1d8f234261","modified":1574498673585},{"_id":"themes/hexo-theme-matery/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1574612724587},{"_id":"themes/hexo-theme-matery/layout/_partial/head.ejs","hash":"6e51f083e032ea02ea4d07966d2d1cdf27915edf","modified":1574612724587},{"_id":"themes/hexo-theme-matery/layout/_partial/header.ejs","hash":"821e1af65990521c9e0288178d8e5b18c73a9cab","modified":1574612724588},{"_id":"themes/hexo-theme-matery/layout/_partial/index-cover.ejs","hash":"dded138c6cf821147b576658fd836d2f8900acfb","modified":1574612724588},{"_id":"themes/hexo-theme-matery/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1574612724589},{"_id":"themes/hexo-theme-matery/layout/_partial/mobile-nav.ejs","hash":"8e4f8158a65843f7b4e5cde81c634ed181ee0667","modified":1574612724589},{"_id":"themes/hexo-theme-matery/layout/_partial/navigation.ejs","hash":"33c882dc2575739df042297f0ffa80d89ac10cd0","modified":1574612724589},{"_id":"themes/hexo-theme-matery/layout/_partial/paging.ejs","hash":"dfdeea9c59d157acb851d4bf44bf95f81787523c","modified":1574498673587},{"_id":"themes/hexo-theme-matery/layout/_partial/post-cover.ejs","hash":"ae8a8db3f0d630e92cf70cfcb3a9afb026b1395a","modified":1574612724590},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail-toc.ejs","hash":"82cb8090cde663fa7ad67418a802997b3057e957","modified":1574612724590},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail.ejs","hash":"f3b21b99cde02d1fb84d2acda6542fdfc4270578","modified":1574612724591},{"_id":"themes/hexo-theme-matery/layout/_partial/post-statis.ejs","hash":"3b42900247d5ea4ea5b68e2be44420a0d54785ad","modified":1574612724591},{"_id":"themes/hexo-theme-matery/layout/_partial/reprint-statement.ejs","hash":"f85a222ec3f9bc27eb7978015e63a16514b38791","modified":1574612724592},{"_id":"themes/hexo-theme-matery/layout/_partial/prev-next.ejs","hash":"d0435697981030e5191436e24dd281fef915b062","modified":1574612724591},{"_id":"themes/hexo-theme-matery/layout/_partial/reward.ejs","hash":"73624d9db81e87ff0c12310bb873fbd0b5221021","modified":1574612724592},{"_id":"themes/hexo-theme-matery/layout/_partial/search.ejs","hash":"e859fe6e0259e0c123cb7ceda6e4cac836318ffc","modified":1574612724592},{"_id":"themes/hexo-theme-matery/layout/_partial/share.ejs","hash":"0f2e1e27d21492cf228e786daead985b1e1dcea4","modified":1574498673589},{"_id":"themes/hexo-theme-matery/layout/_partial/social-link.ejs","hash":"951810257f3dfafcc5156005daa0b65dd24a6296","modified":1574612724593},{"_id":"themes/hexo-theme-matery/layout/_partial/valine.ejs","hash":"8671cff27aef7298b2518dd57fe0671959f21701","modified":1574612724593},{"_id":"themes/hexo-theme-matery/layout/_widget/category-cloud.ejs","hash":"b2b22d4fc4e46b051f67216c391f629f4ff552b5","modified":1574612724594},{"_id":"themes/hexo-theme-matery/layout/_widget/category-radar.ejs","hash":"5284712d84bbaa4f0d88026ac3ec5a8c13e00056","modified":1574612724594},{"_id":"themes/hexo-theme-matery/layout/_widget/music.ejs","hash":"fc50cb4bbc1f4d0e4c9f5941f1c3c74bea742db7","modified":1574612724595},{"_id":"themes/hexo-theme-matery/layout/_widget/dream.ejs","hash":"2af85ddef6e61a44cbe10e8f6272a8324681ee3f","modified":1574612724594},{"_id":"themes/hexo-theme-matery/layout/_widget/my-projects.ejs","hash":"785cb588a31215876f6737213054ba0e8552fff0","modified":1574612724596},{"_id":"themes/hexo-theme-matery/layout/_widget/my-gallery.ejs","hash":"9ea672db65f1e5b8fad1ffafb1614f25adc97e63","modified":1574612724595},{"_id":"themes/hexo-theme-matery/layout/_widget/my-skills.ejs","hash":"599a49af8ce843878253dd95f07a06b00c269f47","modified":1574612724596},{"_id":"themes/hexo-theme-matery/layout/_widget/post-calendar.ejs","hash":"4608af6151f0e32f668c89f09343748340021478","modified":1574612724596},{"_id":"themes/hexo-theme-matery/layout/_widget/post-charts.ejs","hash":"0aaf0a111b9aa07ff37f6286eeac5506283f47f8","modified":1574612724597},{"_id":"themes/hexo-theme-matery/layout/_widget/recommend.ejs","hash":"42a88f242d9a446dc4c648575f7c05483d2d99a0","modified":1574612724597},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-cloud.ejs","hash":"6310903eb0e434d6f9a59ca669aab7fae38d4797","modified":1574612724598},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-wordcloud.ejs","hash":"34b625b27b2b7fe6f47c62a07c4f0a664ad06f32","modified":1574612724598},{"_id":"themes/hexo-theme-matery/layout/_widget/video.ejs","hash":"05f5e2acace5730cdf7bed650375ad88f6b5d1b7","modified":1574612724598},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1574498673591},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1574612724603},{"_id":"themes/hexo-theme-matery/source/css/matery.css","hash":"6f2b8cabc648294bb8e12b6966ac9da7789d4c5d","modified":1574612724603},{"_id":"themes/hexo-theme-matery/source/css/my.css","hash":"37683a9f11c68903a53e2b8593ca8c095a721896","modified":1574498673592},{"_id":"themes/hexo-theme-matery/source/js/matery.js","hash":"208b7806caa943c115aa0825c9c72a0781404775","modified":1574612724604},{"_id":"themes/hexo-theme-matery/source/js/search.js","hash":"77ecae23dd3edd8ad962c5b12954652bb2f7a1b6","modified":1574498673593},{"_id":"themes/hexo-theme-matery/source/medias/avatar.png","hash":"dbe1d07d6bd34b037d939de25ed31e74376800ab","modified":1574612724629},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","hash":"dbe1d07d6bd34b037d939de25ed31e74376800ab","modified":1574498673656},{"_id":"source/_posts/DIY笔记本收纳支架/cuttingAcrylicBoard.jpg","hash":"0eb498c3e333d03bd84d398e5618ed7e1816d0b8","modified":1574612724427},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5Back.jpg","hash":"035b6049e057ba50adfd90809f22163429180cbe","modified":1574612724442},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5BackCover.jpg","hash":"b431cc195b45466bcf50c43cdd12159f0a40edb3","modified":1574612724443},{"_id":"source/_posts/mi5魔改8000mAh大电池/tool.jpg","hash":"6a695f7abd78abad281c3875fe41bab4a9bd4bf1","modified":1574612724453},{"_id":"source/_posts/安装Gitment及常见问题解决/gitmentConfig.png","hash":"948fb10592844e5ff3d3b76be80f3c0922ace936","modified":1574498673250},{"_id":"source/_posts/笔记本-K680e-改侧键开机/button.jpg","hash":"c71c9897a6f1de91d1c2a502d05e5d97c0544e8b","modified":1574612724456},{"_id":"source/_posts/笔记本-K680e-改侧键开机/clickButton.jpg","hash":"f5e1dae458f5e23b86ca3f893878bb176bc24d25","modified":1574612724456},{"_id":"source/_posts/笔记本-K680e-改侧键开机/mouseButton.jpg","hash":"68753fe237f93c6033edd2204396457f0df69641","modified":1574612724461},{"_id":"source/_posts/笔记本-K680e-改侧键开机/safeHoleButton2.jpg","hash":"35a28d8b4672c3713365200ab0f0e70376157b47","modified":1574612724465},{"_id":"source/_posts/笔记本-K680e-改侧键开机/safeHoleButtonInner.jpg","hash":"1e5d42f28cec637c67b65ed2f42b30c77e6cb418","modified":1574612724467},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Feature3.jpg","hash":"94b9df00d295dedd39464aef7e8629987b76dcce","modified":1574498673371},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/capacityExpansion1.png","hash":"1ba2bc3ebdfb8b981820cefc78094c7578c714b3","modified":1574612724471},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/capacityExpansion2.png","hash":"34519b0a319ef9d814767fa7b57f5ade112111c7","modified":1574612724472},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/capacityExpansion3.png","hash":"f631bd6093a3a47d8f1c9603f99eebe78210dda0","modified":1574612724473},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne10.png","hash":"a1a29e39e939925fd77f080e099b7445fd03ed55","modified":1574612724475},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne11.png","hash":"edb7fbb46632eef3b4109e38625ab80ff1fbf07e","modified":1574612724476},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne2.png","hash":"d3fa671e07a3d4840439b31ba7557cafba0310f0","modified":1574612724476},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne3.png","hash":"23c8c8bfdfa9603fcc7a6306e33a505ea31863a4","modified":1574612724477},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskTwo1.png","hash":"2afccdf1fc2fa444d39b8a302ca7b9ad921ac261","modified":1574612724481},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskTwo2.png","hash":"55d307668fc6162d1d39721b822bfeaa4059fcb4","modified":1574612724482},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskTwo3.png","hash":"0a57028ea3cf1ffc3178cb92b6a58f5257ecbda8","modified":1574612724483},{"_id":"source/_posts/DIY笔记本收纳支架/assemble3.jpg","hash":"d930c2948548b0fba9db690e7d66957190e77acf","modified":1574612724422},{"_id":"source/_posts/DIY笔记本收纳支架/assemble4.jpg","hash":"cbb3fc4fbc0278c8a69d6dba9bf8894af1374cda","modified":1574612724423},{"_id":"source/_posts/DIY笔记本收纳支架/drawAcrylicBoard.jpg","hash":"b49667ffa760af54365fb3d1e12882f0b90cf1e1","modified":1574612724428},{"_id":"source/_posts/DIY笔记本收纳支架/notebookStand.jpg","hash":"aed223f34ea1a429cd69d6fa2152e2311c22d66e","modified":1574612724429},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5BackInner1.jpg","hash":"5a29b2f057d79665da54fbb26fe9483db3045f58","modified":1574612724444},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5BackInner2.jpg","hash":"1e78f60b1e097dff023f41db940f39cf79a4e6e4","modified":1574612724446},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5BackNewBattery2.jpg","hash":"4aa48057766d755ee697a7a0dab4f65c085ed367","modified":1574612724449},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5BackNewCoverGlue.jpg","hash":"ac9eb464e7a4ef685e9af72648c1aa4e17b8e9a8","modified":1574612724452},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5BackNewCover.jpg","hash":"5cef43da56be2c6a47e2c130d06dbf249306b5d6","modified":1574612724451},{"_id":"source/_posts/笔记本-K680e-改侧键开机/finishedProduct.jpg","hash":"ca1652e20ede5103b0910bc5af020e10cc059791","modified":1574612724458},{"_id":"source/_posts/笔记本-K680e-改侧键开机/mouse.jpg","hash":"21cecd1cd16f3d2c92dda8ea17e3ec4606c8c4eb","modified":1574612724460},{"_id":"source/_posts/笔记本-K680e-改侧键开机/holdClickButton.jpg","hash":"cebf2a8e6c8805a49b6a5c9516ab1195777e573c","modified":1574612724459},{"_id":"source/_posts/笔记本-K680e-改侧键开机/safeHole.jpg","hash":"d27b306d1ed3c22a3c52738976de6816bdc78d28","modified":1574612724463},{"_id":"source/_posts/笔记本-K680e-改侧键开机/safeHoleButton.jpg","hash":"870a0466de372a449b812d6c8d14c2c7ecaab553","modified":1574612724464},{"_id":"source/_posts/笔记本-K680e-改侧键开机/safeHoleInner.jpg","hash":"91e30c87290fcafd0d9f8529fe89dd359f9a4188","modified":1574612724468},{"_id":"source/_posts/笔记本-K680e-改侧键开机/weldButton.jpg","hash":"a7ac807742633addd4da42714c6ab7b0ad09e9c2","modified":1574612724469},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1574498673594},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1574498673595},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1574498673595},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1574612724604},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1574612724605},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1574612724615},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","hash":"5d52d3b34fceb9d7e11f1beaf7ed380b4249dec4","modified":1574612724616},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","hash":"021898a16279ac2ffe75af4f902fab2a0a39f11a","modified":1574612724621},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1574498673603},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1574612724623},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1574612724624},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1574498673610},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1574612724626},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1574612724626},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1574498673631},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","hash":"f646f2bb75bcd1eb65b2788ac7bf15d4fd243ce9","modified":1574612724627},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1574612724627},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","hash":"66706dfde7d910182c2f1dbadd0e9e917630b8dd","modified":1574498673645},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/15.jpg","hash":"5cf9fc64d5d74ab6ba69bb8bff580fdc22ba32d0","modified":1574498673647},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/16.jpg","hash":"9cac6b80b0cc8959fc8aabfbd1adcab79ebebfc9","modified":1574612724634},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","hash":"a0246a4a560438938489cdd154e35f172b3f31b0","modified":1574498673655},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","hash":"5a46ca4ab4c4ab2101a2af77a31a8878bccc483c","modified":1574498673655},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1574498673641},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","hash":"9d45c4be1d02fd26d3927e4707fa57d0d9de6a0d","modified":1577974255686},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"7a551393b8360731104fdef1af36a6f3638f5855","modified":1574498673605},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","hash":"6979c760beb550b681a06a8f11688f2d1591a70e","modified":1574612724628},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","hash":"2066cdda98ad0035071cd4aa7bd696eb078c0b6d","modified":1574612724634},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","hash":"838e704942de076c60894d14e5f280e2724b6f68","modified":1574498673643},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","hash":"d16e28bd23ea3a63643826dde5eea6b7a9bdda5d","modified":1574498673643},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","hash":"047be4239dd7e0be83243ee6b49a392a61f16b9a","modified":1574498673645},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","hash":"9ed45f95b83626e3d91d6c405eb8bfe6fcb9736a","modified":1574498673644},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/14.jpg","hash":"8aeb816faca2d5eaea4cce9e881d6ff87b8c7cf1","modified":1574498673646},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/17.jpg","hash":"f168ca5b046d10a878a7b0bcfab540e2c4428887","modified":1574498673648},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/19.jpg","hash":"57bc7c804b78b5cceb4eb1f9e51b734b75151b71","modified":1574612724635},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/18.jpg","hash":"ae23fdfaa59bc57b7ed49e90c5d59e4b68e1eea5","modified":1574498673648},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","hash":"16f1d89cdba4dce935ac0f12599e0fcfda543a93","modified":1574612724635},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/20.jpg","hash":"8271c4a327632b566ea62f546c083d08a0528e72","modified":1574498673650},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/21.jpg","hash":"d70b088850c3565e5b5bb9eb8fe4abe688c964cf","modified":1574612724636},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/22.jpg","hash":"bf5b59d193e5ca089a7fff034c222bfa2c4dc41f","modified":1574498673651},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/23.jpg","hash":"ed5ac9f616d3b99af5188a10b1761884c37e93e5","modified":1574612724637},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","hash":"5e879652e032f02961a331b598a50b60ebe80a39","modified":1574612724637},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","hash":"c3c1f36a1b1886037db604f151f335cd4599e970","modified":1574612724638},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","hash":"c63ff64bdd5f6c82da8804c7248fc519d23eaf0b","modified":1574498673654},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","hash":"815c84778b721e3606c2bd7c099c7de7c53251ba","modified":1574498673656},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.png","hash":"ba7cc6b5cea5a32ce904c230d5b97a781b96cbbe","modified":1574612724639},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.png","hash":"9b6e24adbde849edc862a08dbb51a32e1080e640","modified":1574612724640},{"_id":"source/_posts/DIY笔记本收纳支架/combinationOfDrilling.jpg","hash":"d7ff1c7ca61baf0d9501521f9be4e30a952f2d29","modified":1574612724426},{"_id":"source/_posts/DIY笔记本收纳支架/supportForm1.jpg","hash":"4ac1eb1eebb338de7f6c284642cc4ae404a65882","modified":1574612724435},{"_id":"source/_posts/DIY笔记本收纳支架/supportForm2.jpg","hash":"7e71a31d9f9f2b0d420703f5a1b88d89839b950a","modified":1574612724437},{"_id":"source/_posts/mi5魔改8000mAh大电池/battery.jpg","hash":"df4f65bc62ab90f085b3196dc69f19c5fe5b82d6","modified":1574612724441},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","hash":"9d5dd7e092c8eaf6266e2498cff72e6c98790a05","modified":1574612724622},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1574498673605},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1574498673606},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1574498673606},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1574498673607},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1574498673607},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1574498673607},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1574498673608},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1574498673608},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1574498673609},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1574498673609},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.css","hash":"80ae4aa0dba3634dd9bf59586d541d2dd8d8191c","modified":1574612724624},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.js","hash":"c843f0dc497314574c608ca28cc742bb041786d5","modified":1574612724625},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1574498673632},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1574498673634},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1574498673634},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1574498673632},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1574498673632},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1574498673633},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1574498673633},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","hash":"04c6b2782ce4610c429563110f6a20a47432fc4c","modified":1574612724629},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","hash":"1f2ec55fe7825475fde2601573bb622f0bf2acba","modified":1574498673635},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","hash":"c3d5ab183b39a7140941b8375e29498f9d24f343","modified":1574612724630},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","hash":"8d3c8391ff161eec70f66d69e5545a9468cc52ef","modified":1574612724631},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1574498673638},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","hash":"4a08deec1dd5b4f1490e8fc23adfb75a0f88b0c4","modified":1574498673640},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","hash":"62e9586a8cec91a160f147c424a3d1d1aea360f9","modified":1574612724633},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","hash":"4eea5bdb5724ef1ed65790e481eda0d2fb176bf0","modified":1574498673653},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5BackNewBattery.jpg","hash":"f255de949470615db636cdfe4ee31c8018b9fd19","modified":1574612724448},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1574612724606},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1574612724614},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","hash":"82276be41d2001e820020a219b90ad5b026302d1","modified":1574612724616},{"_id":"source/_posts/earphone1/earphone1.png","hash":"678f589c02642031bb61f3618e9bdc7f3c91cc28","modified":1574498673245},{"_id":"source/images/pageHeadImg/earphone1.png","hash":"678f589c02642031bb61f3618e9bdc7f3c91cc28","modified":1574498673578},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1574612724614},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1574612724613},{"_id":"source/_posts/DIY笔记本收纳支架/assemble1.jpg","hash":"2a854509824d7b1ca6e4828d8011406c5669e7b9","modified":1574612724418},{"_id":"source/_posts/DIY笔记本收纳支架/assemble2.jpg","hash":"b7845d7992e24ae28e3b823c4f8e689b734b1577","modified":1574612724421},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1574612724607},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1574612724609},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","hash":"56850c3139cbd72a0eff0c35d8fac32c9c66dd6a","modified":1574612724632},{"_id":"source/_posts/DIY笔记本收纳支架/storageForm.jpg","hash":"1923c0246d74b6268fc180269af91cafde4e9080","modified":1574612724433},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1574612724611},{"_id":"source/images/pageHeadImg/git.png","hash":"8799ce637f4588ce3f2354cdd021d51c1923a715","modified":1574498673580},{"_id":"source/_posts/gitNote/git.png","hash":"221a4d4e14d84d94f1affcda530a2aa4ae61cffc","modified":1574498673248},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1574612724620},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2night.jpg","hash":"874dedc6189127fd7ee2f1e1b97d6b8693a0f7cb","modified":1574498673576},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Feature2.jpg","hash":"9ff180397bb7e1ba777942fd33af17927a05d1a2","modified":1574498673369},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Feature1.jpg","hash":"bc6210647cd718a662cc00b4f56a817c996677ef","modified":1574498673346},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Pkg.jpg","hash":"071c3367373e5918e88f916fd477bdc3c7df7a65","modified":1574498673414},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Trackpoint2.jpg","hash":"0500228a8a6c06961544dc0610f877e7c2c6adb8","modified":1574498673560},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2AssemblyInstructions.jpg","hash":"e6369c59416002852efcaf52498326cc6bf3273a","modified":1574498673286},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Box.jpg","hash":"85505ba5a5eba23a35f1c0ed4a01a9c77be41d16","modified":1574498673305},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Keycap.jpg","hash":"97a47d8fa8a96ca9c7dddc32c4494d1abadfcac4","modified":1574498673388},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Shell4.jpg","hash":"6e4873c4e8b9839484ba8bd067845d477dd01472","modified":1574498673523},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Box2.jpg","hash":"a2815c508d28a96a57f10d716e7e875784708e7f","modified":1574498673322},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Shell2.jpg","hash":"b78b80a415ef76de7c323bfd7e300da0376e26ba","modified":1574498673489},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Shell3.jpg","hash":"fef45c0b191d21d24a658d093097663ca93d4454","modified":1574498673505},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Trackpoint1.jpg","hash":"1a81a314fc29ad9519fd1d69392ba88211c7a1fa","modified":1574498673540},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Accessories1.jpg","hash":"525e6aede80b31b3287ea46de75afdab40e45a34","modified":1574498673267},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2SatelliteAxis2.jpg","hash":"f5c5638ffb712d53dc157ce2e1df51522336a38c","modified":1574498673457},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Shell1.jpg","hash":"ad9e045f59c3ed9670a8d29fda2416a88c87a959","modified":1574498673473},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2SatelliteAxis1.jpg","hash":"adebaf44273fb8d13dfbc26ead18920481efe5d3","modified":1574498673435}],"Category":[{"name":"DIY","_id":"ck8lptih10004bsfo7ac42cnh"},{"name":"软件","_id":"ck8lptiha000bbsfoj51mr78e"},{"name":"画点啥","_id":"ck8lptihg000gbsfoaj6m1ym1"},{"name":"笔记","_id":"ck8lptihn000nbsfoj8wj9chi"},{"name":"Linux","_id":"ck8lptiht000tbsfouhvvgjwl"},{"name":"前端","_id":"ck8lptii00012bsfoknh7eoge"},{"name":"Unity","_id":"ck8lptiif001fbsfof5atvvpg"},{"name":"翻译","_id":"ck8lptiik001jbsfon5r0nss2"}],"Data":[{"_id":"friends","data":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}],"Page":[{"title":"about","date":"2019-05-16T17:59:46.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-05-17 01:59:46\ntype: \"about\"\nlayout: \"about\"\n---\n","updated":"2019-11-24T16:25:24.484Z","path":"about/index.html","comments":1,"_id":"ck8lptigv0000bsfo8652ho7t","content":"","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"categories","date":"2019-05-16T17:58:24.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-05-17 01:58:24\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2019-11-24T16:25:24.484Z","path":"categories/index.html","comments":1,"_id":"ck8lptigz0002bsfo6aki8p1r","content":"","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"friends","date":"2019-05-16T18:00:45.000Z","type":"friends","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2019-05-17 02:00:45\ntype: \"friends\"\nlayout: \"friends\"\n---\n","updated":"2019-11-24T16:25:24.484Z","path":"friends/index.html","comments":1,"_id":"ck8lptih30006bsfoign3mn48","content":"","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"tags","date":"2018-09-20T16:59:42.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-09-21 00:59:42\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2019-11-23T08:44:33.581Z","path":"tags/index.html","comments":1,"_id":"ck8lptih60008bsfo537j2xaw","content":"","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":""}],"Post":[{"title":"DIY笔记本收纳支架","author":"SmalBox","cover":false,"top":false,"date":"2019-06-16T13:59:27.000Z","_content":"# DIY笔记本收纳支架\n\n![notebookStand.jpg](notebookStand.jpg)\n\n## **前言**\n\n最近想用超级本(厚度1.8cm，13.3寸)的雷电接口，做到插一根线即可做移动主机的想法。然后发现，需要一个笔记本支架让本子优雅的立在桌面上。\n\n然而，淘宝一下发现主流的两种，一种铝制的占大多数，一种木质的。价格都在百元左右。嗯～，考虑到重量、便携程度、和 *钱包厚度* ，决定自己搞一个吧。\n\n所以需求就是：\n   1. 重量要轻\n   2. 足够便携\n   3. 成本要低\n   4. 尽量美观\n\n头图已经上成品了，下面就介绍一下具体制作过程。\n\n## **准备工作**\n\n   - 亚克力板2mm厚一块（板面大小：14cm * 12cm 以上）\n   - 螺丝&螺母\n      - 直径3mm，长度12mm 螺丝6颗\n      - 直径3mm，长度40mm 螺丝2颗\n      - 3mm螺母12颗\n   - 电烙铁（头换成刀片，用割刀也可以，主要用来切割板材）\n   - 电钻 直径3mm和4mm的钻头\n   - 热熔胶\n   - 直径4mm的热缩管\n\n## **开始制作**\n\n   1. **在亚克力板上划线 准备切割**\n      - 尺寸是：14cm * 1cm 一条，一共12条。\n      ![drawAcrylicBoard.jpg](drawAcrylicBoard.jpg)\n\n   2. **切割好板材，准备拼装打孔**\n      - 如图将亚克力板切割好，准备合起来组装打孔。\n      ![cuttingAcrylicBoard](cuttingAcrylicBoard.jpg)\n\n   3. **组装、切割底脚、打孔**\n      - 每三片组成一个支架腿\n      - 其中两个腿，中间那片向里缩进1cm\n      - 另两个腿，中间那片向外突出1cm\n      - 对齐后，分别在底脚处、其上2cm处、接头处钻孔，具体如图\n      - 将底角螺丝拧上\n      - 把地脚45度切出一个斜切面，并用热熔胶涂平（做稳定处理）\n      ![combinationOfDrilling](combinationOfDrilling.jpg)\n\n   4. **开始组装**\n      - 拧上接头\n      ![assemble1](assemble1.jpg)\n      ![assemble2](assemble2.jpg)\n      - 剪好热缩管，做防滑垫\n      ![assemble3](assemble3.jpg)\n      ![assemble4](assemble4.jpg)\n\n   5. **两种形态**\n      - 两种模式只需要将接头螺丝拧下，将支架腿以45度插入或180度插入即可切换两种模式\n      - **支架模式**\n         ![supportForm1](supportForm1.jpg)\n         ![supportForm2](supportForm2.jpg)\n      - **收纳模式**\n         ![storageForm](storageForm.jpg)\n\n## **总结**\n   - 在能满足放置超级本的需求下，做到了极致轻便，价格足够便宜。\n   - 外观和手感需要后期打磨，可以用1500、5000、10000目的砂纸打磨，手感会很好。\n   - *（**初版原创设计，如果有兴趣改进，可以邮箱联系我**）*","source":"_posts/DIY笔记本收纳支架.md","raw":"---\ntitle: DIY笔记本收纳支架\nauthor: SmalBox\ncover: false\ntop: false\ndate: 2019-06-16 21:59:27\ncategories: DIY\ntags:\n  - 支架\n  - 笔记本\n---\n# DIY笔记本收纳支架\n\n![notebookStand.jpg](notebookStand.jpg)\n\n## **前言**\n\n最近想用超级本(厚度1.8cm，13.3寸)的雷电接口，做到插一根线即可做移动主机的想法。然后发现，需要一个笔记本支架让本子优雅的立在桌面上。\n\n然而，淘宝一下发现主流的两种，一种铝制的占大多数，一种木质的。价格都在百元左右。嗯～，考虑到重量、便携程度、和 *钱包厚度* ，决定自己搞一个吧。\n\n所以需求就是：\n   1. 重量要轻\n   2. 足够便携\n   3. 成本要低\n   4. 尽量美观\n\n头图已经上成品了，下面就介绍一下具体制作过程。\n\n## **准备工作**\n\n   - 亚克力板2mm厚一块（板面大小：14cm * 12cm 以上）\n   - 螺丝&螺母\n      - 直径3mm，长度12mm 螺丝6颗\n      - 直径3mm，长度40mm 螺丝2颗\n      - 3mm螺母12颗\n   - 电烙铁（头换成刀片，用割刀也可以，主要用来切割板材）\n   - 电钻 直径3mm和4mm的钻头\n   - 热熔胶\n   - 直径4mm的热缩管\n\n## **开始制作**\n\n   1. **在亚克力板上划线 准备切割**\n      - 尺寸是：14cm * 1cm 一条，一共12条。\n      ![drawAcrylicBoard.jpg](drawAcrylicBoard.jpg)\n\n   2. **切割好板材，准备拼装打孔**\n      - 如图将亚克力板切割好，准备合起来组装打孔。\n      ![cuttingAcrylicBoard](cuttingAcrylicBoard.jpg)\n\n   3. **组装、切割底脚、打孔**\n      - 每三片组成一个支架腿\n      - 其中两个腿，中间那片向里缩进1cm\n      - 另两个腿，中间那片向外突出1cm\n      - 对齐后，分别在底脚处、其上2cm处、接头处钻孔，具体如图\n      - 将底角螺丝拧上\n      - 把地脚45度切出一个斜切面，并用热熔胶涂平（做稳定处理）\n      ![combinationOfDrilling](combinationOfDrilling.jpg)\n\n   4. **开始组装**\n      - 拧上接头\n      ![assemble1](assemble1.jpg)\n      ![assemble2](assemble2.jpg)\n      - 剪好热缩管，做防滑垫\n      ![assemble3](assemble3.jpg)\n      ![assemble4](assemble4.jpg)\n\n   5. **两种形态**\n      - 两种模式只需要将接头螺丝拧下，将支架腿以45度插入或180度插入即可切换两种模式\n      - **支架模式**\n         ![supportForm1](supportForm1.jpg)\n         ![supportForm2](supportForm2.jpg)\n      - **收纳模式**\n         ![storageForm](storageForm.jpg)\n\n## **总结**\n   - 在能满足放置超级本的需求下，做到了极致轻便，价格足够便宜。\n   - 外观和手感需要后期打磨，可以用1500、5000、10000目的砂纸打磨，手感会很好。\n   - *（**初版原创设计，如果有兴趣改进，可以邮箱联系我**）*","slug":"DIY笔记本收纳支架","published":1,"updated":"2019-12-10T17:14:53.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptigw0001bsfo5n91x2qi","content":"<h1 id=\"DIY笔记本收纳支架\"><a href=\"#DIY笔记本收纳支架\" class=\"headerlink\" title=\"DIY笔记本收纳支架\"></a>DIY笔记本收纳支架</h1><p><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/notebookStand.jpg\" alt=\"notebookStand.jpg\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>最近想用超级本(厚度1.8cm，13.3寸)的雷电接口，做到插一根线即可做移动主机的想法。然后发现，需要一个笔记本支架让本子优雅的立在桌面上。</p>\n<p>然而，淘宝一下发现主流的两种，一种铝制的占大多数，一种木质的。价格都在百元左右。嗯～，考虑到重量、便携程度、和 <em>钱包厚度</em> ，决定自己搞一个吧。</p>\n<p>所以需求就是：</p>\n<ol>\n<li>重量要轻</li>\n<li>足够便携</li>\n<li>成本要低</li>\n<li>尽量美观</li>\n</ol>\n<p>头图已经上成品了，下面就介绍一下具体制作过程。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a><strong>准备工作</strong></h2><ul>\n<li>亚克力板2mm厚一块（板面大小：14cm * 12cm 以上）</li>\n<li>螺丝&amp;螺母<ul>\n<li>直径3mm，长度12mm 螺丝6颗</li>\n<li>直径3mm，长度40mm 螺丝2颗</li>\n<li>3mm螺母12颗</li>\n</ul>\n</li>\n<li>电烙铁（头换成刀片，用割刀也可以，主要用来切割板材）</li>\n<li>电钻 直径3mm和4mm的钻头</li>\n<li>热熔胶</li>\n<li>直径4mm的热缩管</li>\n</ul>\n<h2 id=\"开始制作\"><a href=\"#开始制作\" class=\"headerlink\" title=\"开始制作\"></a><strong>开始制作</strong></h2><ol>\n<li><p><strong>在亚克力板上划线 准备切割</strong></p>\n<ul>\n<li>尺寸是：14cm * 1cm 一条，一共12条。<br><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/drawAcrylicBoard.jpg\" alt=\"drawAcrylicBoard.jpg\"></li>\n</ul>\n</li>\n<li><p><strong>切割好板材，准备拼装打孔</strong></p>\n<ul>\n<li>如图将亚克力板切割好，准备合起来组装打孔。<br><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/cuttingAcrylicBoard.jpg\" alt=\"cuttingAcrylicBoard\"></li>\n</ul>\n</li>\n<li><p><strong>组装、切割底脚、打孔</strong></p>\n<ul>\n<li>每三片组成一个支架腿</li>\n<li>其中两个腿，中间那片向里缩进1cm</li>\n<li>另两个腿，中间那片向外突出1cm</li>\n<li>对齐后，分别在底脚处、其上2cm处、接头处钻孔，具体如图</li>\n<li>将底角螺丝拧上</li>\n<li>把地脚45度切出一个斜切面，并用热熔胶涂平（做稳定处理）<br><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/combinationOfDrilling.jpg\" alt=\"combinationOfDrilling\"></li>\n</ul>\n</li>\n<li><p><strong>开始组装</strong></p>\n<ul>\n<li>拧上接头<br><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/assemble1.jpg\" alt=\"assemble1\"><br><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/assemble2.jpg\" alt=\"assemble2\"></li>\n<li>剪好热缩管，做防滑垫<br><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/assemble3.jpg\" alt=\"assemble3\"><br><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/assemble4.jpg\" alt=\"assemble4\"></li>\n</ul>\n</li>\n<li><p><strong>两种形态</strong></p>\n<ul>\n<li>两种模式只需要将接头螺丝拧下，将支架腿以45度插入或180度插入即可切换两种模式</li>\n<li><strong>支架模式</strong><br> <img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/supportForm1.jpg\" alt=\"supportForm1\"><br> <img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/supportForm2.jpg\" alt=\"supportForm2\"></li>\n<li><strong>收纳模式</strong><br> <img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/storageForm.jpg\" alt=\"storageForm\"></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><ul>\n<li>在能满足放置超级本的需求下，做到了极致轻便，价格足够便宜。</li>\n<li>外观和手感需要后期打磨，可以用1500、5000、10000目的砂纸打磨，手感会很好。</li>\n<li><em>（<strong>初版原创设计，如果有兴趣改进，可以邮箱联系我</strong>）</em></li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"DIY笔记本收纳支架\"><a href=\"#DIY笔记本收纳支架\" class=\"headerlink\" title=\"DIY笔记本收纳支架\"></a>DIY笔记本收纳支架</h1><p><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/notebookStand.jpg\" alt=\"notebookStand.jpg\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>最近想用超级本(厚度1.8cm，13.3寸)的雷电接口，做到插一根线即可做移动主机的想法。然后发现，需要一个笔记本支架让本子优雅的立在桌面上。</p>\n<p>然而，淘宝一下发现主流的两种，一种铝制的占大多数，一种木质的。价格都在百元左右。嗯～，考虑到重量、便携程度、和 <em>钱包厚度</em> ，决定自己搞一个吧。</p>\n<p>所以需求就是：</p>\n<ol>\n<li>重量要轻</li>\n<li>足够便携</li>\n<li>成本要低</li>\n<li>尽量美观</li>\n</ol>\n<p>头图已经上成品了，下面就介绍一下具体制作过程。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a><strong>准备工作</strong></h2><ul>\n<li>亚克力板2mm厚一块（板面大小：14cm * 12cm 以上）</li>\n<li>螺丝&amp;螺母<ul>\n<li>直径3mm，长度12mm 螺丝6颗</li>\n<li>直径3mm，长度40mm 螺丝2颗</li>\n<li>3mm螺母12颗</li>\n</ul>\n</li>\n<li>电烙铁（头换成刀片，用割刀也可以，主要用来切割板材）</li>\n<li>电钻 直径3mm和4mm的钻头</li>\n<li>热熔胶</li>\n<li>直径4mm的热缩管</li>\n</ul>\n<h2 id=\"开始制作\"><a href=\"#开始制作\" class=\"headerlink\" title=\"开始制作\"></a><strong>开始制作</strong></h2><ol>\n<li><p><strong>在亚克力板上划线 准备切割</strong></p>\n<ul>\n<li>尺寸是：14cm * 1cm 一条，一共12条。<br><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/drawAcrylicBoard.jpg\" alt=\"drawAcrylicBoard.jpg\"></li>\n</ul>\n</li>\n<li><p><strong>切割好板材，准备拼装打孔</strong></p>\n<ul>\n<li>如图将亚克力板切割好，准备合起来组装打孔。<br><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/cuttingAcrylicBoard.jpg\" alt=\"cuttingAcrylicBoard\"></li>\n</ul>\n</li>\n<li><p><strong>组装、切割底脚、打孔</strong></p>\n<ul>\n<li>每三片组成一个支架腿</li>\n<li>其中两个腿，中间那片向里缩进1cm</li>\n<li>另两个腿，中间那片向外突出1cm</li>\n<li>对齐后，分别在底脚处、其上2cm处、接头处钻孔，具体如图</li>\n<li>将底角螺丝拧上</li>\n<li>把地脚45度切出一个斜切面，并用热熔胶涂平（做稳定处理）<br><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/combinationOfDrilling.jpg\" alt=\"combinationOfDrilling\"></li>\n</ul>\n</li>\n<li><p><strong>开始组装</strong></p>\n<ul>\n<li>拧上接头<br><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/assemble1.jpg\" alt=\"assemble1\"><br><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/assemble2.jpg\" alt=\"assemble2\"></li>\n<li>剪好热缩管，做防滑垫<br><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/assemble3.jpg\" alt=\"assemble3\"><br><img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/assemble4.jpg\" alt=\"assemble4\"></li>\n</ul>\n</li>\n<li><p><strong>两种形态</strong></p>\n<ul>\n<li>两种模式只需要将接头螺丝拧下，将支架腿以45度插入或180度插入即可切换两种模式</li>\n<li><strong>支架模式</strong><br> <img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/supportForm1.jpg\" alt=\"supportForm1\"><br> <img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/supportForm2.jpg\" alt=\"supportForm2\"></li>\n<li><strong>收纳模式</strong><br> <img src=\"/2019/06/16/diy-bi-ji-ben-shou-na-zhi-jia/storageForm.jpg\" alt=\"storageForm\"></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><ul>\n<li>在能满足放置超级本的需求下，做到了极致轻便，价格足够便宜。</li>\n<li>外观和手感需要后期打磨，可以用1500、5000、10000目的砂纸打磨，手感会很好。</li>\n<li><em>（<strong>初版原创设计，如果有兴趣改进，可以邮箱联系我</strong>）</em></li>\n</ul>\n"},{"title":"VScode 问题及解决方案","author":"SmalBox","cover":false,"top":false,"date":"2019-12-12T15:18:31.000Z","_content":"# VScode 问题及其解决方案\n\n## **前言**\n\n在使用VScode中遇到的一些问题，在此帖中进行记录，持续更新……\n\n## **Q&A**\n\n### Q1: VScode在Mac下Vim插件长按hjkl键无法持续移动\n   - **A1:**\n     - 在Mac终端下执行以下命令:\n     - ``` bash\n       $ defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false\n       ```\n     - 重启VScode即可\n     - 若要恢复，执行以下命令\n     - ``` bash\n       $ defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool true\n       ```\n\n### Q2: 配置VScode终端字体\n   - **A2:**\n      1. **Linux下配置VScode终端字体：**\n         - 在Ubuntu 18.04.1LTS 下的解决方案（亲测可用），其他版本linux做参考。\n         - ``` bash\n           # 下载安装字体\n           $cd /usr/share/fonts/truetype/\n           $sudo git clone https://github.com/abertsch/Menlo-for-Powerline.git\n           # 刷新字体\n           $sudo fc-cache -f -v\n           ```\n         - 回到  VScode的用户设置.json  中加入以下代码\n         - ``` bash\n           \"terminal.integrated.fontFamily\": \"Menlo for Powerline\"\n           ```\n      2. **Mac下配置VScode终端字体：**\n         - 在Mac 10.13.6下的解决方案（亲测可用），其他版本做参考。\n         - ``` bash\n           # 下载安装字体\n           $cd /Library/Fonts\n           $sudo git clone https://github.com/abertsch/Menlo-for-Powerline.git\n           ```\n         - 在vscode中设置字体：\n         - ``` bash\n           \"terminal.integrated.fontFamily\": \"Menlo for Powerline\"\n           ```\n      3. **Windows下配置VScode终端字体：**\n         - win10 系统下测试有效。\n         - 先[下载字体](https://github.com/abertsch/Menlo-for-Powerline)，下载好的字体点击打开安装\n         - 在vscode中设置字体：\n         - ``` bash\n           \"terminal.integrated.fontFamily\": \"Menlo for Powerline\"\n           ```","source":"_posts/VScode-问题及解决方案.md","raw":"---\ntitle: VScode 问题及解决方案\nauthor: SmalBox\ncover: false\ntop: false\ndate: 2019-12-12 23:18:31\ncategories: 软件\ntags:\n  - VScode\n  - Q&A\n---\n# VScode 问题及其解决方案\n\n## **前言**\n\n在使用VScode中遇到的一些问题，在此帖中进行记录，持续更新……\n\n## **Q&A**\n\n### Q1: VScode在Mac下Vim插件长按hjkl键无法持续移动\n   - **A1:**\n     - 在Mac终端下执行以下命令:\n     - ``` bash\n       $ defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false\n       ```\n     - 重启VScode即可\n     - 若要恢复，执行以下命令\n     - ``` bash\n       $ defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool true\n       ```\n\n### Q2: 配置VScode终端字体\n   - **A2:**\n      1. **Linux下配置VScode终端字体：**\n         - 在Ubuntu 18.04.1LTS 下的解决方案（亲测可用），其他版本linux做参考。\n         - ``` bash\n           # 下载安装字体\n           $cd /usr/share/fonts/truetype/\n           $sudo git clone https://github.com/abertsch/Menlo-for-Powerline.git\n           # 刷新字体\n           $sudo fc-cache -f -v\n           ```\n         - 回到  VScode的用户设置.json  中加入以下代码\n         - ``` bash\n           \"terminal.integrated.fontFamily\": \"Menlo for Powerline\"\n           ```\n      2. **Mac下配置VScode终端字体：**\n         - 在Mac 10.13.6下的解决方案（亲测可用），其他版本做参考。\n         - ``` bash\n           # 下载安装字体\n           $cd /Library/Fonts\n           $sudo git clone https://github.com/abertsch/Menlo-for-Powerline.git\n           ```\n         - 在vscode中设置字体：\n         - ``` bash\n           \"terminal.integrated.fontFamily\": \"Menlo for Powerline\"\n           ```\n      3. **Windows下配置VScode终端字体：**\n         - win10 系统下测试有效。\n         - 先[下载字体](https://github.com/abertsch/Menlo-for-Powerline)，下载好的字体点击打开安装\n         - 在vscode中设置字体：\n         - ``` bash\n           \"terminal.integrated.fontFamily\": \"Menlo for Powerline\"\n           ```","slug":"VScode-问题及解决方案","published":1,"updated":"2020-01-02T14:10:55.685Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptih00003bsfooj0p53kc","content":"<h1 id=\"VScode-问题及其解决方案\"><a href=\"#VScode-问题及其解决方案\" class=\"headerlink\" title=\"VScode 问题及其解决方案\"></a>VScode 问题及其解决方案</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>在使用VScode中遇到的一些问题，在此帖中进行记录，持续更新……</p>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a><strong>Q&amp;A</strong></h2><h3 id=\"Q1-VScode在Mac下Vim插件长按hjkl键无法持续移动\"><a href=\"#Q1-VScode在Mac下Vim插件长按hjkl键无法持续移动\" class=\"headerlink\" title=\"Q1: VScode在Mac下Vim插件长按hjkl键无法持续移动\"></a>Q1: VScode在Mac下Vim插件长按hjkl键无法持续移动</h3><ul>\n<li><strong>A1:</strong><ul>\n<li>在Mac终端下执行以下命令:</li>\n<li><pre class=\" language-bash\"><code class=\"language-bash\">$ defaults <span class=\"token function\">write</span> com.microsoft.VSCode ApplePressAndHoldEnabled -bool <span class=\"token boolean\">false</span>\n</code></pre>\n</li>\n<li>重启VScode即可</li>\n<li>若要恢复，执行以下命令</li>\n<li><pre class=\" language-bash\"><code class=\"language-bash\">$ defaults <span class=\"token function\">write</span> com.microsoft.VSCode ApplePressAndHoldEnabled -bool <span class=\"token boolean\">true</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Q2-配置VScode终端字体\"><a href=\"#Q2-配置VScode终端字体\" class=\"headerlink\" title=\"Q2: 配置VScode终端字体\"></a>Q2: 配置VScode终端字体</h3><ul>\n<li><strong>A2:</strong><ol>\n<li><strong>Linux下配置VScode终端字体：</strong><ul>\n<li>在Ubuntu 18.04.1LTS 下的解决方案（亲测可用），其他版本linux做参考。</li>\n<li><pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 下载安装字体</span>\n<span class=\"token variable\">$cd</span> /usr/share/fonts/truetype/\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">git</span> clone https://github.com/abertsch/Menlo-for-Powerline.git\n<span class=\"token comment\" spellcheck=\"true\"># 刷新字体</span>\n<span class=\"token variable\">$sudo</span> fc-cache -f -v\n</code></pre>\n</li>\n<li>回到  VScode的用户设置.json  中加入以下代码</li>\n<li><pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token string\">\"terminal.integrated.fontFamily\"</span><span class=\"token keyword\">:</span> <span class=\"token string\">\"Menlo for Powerline\"</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Mac下配置VScode终端字体：</strong><ul>\n<li>在Mac 10.13.6下的解决方案（亲测可用），其他版本做参考。</li>\n<li><pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 下载安装字体</span>\n<span class=\"token variable\">$cd</span> /Library/Fonts\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">git</span> clone https://github.com/abertsch/Menlo-for-Powerline.git\n</code></pre>\n</li>\n<li>在vscode中设置字体：</li>\n<li><pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token string\">\"terminal.integrated.fontFamily\"</span><span class=\"token keyword\">:</span> <span class=\"token string\">\"Menlo for Powerline\"</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Windows下配置VScode终端字体：</strong><ul>\n<li>win10 系统下测试有效。</li>\n<li>先<a href=\"https://github.com/abertsch/Menlo-for-Powerline\" target=\"_blank\" rel=\"noopener\">下载字体</a>，下载好的字体点击打开安装</li>\n<li>在vscode中设置字体：</li>\n<li><pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token string\">\"terminal.integrated.fontFamily\"</span><span class=\"token keyword\">:</span> <span class=\"token string\">\"Menlo for Powerline\"</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"VScode-问题及其解决方案\"><a href=\"#VScode-问题及其解决方案\" class=\"headerlink\" title=\"VScode 问题及其解决方案\"></a>VScode 问题及其解决方案</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>在使用VScode中遇到的一些问题，在此帖中进行记录，持续更新……</p>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a><strong>Q&amp;A</strong></h2><h3 id=\"Q1-VScode在Mac下Vim插件长按hjkl键无法持续移动\"><a href=\"#Q1-VScode在Mac下Vim插件长按hjkl键无法持续移动\" class=\"headerlink\" title=\"Q1: VScode在Mac下Vim插件长按hjkl键无法持续移动\"></a>Q1: VScode在Mac下Vim插件长按hjkl键无法持续移动</h3><ul>\n<li><strong>A1:</strong><ul>\n<li>在Mac终端下执行以下命令:</li>\n<li><pre><code class=\"bash\">$ defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false\n</code></pre>\n</li>\n<li>重启VScode即可</li>\n<li>若要恢复，执行以下命令</li>\n<li><pre><code class=\"bash\">$ defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool true\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Q2-配置VScode终端字体\"><a href=\"#Q2-配置VScode终端字体\" class=\"headerlink\" title=\"Q2: 配置VScode终端字体\"></a>Q2: 配置VScode终端字体</h3><ul>\n<li><strong>A2:</strong><ol>\n<li><strong>Linux下配置VScode终端字体：</strong><ul>\n<li>在Ubuntu 18.04.1LTS 下的解决方案（亲测可用），其他版本linux做参考。</li>\n<li><pre><code class=\"bash\"># 下载安装字体\n$cd /usr/share/fonts/truetype/\n$sudo git clone https://github.com/abertsch/Menlo-for-Powerline.git\n# 刷新字体\n$sudo fc-cache -f -v\n</code></pre>\n</li>\n<li>回到  VScode的用户设置.json  中加入以下代码</li>\n<li><pre><code class=\"bash\">&quot;terminal.integrated.fontFamily&quot;: &quot;Menlo for Powerline&quot;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Mac下配置VScode终端字体：</strong><ul>\n<li>在Mac 10.13.6下的解决方案（亲测可用），其他版本做参考。</li>\n<li><pre><code class=\"bash\"># 下载安装字体\n$cd /Library/Fonts\n$sudo git clone https://github.com/abertsch/Menlo-for-Powerline.git\n</code></pre>\n</li>\n<li>在vscode中设置字体：</li>\n<li><pre><code class=\"bash\">&quot;terminal.integrated.fontFamily&quot;: &quot;Menlo for Powerline&quot;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Windows下配置VScode终端字体：</strong><ul>\n<li>win10 系统下测试有效。</li>\n<li>先<a href=\"https://github.com/abertsch/Menlo-for-Powerline\" target=\"_blank\" rel=\"noopener\">下载字体</a>，下载好的字体点击打开安装</li>\n<li>在vscode中设置字体：</li>\n<li><pre><code class=\"bash\">&quot;terminal.integrated.fontFamily&quot;: &quot;Menlo for Powerline&quot;\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2019-11-23T08:44:33.248Z","updated":"2019-11-23T08:44:33.248Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptih30007bsfofxhejdh8","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo new <span class=\"token string\">\"My New Post\"</span>\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"earphone1","date":"2018-09-25T18:09:33.000Z","author":"SmalBox","img":"/images/pageHeadImg/earphone1.png","_content":"# earphone1\n\n![earphone1](earphone1.png)\n","source":"_posts/earphone1.md","raw":"---\ntitle: earphone1\ndate: 2018-09-26 02:09:33\nauthor: SmalBox\ncategories: 画点啥\nimg: /images/pageHeadImg/earphone1.png\ntags:\n  - hand painted\n  - earphone\n---\n# earphone1\n\n![earphone1](earphone1.png)\n","slug":"earphone1","published":1,"updated":"2019-11-24T16:25:24.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptih70009bsfo8q3ro8sp","content":"<h1 id=\"earphone1\"><a href=\"#earphone1\" class=\"headerlink\" title=\"earphone1\"></a>earphone1</h1><p><img src=\"/2018/09/26/earphone1/earphone1.png\" alt=\"earphone1\"></p>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"earphone1\"><a href=\"#earphone1\" class=\"headerlink\" title=\"earphone1\"></a>earphone1</h1><p><img src=\"/2018/09/26/earphone1/earphone1.png\" alt=\"earphone1\"></p>\n"},{"title":"gitNote","date":"2018-09-22T16:42:34.000Z","author":"SmalBox","img":"/images/pageHeadImg/git.png","_content":"# Git command note\n\n## Install: initialize user name and user email.\n\n``` bash\n$ git config --global user.name \"Your Name\"\n$ git config --global user.email \"email@example.com\"\n```\n\n## 1.Create git\n\n``` bash\n$ mkdir learnBox #创建目录作为仓库\n$ cd learnBox #进入目录\n$ pwd #显示仓库位置\n$ git init #创建仓库（仓库根目录下有.git的隐藏目录，用ls -ah可以看到）\n```\n\n## 2.Add & Commit file\n\n``` bash\n$ git add readme.txt #添加文件到仓库\n$ git commit -m \"add readme.txt\" #提交以上添加，填写修改信息\n```\n\n## 3.Check the status & difference\n\n``` bash\n$ git status #查看仓库状态\n$ git diff readme.txt #查看具体修改了哪些\n$ git log #从近到远查看提交日志\n$ git log --pretty=oneline #简化日志每个只显示一行\n```\n\n## 4.Reset\n\n``` bash\n$ git reset --hard HEAD^ #退回上一个版本 '^'退回一个 '~100'退100个\n$ git reset --hard <version id> #版本号写前几位即可，git自己会找\n$ git reflog #记录执行过的命令\n```\n\n## 5.Stage(index)\n\n``` bash\n使用 \"git add\" 命令将工作区文件添加到stage暂存区。\n使用 \"git commit\" 命令将stage暂存区中文件添加到分支。\n```\n## 6.Manage modify\n\n``` bash\n先add添加到stage，后commit到分支。\n$ git diff HEAD -- readme.txt #查看工作区和版本库中最新版本区别\n```\n\n## 7.Undo changes\n\n``` bash\n1)无add无commit：\n\t$ git checkout -- <file>\n2)有add无commit：\n\t$ git reset HEAD <file>\n\t$ git checkout -- <file>\n3)有add有commit：\n\t$ git reset --hard HEAD^#退回上一版本\n```\n\t\n## 8.Remove file\n\n``` bash\n$ rm <file> #删除工作区的文件\n$ git rm <file> #如果真的想删，删除版本库里的文件\n$ git checkout -- <file> #误删了工作区文件，用版本库恢复删除文件\n```\n\n\n## Remote repository\n\n``` bash\n$ ssh-keygen -t rsa -C \"email@example.com\" #创建ssh协议公钥和私钥\n#进入到GitHub中添加ssh key 即可远程推送\n```\n\n## 9.Add and remove remote repository\n\n``` bash\n$ git remote add origin https://github.com/SmalBox/learngit.git\n$ git remote add origin git@github.com:SmalBox/learngit.git\n#GitHub上的提示添加远程库.这两种都可以\n$ git remote rm <remote name> #移除远程库\n$ git push -u origin master #将本地库推送到GitHub\n```\n\n## 10.Clone from remote repository\n\n``` bash\n$ git clone git@github.com:SmalBox/repositoryName.git #从远程克隆到本地\n```\n\n## Manage branch\n\n## 11.Create & Combine branch\n\n``` bash\n$ git branch #查看分支结构\n$ git branch <name> #创建分支\n$ git checkout <name> #切换分支\n$ git checkout -b <name> #创建并切换分支\n$ git merge <name> #合并某分支到当前分支\n$ git branch -d <name> #删除某分支\n$ git branch -D <name> #强行删除某分支，例如强行删除未合并的分支\n```\n\n``` bash\n$ git checkout -b dev #创建并切换 到dev分支\n$ git branch #查看 分支\n$ git checkout master #切换 到master分支\n$ git merge dev #把dev分支 合并 到master分支\n$ git branch -d dev #删除 dev分支\n```\n\n## 12.Conflict fixed\n\n``` bash\n#当两个分支修改同一个文件，合并时产生冲突。\n#在当前分支修改冲突文件，再add和commit之后重新合并。\n$ git log --graph --pretty=oneline --addrev-commit #查看分之合并图\n```\n\t\n## 13.Branch strategy\n\n``` bash\n$ git merge --no-ff -m \"merge with no-ff\" dev #不使用Fast\nforward合并，创建一个commit记录。\n```\n\n## 14.Bug branch(Stach)\n\n``` bash\n$ git stash #把暂时没完成的分支储藏起来\n$ git stash list #列出存储的各个版本\n$ git stash pop #恢复储藏，并删除stach记录\n$ git stash apply stash@{0} #恢复到stash0\n$ git stash drop #删除stash内容\n```\n\n## 15.Collaboration\n\n``` bash\n$ git remote #查看远程仓库信息(name)\n$ git remote -v #查看远程仓库详细信息\n$ git push <git name> <branch name> #推送分支 例如：git push origin master\n$ git checkout -b dev origin/dev #创建本地dev链接远程仓库中的dev\n$ git pull #推送失败，远程分支新，用此试图合并\n$ git git  branch --set-upstream-to=<remote name>/<branch name> #无跟踪信息时，说明本地分支与远程分支没有建立关系，用此建立\n```\n\n## 16.Tag\n\n``` bash\n$ git tag <name> #给当前分支打标签,标签打在最新提交的commit上\n$ git tag #查看当前分支的标签\n$ git tag <name> <commit id> #给某一个版本的commit打标签\n$ git tag -a <tag name> -m \"description\" <commit id> #带有说明的标签\n$ git tag -s <tag name> -m \"description\" <commit id> #私钥签名一个标签\n$ git show <tag name> #查看标签信息\n$ git tag -d <tag name> #删除标签\n$ git push <remote name> <tag name> #推送某一标签到远程仓库\n$ git push <remote name> --tags #推送全部标签到远程\n#删除远程标签，要先删除本地标签，再推送远程。格式如下：\n$ git tag -d <tag name> #删除本地标签\n$ git push <remote name> :refs/tags/<tag name> #推送远程\n```\n\n## 17.Alias\n\n``` bash\n$ git config --global alias.co checkout #设置全局简写\n$ git config --global alias.st status \n$ git config --global alias.ci commit\n$ git config --global alias.br branch\n$ git config --global alias.lol \"log --pretty=oneline\"\n$ git config --global alias.glol \"log --graph --pretty=oneline --abbrev-commit\"\n#全局的配置文件在用户目录下名为：.gitconfig中记录。每个仓库的配置文件在仓库下的.git文件下config文件中记录\n```\n\n## 18.Setting up a proxy\n\n``` bash\n# 设置只对github代理\n$ git config --global http.https://github.com.proxy socks5://127.0.0.1:本地代理端口号\n# 取消代理\n$ git config --global --unset http.proxy\n$ git config --global --unset http.https://github.com.proxy\n```\n\n## 19.Git Large File Storage\n\n去 Git Large File Storage [官网](https://git-lfs.github.com/)下载安装\n``` bash\n# 提供Git对大文件存储支持\n# 在每个git版本库下执行一下命令以提供大文件存储功能\n$ git lfs install\n$ git lfs track \"*.psd\"\n$ git add .gitattributes\n$ git commit -m \"添加对psd文件的支持\"\n```\n在git版本库的目录下修改 .gitattributes 即可快速添加支持文件\n例如在 .gitattributes 添加如下配置文件:\n\n``` bash\n# Image formats:\n*.tga filter=lfs diff=lfs merge=lfs -text\n*.png filter=lfs diff=lfs merge=lfs -text\n*.tif filter=lfs diff=lfs merge=lfs -text\n*.jpg filter=lfs diff=lfs merge=lfs -text\n*.gif filter=lfs diff=lfs merge=lfs -text\n*.psd filter=lfs diff=lfs merge=lfs -text\n\n# Audio formats:\n*.mp3 filter=lfs diff=lfs merge=lfs -text\n*.wav filter=lfs diff=lfs merge=lfs -text\n*.aiff filter=lfs diff=lfs merge=lfs -text\n\n# 3D model formats:\n*.fbx filter=lfs diff=lfs merge=lfs -text\n*.obj filter=lfs diff=lfs merge=lfs -text\n\n# Unity formats:\n*.sbsar filter=lfs diff=lfs merge=lfs -text\n*.unity filter=lfs diff=lfs merge=lfs -text\n\n# Other binary formats\n*.dll filter=lfs diff=lfs merge=lfs -text\n```\n\n## Q&A\n\n   - **Q1: Git push到远程时，遇到 “fatal: TaskCanceledException encountered” 错误**\n      - **A1:**\n\t     - 在终端输入：\n\t\t   ``` bash\n\t\t   git config –global credential.helper store\n\t\t   ```\n\t\t - 在.gitconfig文件中，可以看到多了一项：\n\t\t   ``` bash\n\t\t   [credential]\n\t\t   helper = store\n\t\t   ```\n   - **Q2: windows Git Bash 输入python无响应**\n      - **A2:**\n\t     - 安装Git Bash 的时候有提示，MinTTY不支持交互操作，如Python和Node, 用winpty + program就可以运行了\n\t\t - 有三种方法：\n\t\t    1. 利用winpty接口\n\t\t\t   ``` bash\n\t\t\t   winpty python\n\t\t\t   ```\n\t\t\t2. 显示使用python -i\n\t\t\t   ``` bash\n\t\t\t   python -i\n\t\t\t   ```\n\t\t\t3. 用git的alias按键映射，映射上述两方案\n\t\t\t   ``` bash\n\t\t\t   # 在 /etc/bash.bashrc 这个文件中加入\n\t\t\t   alias python='winpty python'\n\t\t\t   #然后重启bash，因为它每次重启时会读取bashrc文件来进行初始配置。\n\t\t\t   ```","source":"_posts/gitNote.md","raw":"---\ntitle: gitNote\ndate: 2018-09-23 00:42:34\nauthor: SmalBox\ncategories: 笔记\nimg: /images/pageHeadImg/git.png\ntags:\n  - git\n  - note\n---\n# Git command note\n\n## Install: initialize user name and user email.\n\n``` bash\n$ git config --global user.name \"Your Name\"\n$ git config --global user.email \"email@example.com\"\n```\n\n## 1.Create git\n\n``` bash\n$ mkdir learnBox #创建目录作为仓库\n$ cd learnBox #进入目录\n$ pwd #显示仓库位置\n$ git init #创建仓库（仓库根目录下有.git的隐藏目录，用ls -ah可以看到）\n```\n\n## 2.Add & Commit file\n\n``` bash\n$ git add readme.txt #添加文件到仓库\n$ git commit -m \"add readme.txt\" #提交以上添加，填写修改信息\n```\n\n## 3.Check the status & difference\n\n``` bash\n$ git status #查看仓库状态\n$ git diff readme.txt #查看具体修改了哪些\n$ git log #从近到远查看提交日志\n$ git log --pretty=oneline #简化日志每个只显示一行\n```\n\n## 4.Reset\n\n``` bash\n$ git reset --hard HEAD^ #退回上一个版本 '^'退回一个 '~100'退100个\n$ git reset --hard <version id> #版本号写前几位即可，git自己会找\n$ git reflog #记录执行过的命令\n```\n\n## 5.Stage(index)\n\n``` bash\n使用 \"git add\" 命令将工作区文件添加到stage暂存区。\n使用 \"git commit\" 命令将stage暂存区中文件添加到分支。\n```\n## 6.Manage modify\n\n``` bash\n先add添加到stage，后commit到分支。\n$ git diff HEAD -- readme.txt #查看工作区和版本库中最新版本区别\n```\n\n## 7.Undo changes\n\n``` bash\n1)无add无commit：\n\t$ git checkout -- <file>\n2)有add无commit：\n\t$ git reset HEAD <file>\n\t$ git checkout -- <file>\n3)有add有commit：\n\t$ git reset --hard HEAD^#退回上一版本\n```\n\t\n## 8.Remove file\n\n``` bash\n$ rm <file> #删除工作区的文件\n$ git rm <file> #如果真的想删，删除版本库里的文件\n$ git checkout -- <file> #误删了工作区文件，用版本库恢复删除文件\n```\n\n\n## Remote repository\n\n``` bash\n$ ssh-keygen -t rsa -C \"email@example.com\" #创建ssh协议公钥和私钥\n#进入到GitHub中添加ssh key 即可远程推送\n```\n\n## 9.Add and remove remote repository\n\n``` bash\n$ git remote add origin https://github.com/SmalBox/learngit.git\n$ git remote add origin git@github.com:SmalBox/learngit.git\n#GitHub上的提示添加远程库.这两种都可以\n$ git remote rm <remote name> #移除远程库\n$ git push -u origin master #将本地库推送到GitHub\n```\n\n## 10.Clone from remote repository\n\n``` bash\n$ git clone git@github.com:SmalBox/repositoryName.git #从远程克隆到本地\n```\n\n## Manage branch\n\n## 11.Create & Combine branch\n\n``` bash\n$ git branch #查看分支结构\n$ git branch <name> #创建分支\n$ git checkout <name> #切换分支\n$ git checkout -b <name> #创建并切换分支\n$ git merge <name> #合并某分支到当前分支\n$ git branch -d <name> #删除某分支\n$ git branch -D <name> #强行删除某分支，例如强行删除未合并的分支\n```\n\n``` bash\n$ git checkout -b dev #创建并切换 到dev分支\n$ git branch #查看 分支\n$ git checkout master #切换 到master分支\n$ git merge dev #把dev分支 合并 到master分支\n$ git branch -d dev #删除 dev分支\n```\n\n## 12.Conflict fixed\n\n``` bash\n#当两个分支修改同一个文件，合并时产生冲突。\n#在当前分支修改冲突文件，再add和commit之后重新合并。\n$ git log --graph --pretty=oneline --addrev-commit #查看分之合并图\n```\n\t\n## 13.Branch strategy\n\n``` bash\n$ git merge --no-ff -m \"merge with no-ff\" dev #不使用Fast\nforward合并，创建一个commit记录。\n```\n\n## 14.Bug branch(Stach)\n\n``` bash\n$ git stash #把暂时没完成的分支储藏起来\n$ git stash list #列出存储的各个版本\n$ git stash pop #恢复储藏，并删除stach记录\n$ git stash apply stash@{0} #恢复到stash0\n$ git stash drop #删除stash内容\n```\n\n## 15.Collaboration\n\n``` bash\n$ git remote #查看远程仓库信息(name)\n$ git remote -v #查看远程仓库详细信息\n$ git push <git name> <branch name> #推送分支 例如：git push origin master\n$ git checkout -b dev origin/dev #创建本地dev链接远程仓库中的dev\n$ git pull #推送失败，远程分支新，用此试图合并\n$ git git  branch --set-upstream-to=<remote name>/<branch name> #无跟踪信息时，说明本地分支与远程分支没有建立关系，用此建立\n```\n\n## 16.Tag\n\n``` bash\n$ git tag <name> #给当前分支打标签,标签打在最新提交的commit上\n$ git tag #查看当前分支的标签\n$ git tag <name> <commit id> #给某一个版本的commit打标签\n$ git tag -a <tag name> -m \"description\" <commit id> #带有说明的标签\n$ git tag -s <tag name> -m \"description\" <commit id> #私钥签名一个标签\n$ git show <tag name> #查看标签信息\n$ git tag -d <tag name> #删除标签\n$ git push <remote name> <tag name> #推送某一标签到远程仓库\n$ git push <remote name> --tags #推送全部标签到远程\n#删除远程标签，要先删除本地标签，再推送远程。格式如下：\n$ git tag -d <tag name> #删除本地标签\n$ git push <remote name> :refs/tags/<tag name> #推送远程\n```\n\n## 17.Alias\n\n``` bash\n$ git config --global alias.co checkout #设置全局简写\n$ git config --global alias.st status \n$ git config --global alias.ci commit\n$ git config --global alias.br branch\n$ git config --global alias.lol \"log --pretty=oneline\"\n$ git config --global alias.glol \"log --graph --pretty=oneline --abbrev-commit\"\n#全局的配置文件在用户目录下名为：.gitconfig中记录。每个仓库的配置文件在仓库下的.git文件下config文件中记录\n```\n\n## 18.Setting up a proxy\n\n``` bash\n# 设置只对github代理\n$ git config --global http.https://github.com.proxy socks5://127.0.0.1:本地代理端口号\n# 取消代理\n$ git config --global --unset http.proxy\n$ git config --global --unset http.https://github.com.proxy\n```\n\n## 19.Git Large File Storage\n\n去 Git Large File Storage [官网](https://git-lfs.github.com/)下载安装\n``` bash\n# 提供Git对大文件存储支持\n# 在每个git版本库下执行一下命令以提供大文件存储功能\n$ git lfs install\n$ git lfs track \"*.psd\"\n$ git add .gitattributes\n$ git commit -m \"添加对psd文件的支持\"\n```\n在git版本库的目录下修改 .gitattributes 即可快速添加支持文件\n例如在 .gitattributes 添加如下配置文件:\n\n``` bash\n# Image formats:\n*.tga filter=lfs diff=lfs merge=lfs -text\n*.png filter=lfs diff=lfs merge=lfs -text\n*.tif filter=lfs diff=lfs merge=lfs -text\n*.jpg filter=lfs diff=lfs merge=lfs -text\n*.gif filter=lfs diff=lfs merge=lfs -text\n*.psd filter=lfs diff=lfs merge=lfs -text\n\n# Audio formats:\n*.mp3 filter=lfs diff=lfs merge=lfs -text\n*.wav filter=lfs diff=lfs merge=lfs -text\n*.aiff filter=lfs diff=lfs merge=lfs -text\n\n# 3D model formats:\n*.fbx filter=lfs diff=lfs merge=lfs -text\n*.obj filter=lfs diff=lfs merge=lfs -text\n\n# Unity formats:\n*.sbsar filter=lfs diff=lfs merge=lfs -text\n*.unity filter=lfs diff=lfs merge=lfs -text\n\n# Other binary formats\n*.dll filter=lfs diff=lfs merge=lfs -text\n```\n\n## Q&A\n\n   - **Q1: Git push到远程时，遇到 “fatal: TaskCanceledException encountered” 错误**\n      - **A1:**\n\t     - 在终端输入：\n\t\t   ``` bash\n\t\t   git config –global credential.helper store\n\t\t   ```\n\t\t - 在.gitconfig文件中，可以看到多了一项：\n\t\t   ``` bash\n\t\t   [credential]\n\t\t   helper = store\n\t\t   ```\n   - **Q2: windows Git Bash 输入python无响应**\n      - **A2:**\n\t     - 安装Git Bash 的时候有提示，MinTTY不支持交互操作，如Python和Node, 用winpty + program就可以运行了\n\t\t - 有三种方法：\n\t\t    1. 利用winpty接口\n\t\t\t   ``` bash\n\t\t\t   winpty python\n\t\t\t   ```\n\t\t\t2. 显示使用python -i\n\t\t\t   ``` bash\n\t\t\t   python -i\n\t\t\t   ```\n\t\t\t3. 用git的alias按键映射，映射上述两方案\n\t\t\t   ``` bash\n\t\t\t   # 在 /etc/bash.bashrc 这个文件中加入\n\t\t\t   alias python='winpty python'\n\t\t\t   #然后重启bash，因为它每次重启时会读取bashrc文件来进行初始配置。\n\t\t\t   ```","slug":"gitNote","published":1,"updated":"2020-01-03T10:42:33.494Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptiha000absfo5fmkh6t0","content":"<h1 id=\"Git-command-note\"><a href=\"#Git-command-note\" class=\"headerlink\" title=\"Git command note\"></a>Git command note</h1><h2 id=\"Install-initialize-user-name-and-user-email\"><a href=\"#Install-initialize-user-name-and-user-email\" class=\"headerlink\" title=\"Install: initialize user name and user email.\"></a>Install: initialize user name and user email.</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> config --global user.name <span class=\"token string\">\"Your Name\"</span>\n$ <span class=\"token function\">git</span> config --global user.email <span class=\"token string\">\"email@example.com\"</span>\n</code></pre>\n<h2 id=\"1-Create-git\"><a href=\"#1-Create-git\" class=\"headerlink\" title=\"1.Create git\"></a>1.Create git</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">mkdir</span> learnBox <span class=\"token comment\" spellcheck=\"true\">#创建目录作为仓库</span>\n$ <span class=\"token function\">cd</span> learnBox <span class=\"token comment\" spellcheck=\"true\">#进入目录</span>\n$ <span class=\"token function\">pwd</span> <span class=\"token comment\" spellcheck=\"true\">#显示仓库位置</span>\n$ <span class=\"token function\">git</span> init <span class=\"token comment\" spellcheck=\"true\">#创建仓库（仓库根目录下有.git的隐藏目录，用ls -ah可以看到）</span>\n</code></pre>\n<h2 id=\"2-Add-amp-Commit-file\"><a href=\"#2-Add-amp-Commit-file\" class=\"headerlink\" title=\"2.Add &amp; Commit file\"></a>2.Add &amp; Commit file</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> add readme.txt <span class=\"token comment\" spellcheck=\"true\">#添加文件到仓库</span>\n$ <span class=\"token function\">git</span> commit -m <span class=\"token string\">\"add readme.txt\"</span> <span class=\"token comment\" spellcheck=\"true\">#提交以上添加，填写修改信息</span>\n</code></pre>\n<h2 id=\"3-Check-the-status-amp-difference\"><a href=\"#3-Check-the-status-amp-difference\" class=\"headerlink\" title=\"3.Check the status &amp; difference\"></a>3.Check the status &amp; difference</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> status <span class=\"token comment\" spellcheck=\"true\">#查看仓库状态</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">diff</span> readme.txt <span class=\"token comment\" spellcheck=\"true\">#查看具体修改了哪些</span>\n$ <span class=\"token function\">git</span> log <span class=\"token comment\" spellcheck=\"true\">#从近到远查看提交日志</span>\n$ <span class=\"token function\">git</span> log --pretty<span class=\"token operator\">=</span>oneline <span class=\"token comment\" spellcheck=\"true\">#简化日志每个只显示一行</span>\n</code></pre>\n<h2 id=\"4-Reset\"><a href=\"#4-Reset\" class=\"headerlink\" title=\"4.Reset\"></a>4.Reset</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> reset --hard HEAD^ <span class=\"token comment\" spellcheck=\"true\">#退回上一个版本 '^'退回一个 '~100'退100个</span>\n$ <span class=\"token function\">git</span> reset --hard <span class=\"token operator\">&lt;</span>version id<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#版本号写前几位即可，git自己会找</span>\n$ <span class=\"token function\">git</span> reflog <span class=\"token comment\" spellcheck=\"true\">#记录执行过的命令</span>\n</code></pre>\n<h2 id=\"5-Stage-index\"><a href=\"#5-Stage-index\" class=\"headerlink\" title=\"5.Stage(index)\"></a>5.Stage(index)</h2><pre class=\" language-bash\"><code class=\"language-bash\">使用 <span class=\"token string\">\"git add\"</span> 命令将工作区文件添加到stage暂存区。\n使用 <span class=\"token string\">\"git commit\"</span> 命令将stage暂存区中文件添加到分支。\n</code></pre>\n<h2 id=\"6-Manage-modify\"><a href=\"#6-Manage-modify\" class=\"headerlink\" title=\"6.Manage modify\"></a>6.Manage modify</h2><pre class=\" language-bash\"><code class=\"language-bash\">先add添加到stage，后commit到分支。\n$ <span class=\"token function\">git</span> <span class=\"token function\">diff</span> HEAD -- readme.txt <span class=\"token comment\" spellcheck=\"true\">#查看工作区和版本库中最新版本区别</span>\n</code></pre>\n<h2 id=\"7-Undo-changes\"><a href=\"#7-Undo-changes\" class=\"headerlink\" title=\"7.Undo changes\"></a>7.Undo changes</h2><pre class=\" language-bash\"><code class=\"language-bash\">1<span class=\"token punctuation\">)</span>无add无commit：\n    $ <span class=\"token function\">git</span> checkout -- <span class=\"token operator\">&lt;</span>file<span class=\"token operator\">></span>\n2<span class=\"token punctuation\">)</span>有add无commit：\n    $ <span class=\"token function\">git</span> reset HEAD <span class=\"token operator\">&lt;</span>file<span class=\"token operator\">></span>\n    $ <span class=\"token function\">git</span> checkout -- <span class=\"token operator\">&lt;</span>file<span class=\"token operator\">></span>\n3<span class=\"token punctuation\">)</span>有add有commit：\n    $ <span class=\"token function\">git</span> reset --hard HEAD^<span class=\"token comment\" spellcheck=\"true\">#退回上一版本</span>\n</code></pre>\n<h2 id=\"8-Remove-file\"><a href=\"#8-Remove-file\" class=\"headerlink\" title=\"8.Remove file\"></a>8.Remove file</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">rm</span> <span class=\"token operator\">&lt;</span>file<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#删除工作区的文件</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">rm</span> <span class=\"token operator\">&lt;</span>file<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#如果真的想删，删除版本库里的文件</span>\n$ <span class=\"token function\">git</span> checkout -- <span class=\"token operator\">&lt;</span>file<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#误删了工作区文件，用版本库恢复删除文件</span>\n</code></pre>\n<h2 id=\"Remote-repository\"><a href=\"#Remote-repository\" class=\"headerlink\" title=\"Remote repository\"></a>Remote repository</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ ssh-keygen -t rsa -C <span class=\"token string\">\"email@example.com\"</span> <span class=\"token comment\" spellcheck=\"true\">#创建ssh协议公钥和私钥</span>\n<span class=\"token comment\" spellcheck=\"true\">#进入到GitHub中添加ssh key 即可远程推送</span>\n</code></pre>\n<h2 id=\"9-Add-and-remove-remote-repository\"><a href=\"#9-Add-and-remove-remote-repository\" class=\"headerlink\" title=\"9.Add and remove remote repository\"></a>9.Add and remove remote repository</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> remote add origin https://github.com/SmalBox/learngit.git\n$ <span class=\"token function\">git</span> remote add origin git@github.com:SmalBox/learngit.git\n<span class=\"token comment\" spellcheck=\"true\">#GitHub上的提示添加远程库.这两种都可以</span>\n$ <span class=\"token function\">git</span> remote <span class=\"token function\">rm</span> <span class=\"token operator\">&lt;</span>remote name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#移除远程库</span>\n$ <span class=\"token function\">git</span> push -u origin master <span class=\"token comment\" spellcheck=\"true\">#将本地库推送到GitHub</span>\n</code></pre>\n<h2 id=\"10-Clone-from-remote-repository\"><a href=\"#10-Clone-from-remote-repository\" class=\"headerlink\" title=\"10.Clone from remote repository\"></a>10.Clone from remote repository</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> clone git@github.com:SmalBox/repositoryName.git <span class=\"token comment\" spellcheck=\"true\">#从远程克隆到本地</span>\n</code></pre>\n<h2 id=\"Manage-branch\"><a href=\"#Manage-branch\" class=\"headerlink\" title=\"Manage branch\"></a>Manage branch</h2><h2 id=\"11-Create-amp-Combine-branch\"><a href=\"#11-Create-amp-Combine-branch\" class=\"headerlink\" title=\"11.Create &amp; Combine branch\"></a>11.Create &amp; Combine branch</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> branch <span class=\"token comment\" spellcheck=\"true\">#查看分支结构</span>\n$ <span class=\"token function\">git</span> branch <span class=\"token operator\">&lt;</span>name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#创建分支</span>\n$ <span class=\"token function\">git</span> checkout <span class=\"token operator\">&lt;</span>name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#切换分支</span>\n$ <span class=\"token function\">git</span> checkout -b <span class=\"token operator\">&lt;</span>name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#创建并切换分支</span>\n$ <span class=\"token function\">git</span> merge <span class=\"token operator\">&lt;</span>name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#合并某分支到当前分支</span>\n$ <span class=\"token function\">git</span> branch -d <span class=\"token operator\">&lt;</span>name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#删除某分支</span>\n$ <span class=\"token function\">git</span> branch -D <span class=\"token operator\">&lt;</span>name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#强行删除某分支，例如强行删除未合并的分支</span>\n</code></pre>\n<pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> checkout -b dev <span class=\"token comment\" spellcheck=\"true\">#创建并切换 到dev分支</span>\n$ <span class=\"token function\">git</span> branch <span class=\"token comment\" spellcheck=\"true\">#查看 分支</span>\n$ <span class=\"token function\">git</span> checkout master <span class=\"token comment\" spellcheck=\"true\">#切换 到master分支</span>\n$ <span class=\"token function\">git</span> merge dev <span class=\"token comment\" spellcheck=\"true\">#把dev分支 合并 到master分支</span>\n$ <span class=\"token function\">git</span> branch -d dev <span class=\"token comment\" spellcheck=\"true\">#删除 dev分支</span>\n</code></pre>\n<h2 id=\"12-Conflict-fixed\"><a href=\"#12-Conflict-fixed\" class=\"headerlink\" title=\"12.Conflict fixed\"></a>12.Conflict fixed</h2><pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\">#当两个分支修改同一个文件，合并时产生冲突。</span>\n<span class=\"token comment\" spellcheck=\"true\">#在当前分支修改冲突文件，再add和commit之后重新合并。</span>\n$ <span class=\"token function\">git</span> log --graph --pretty<span class=\"token operator\">=</span>oneline --addrev-commit <span class=\"token comment\" spellcheck=\"true\">#查看分之合并图</span>\n</code></pre>\n<h2 id=\"13-Branch-strategy\"><a href=\"#13-Branch-strategy\" class=\"headerlink\" title=\"13.Branch strategy\"></a>13.Branch strategy</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> merge --no-ff -m <span class=\"token string\">\"merge with no-ff\"</span> dev <span class=\"token comment\" spellcheck=\"true\">#不使用Fast</span>\nforward合并，创建一个commit记录。\n</code></pre>\n<h2 id=\"14-Bug-branch-Stach\"><a href=\"#14-Bug-branch-Stach\" class=\"headerlink\" title=\"14.Bug branch(Stach)\"></a>14.Bug branch(Stach)</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> stash <span class=\"token comment\" spellcheck=\"true\">#把暂时没完成的分支储藏起来</span>\n$ <span class=\"token function\">git</span> stash list <span class=\"token comment\" spellcheck=\"true\">#列出存储的各个版本</span>\n$ <span class=\"token function\">git</span> stash pop <span class=\"token comment\" spellcheck=\"true\">#恢复储藏，并删除stach记录</span>\n$ <span class=\"token function\">git</span> stash apply stash@<span class=\"token punctuation\">{</span>0<span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">#恢复到stash0</span>\n$ <span class=\"token function\">git</span> stash drop <span class=\"token comment\" spellcheck=\"true\">#删除stash内容</span>\n</code></pre>\n<h2 id=\"15-Collaboration\"><a href=\"#15-Collaboration\" class=\"headerlink\" title=\"15.Collaboration\"></a>15.Collaboration</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> remote <span class=\"token comment\" spellcheck=\"true\">#查看远程仓库信息(name)</span>\n$ <span class=\"token function\">git</span> remote -v <span class=\"token comment\" spellcheck=\"true\">#查看远程仓库详细信息</span>\n$ <span class=\"token function\">git</span> push <span class=\"token operator\">&lt;</span>git name<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>branch name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#推送分支 例如：git push origin master</span>\n$ <span class=\"token function\">git</span> checkout -b dev origin/dev <span class=\"token comment\" spellcheck=\"true\">#创建本地dev链接远程仓库中的dev</span>\n$ <span class=\"token function\">git</span> pull <span class=\"token comment\" spellcheck=\"true\">#推送失败，远程分支新，用此试图合并</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">git</span>  branch --set-upstream-to<span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>remote name<span class=\"token operator\">></span>/<span class=\"token operator\">&lt;</span>branch name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#无跟踪信息时，说明本地分支与远程分支没有建立关系，用此建立</span>\n</code></pre>\n<h2 id=\"16-Tag\"><a href=\"#16-Tag\" class=\"headerlink\" title=\"16.Tag\"></a>16.Tag</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> tag <span class=\"token operator\">&lt;</span>name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#给当前分支打标签,标签打在最新提交的commit上</span>\n$ <span class=\"token function\">git</span> tag <span class=\"token comment\" spellcheck=\"true\">#查看当前分支的标签</span>\n$ <span class=\"token function\">git</span> tag <span class=\"token operator\">&lt;</span>name<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>commit id<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#给某一个版本的commit打标签</span>\n$ <span class=\"token function\">git</span> tag -a <span class=\"token operator\">&lt;</span>tag name<span class=\"token operator\">></span> -m <span class=\"token string\">\"description\"</span> <span class=\"token operator\">&lt;</span>commit id<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#带有说明的标签</span>\n$ <span class=\"token function\">git</span> tag -s <span class=\"token operator\">&lt;</span>tag name<span class=\"token operator\">></span> -m <span class=\"token string\">\"description\"</span> <span class=\"token operator\">&lt;</span>commit id<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#私钥签名一个标签</span>\n$ <span class=\"token function\">git</span> show <span class=\"token operator\">&lt;</span>tag name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#查看标签信息</span>\n$ <span class=\"token function\">git</span> tag -d <span class=\"token operator\">&lt;</span>tag name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#删除标签</span>\n$ <span class=\"token function\">git</span> push <span class=\"token operator\">&lt;</span>remote name<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>tag name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#推送某一标签到远程仓库</span>\n$ <span class=\"token function\">git</span> push <span class=\"token operator\">&lt;</span>remote name<span class=\"token operator\">></span> --tags <span class=\"token comment\" spellcheck=\"true\">#推送全部标签到远程</span>\n<span class=\"token comment\" spellcheck=\"true\">#删除远程标签，要先删除本地标签，再推送远程。格式如下：</span>\n$ <span class=\"token function\">git</span> tag -d <span class=\"token operator\">&lt;</span>tag name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#删除本地标签</span>\n$ <span class=\"token function\">git</span> push <span class=\"token operator\">&lt;</span>remote name<span class=\"token operator\">></span> :refs/tags/<span class=\"token operator\">&lt;</span>tag name<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\">#推送远程</span>\n</code></pre>\n<h2 id=\"17-Alias\"><a href=\"#17-Alias\" class=\"headerlink\" title=\"17.Alias\"></a>17.Alias</h2><pre class=\" language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> config --global alias.co checkout <span class=\"token comment\" spellcheck=\"true\">#设置全局简写</span>\n$ <span class=\"token function\">git</span> config --global alias.st status \n$ <span class=\"token function\">git</span> config --global alias.ci commit\n$ <span class=\"token function\">git</span> config --global alias.br branch\n$ <span class=\"token function\">git</span> config --global alias.lol <span class=\"token string\">\"log --pretty=oneline\"</span>\n$ <span class=\"token function\">git</span> config --global alias.glol <span class=\"token string\">\"log --graph --pretty=oneline --abbrev-commit\"</span>\n<span class=\"token comment\" spellcheck=\"true\">#全局的配置文件在用户目录下名为：.gitconfig中记录。每个仓库的配置文件在仓库下的.git文件下config文件中记录</span>\n</code></pre>\n<h2 id=\"18-Setting-up-a-proxy\"><a href=\"#18-Setting-up-a-proxy\" class=\"headerlink\" title=\"18.Setting up a proxy\"></a>18.Setting up a proxy</h2><pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 设置只对github代理</span>\n$ <span class=\"token function\">git</span> config --global http.https://github.com.proxy socks5://127.0.0.1:本地代理端口号\n<span class=\"token comment\" spellcheck=\"true\"># 取消代理</span>\n$ <span class=\"token function\">git</span> config --global --unset http.proxy\n$ <span class=\"token function\">git</span> config --global --unset http.https://github.com.proxy\n</code></pre>\n<h2 id=\"19-Git-Large-File-Storage\"><a href=\"#19-Git-Large-File-Storage\" class=\"headerlink\" title=\"19.Git Large File Storage\"></a>19.Git Large File Storage</h2><p>去 Git Large File Storage <a href=\"https://git-lfs.github.com/\" target=\"_blank\" rel=\"noopener\">官网</a>下载安装</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 提供Git对大文件存储支持</span>\n<span class=\"token comment\" spellcheck=\"true\"># 在每个git版本库下执行一下命令以提供大文件存储功能</span>\n$ <span class=\"token function\">git</span> lfs <span class=\"token function\">install</span>\n$ <span class=\"token function\">git</span> lfs track <span class=\"token string\">\"*.psd\"</span>\n$ <span class=\"token function\">git</span> add .gitattributes\n$ <span class=\"token function\">git</span> commit -m <span class=\"token string\">\"添加对psd文件的支持\"</span>\n</code></pre>\n<p>在git版本库的目录下修改 .gitattributes 即可快速添加支持文件<br>例如在 .gitattributes 添加如下配置文件:</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># Image formats:</span>\n*.tga filter<span class=\"token operator\">=</span>lfs diff<span class=\"token operator\">=</span>lfs merge<span class=\"token operator\">=</span>lfs -text\n*.png filter<span class=\"token operator\">=</span>lfs diff<span class=\"token operator\">=</span>lfs merge<span class=\"token operator\">=</span>lfs -text\n*.tif filter<span class=\"token operator\">=</span>lfs diff<span class=\"token operator\">=</span>lfs merge<span class=\"token operator\">=</span>lfs -text\n*.jpg filter<span class=\"token operator\">=</span>lfs diff<span class=\"token operator\">=</span>lfs merge<span class=\"token operator\">=</span>lfs -text\n*.gif filter<span class=\"token operator\">=</span>lfs diff<span class=\"token operator\">=</span>lfs merge<span class=\"token operator\">=</span>lfs -text\n*.psd filter<span class=\"token operator\">=</span>lfs diff<span class=\"token operator\">=</span>lfs merge<span class=\"token operator\">=</span>lfs -text\n\n<span class=\"token comment\" spellcheck=\"true\"># Audio formats:</span>\n*.mp3 filter<span class=\"token operator\">=</span>lfs diff<span class=\"token operator\">=</span>lfs merge<span class=\"token operator\">=</span>lfs -text\n*.wav filter<span class=\"token operator\">=</span>lfs diff<span class=\"token operator\">=</span>lfs merge<span class=\"token operator\">=</span>lfs -text\n*.aiff filter<span class=\"token operator\">=</span>lfs diff<span class=\"token operator\">=</span>lfs merge<span class=\"token operator\">=</span>lfs -text\n\n<span class=\"token comment\" spellcheck=\"true\"># 3D model formats:</span>\n*.fbx filter<span class=\"token operator\">=</span>lfs diff<span class=\"token operator\">=</span>lfs merge<span class=\"token operator\">=</span>lfs -text\n*.obj filter<span class=\"token operator\">=</span>lfs diff<span class=\"token operator\">=</span>lfs merge<span class=\"token operator\">=</span>lfs -text\n\n<span class=\"token comment\" spellcheck=\"true\"># Unity formats:</span>\n*.sbsar filter<span class=\"token operator\">=</span>lfs diff<span class=\"token operator\">=</span>lfs merge<span class=\"token operator\">=</span>lfs -text\n*.unity filter<span class=\"token operator\">=</span>lfs diff<span class=\"token operator\">=</span>lfs merge<span class=\"token operator\">=</span>lfs -text\n\n<span class=\"token comment\" spellcheck=\"true\"># Other binary formats</span>\n*.dll filter<span class=\"token operator\">=</span>lfs diff<span class=\"token operator\">=</span>lfs merge<span class=\"token operator\">=</span>lfs -text\n</code></pre>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><ul>\n<li><strong>Q1: Git push到远程时，遇到 “fatal: TaskCanceledException encountered” 错误</strong><ul>\n<li><strong>A1:</strong><ul>\n<li>在终端输入：<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> config –global credential.helper store\n</code></pre>\n</li>\n<li>在.gitconfig文件中，可以看到多了一项：<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>credential<span class=\"token punctuation\">]</span>\nhelper <span class=\"token operator\">=</span> store\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Q2: windows Git Bash 输入python无响应</strong><ul>\n<li><strong>A2:</strong><ul>\n<li>安装Git Bash 的时候有提示，MinTTY不支持交互操作，如Python和Node, 用winpty + program就可以运行了</li>\n<li>有三种方法：<ol>\n<li>利用winpty接口<pre class=\" language-bash\"><code class=\"language-bash\">winpty python\n</code></pre>\n</li>\n<li>显示使用python -i<pre class=\" language-bash\"><code class=\"language-bash\">python -i\n</code></pre>\n</li>\n<li>用git的alias按键映射，映射上述两方案<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 在 /etc/bash.bashrc 这个文件中加入</span>\n<span class=\"token function\">alias</span> python<span class=\"token operator\">=</span><span class=\"token string\">'winpty python'</span>\n<span class=\"token comment\" spellcheck=\"true\">#然后重启bash，因为它每次重启时会读取bashrc文件来进行初始配置。</span>\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"Git-command-note\"><a href=\"#Git-command-note\" class=\"headerlink\" title=\"Git command note\"></a>Git command note</h1><h2 id=\"Install-initialize-user-name-and-user-email\"><a href=\"#Install-initialize-user-name-and-user-email\" class=\"headerlink\" title=\"Install: initialize user name and user email.\"></a>Install: initialize user name and user email.</h2><pre><code class=\"bash\">$ git config --global user.name &quot;Your Name&quot;\n$ git config --global user.email &quot;email@example.com&quot;\n</code></pre>\n<h2 id=\"1-Create-git\"><a href=\"#1-Create-git\" class=\"headerlink\" title=\"1.Create git\"></a>1.Create git</h2><pre><code class=\"bash\">$ mkdir learnBox #创建目录作为仓库\n$ cd learnBox #进入目录\n$ pwd #显示仓库位置\n$ git init #创建仓库（仓库根目录下有.git的隐藏目录，用ls -ah可以看到）\n</code></pre>\n<h2 id=\"2-Add-amp-Commit-file\"><a href=\"#2-Add-amp-Commit-file\" class=\"headerlink\" title=\"2.Add &amp; Commit file\"></a>2.Add &amp; Commit file</h2><pre><code class=\"bash\">$ git add readme.txt #添加文件到仓库\n$ git commit -m &quot;add readme.txt&quot; #提交以上添加，填写修改信息\n</code></pre>\n<h2 id=\"3-Check-the-status-amp-difference\"><a href=\"#3-Check-the-status-amp-difference\" class=\"headerlink\" title=\"3.Check the status &amp; difference\"></a>3.Check the status &amp; difference</h2><pre><code class=\"bash\">$ git status #查看仓库状态\n$ git diff readme.txt #查看具体修改了哪些\n$ git log #从近到远查看提交日志\n$ git log --pretty=oneline #简化日志每个只显示一行\n</code></pre>\n<h2 id=\"4-Reset\"><a href=\"#4-Reset\" class=\"headerlink\" title=\"4.Reset\"></a>4.Reset</h2><pre><code class=\"bash\">$ git reset --hard HEAD^ #退回上一个版本 &#39;^&#39;退回一个 &#39;~100&#39;退100个\n$ git reset --hard &lt;version id&gt; #版本号写前几位即可，git自己会找\n$ git reflog #记录执行过的命令\n</code></pre>\n<h2 id=\"5-Stage-index\"><a href=\"#5-Stage-index\" class=\"headerlink\" title=\"5.Stage(index)\"></a>5.Stage(index)</h2><pre><code class=\"bash\">使用 &quot;git add&quot; 命令将工作区文件添加到stage暂存区。\n使用 &quot;git commit&quot; 命令将stage暂存区中文件添加到分支。\n</code></pre>\n<h2 id=\"6-Manage-modify\"><a href=\"#6-Manage-modify\" class=\"headerlink\" title=\"6.Manage modify\"></a>6.Manage modify</h2><pre><code class=\"bash\">先add添加到stage，后commit到分支。\n$ git diff HEAD -- readme.txt #查看工作区和版本库中最新版本区别\n</code></pre>\n<h2 id=\"7-Undo-changes\"><a href=\"#7-Undo-changes\" class=\"headerlink\" title=\"7.Undo changes\"></a>7.Undo changes</h2><pre><code class=\"bash\">1)无add无commit：\n    $ git checkout -- &lt;file&gt;\n2)有add无commit：\n    $ git reset HEAD &lt;file&gt;\n    $ git checkout -- &lt;file&gt;\n3)有add有commit：\n    $ git reset --hard HEAD^#退回上一版本\n</code></pre>\n<h2 id=\"8-Remove-file\"><a href=\"#8-Remove-file\" class=\"headerlink\" title=\"8.Remove file\"></a>8.Remove file</h2><pre><code class=\"bash\">$ rm &lt;file&gt; #删除工作区的文件\n$ git rm &lt;file&gt; #如果真的想删，删除版本库里的文件\n$ git checkout -- &lt;file&gt; #误删了工作区文件，用版本库恢复删除文件\n</code></pre>\n<h2 id=\"Remote-repository\"><a href=\"#Remote-repository\" class=\"headerlink\" title=\"Remote repository\"></a>Remote repository</h2><pre><code class=\"bash\">$ ssh-keygen -t rsa -C &quot;email@example.com&quot; #创建ssh协议公钥和私钥\n#进入到GitHub中添加ssh key 即可远程推送\n</code></pre>\n<h2 id=\"9-Add-and-remove-remote-repository\"><a href=\"#9-Add-and-remove-remote-repository\" class=\"headerlink\" title=\"9.Add and remove remote repository\"></a>9.Add and remove remote repository</h2><pre><code class=\"bash\">$ git remote add origin https://github.com/SmalBox/learngit.git\n$ git remote add origin git@github.com:SmalBox/learngit.git\n#GitHub上的提示添加远程库.这两种都可以\n$ git remote rm &lt;remote name&gt; #移除远程库\n$ git push -u origin master #将本地库推送到GitHub\n</code></pre>\n<h2 id=\"10-Clone-from-remote-repository\"><a href=\"#10-Clone-from-remote-repository\" class=\"headerlink\" title=\"10.Clone from remote repository\"></a>10.Clone from remote repository</h2><pre><code class=\"bash\">$ git clone git@github.com:SmalBox/repositoryName.git #从远程克隆到本地\n</code></pre>\n<h2 id=\"Manage-branch\"><a href=\"#Manage-branch\" class=\"headerlink\" title=\"Manage branch\"></a>Manage branch</h2><h2 id=\"11-Create-amp-Combine-branch\"><a href=\"#11-Create-amp-Combine-branch\" class=\"headerlink\" title=\"11.Create &amp; Combine branch\"></a>11.Create &amp; Combine branch</h2><pre><code class=\"bash\">$ git branch #查看分支结构\n$ git branch &lt;name&gt; #创建分支\n$ git checkout &lt;name&gt; #切换分支\n$ git checkout -b &lt;name&gt; #创建并切换分支\n$ git merge &lt;name&gt; #合并某分支到当前分支\n$ git branch -d &lt;name&gt; #删除某分支\n$ git branch -D &lt;name&gt; #强行删除某分支，例如强行删除未合并的分支\n</code></pre>\n<pre><code class=\"bash\">$ git checkout -b dev #创建并切换 到dev分支\n$ git branch #查看 分支\n$ git checkout master #切换 到master分支\n$ git merge dev #把dev分支 合并 到master分支\n$ git branch -d dev #删除 dev分支\n</code></pre>\n<h2 id=\"12-Conflict-fixed\"><a href=\"#12-Conflict-fixed\" class=\"headerlink\" title=\"12.Conflict fixed\"></a>12.Conflict fixed</h2><pre><code class=\"bash\">#当两个分支修改同一个文件，合并时产生冲突。\n#在当前分支修改冲突文件，再add和commit之后重新合并。\n$ git log --graph --pretty=oneline --addrev-commit #查看分之合并图\n</code></pre>\n<h2 id=\"13-Branch-strategy\"><a href=\"#13-Branch-strategy\" class=\"headerlink\" title=\"13.Branch strategy\"></a>13.Branch strategy</h2><pre><code class=\"bash\">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev #不使用Fast\nforward合并，创建一个commit记录。\n</code></pre>\n<h2 id=\"14-Bug-branch-Stach\"><a href=\"#14-Bug-branch-Stach\" class=\"headerlink\" title=\"14.Bug branch(Stach)\"></a>14.Bug branch(Stach)</h2><pre><code class=\"bash\">$ git stash #把暂时没完成的分支储藏起来\n$ git stash list #列出存储的各个版本\n$ git stash pop #恢复储藏，并删除stach记录\n$ git stash apply stash@{0} #恢复到stash0\n$ git stash drop #删除stash内容\n</code></pre>\n<h2 id=\"15-Collaboration\"><a href=\"#15-Collaboration\" class=\"headerlink\" title=\"15.Collaboration\"></a>15.Collaboration</h2><pre><code class=\"bash\">$ git remote #查看远程仓库信息(name)\n$ git remote -v #查看远程仓库详细信息\n$ git push &lt;git name&gt; &lt;branch name&gt; #推送分支 例如：git push origin master\n$ git checkout -b dev origin/dev #创建本地dev链接远程仓库中的dev\n$ git pull #推送失败，远程分支新，用此试图合并\n$ git git  branch --set-upstream-to=&lt;remote name&gt;/&lt;branch name&gt; #无跟踪信息时，说明本地分支与远程分支没有建立关系，用此建立\n</code></pre>\n<h2 id=\"16-Tag\"><a href=\"#16-Tag\" class=\"headerlink\" title=\"16.Tag\"></a>16.Tag</h2><pre><code class=\"bash\">$ git tag &lt;name&gt; #给当前分支打标签,标签打在最新提交的commit上\n$ git tag #查看当前分支的标签\n$ git tag &lt;name&gt; &lt;commit id&gt; #给某一个版本的commit打标签\n$ git tag -a &lt;tag name&gt; -m &quot;description&quot; &lt;commit id&gt; #带有说明的标签\n$ git tag -s &lt;tag name&gt; -m &quot;description&quot; &lt;commit id&gt; #私钥签名一个标签\n$ git show &lt;tag name&gt; #查看标签信息\n$ git tag -d &lt;tag name&gt; #删除标签\n$ git push &lt;remote name&gt; &lt;tag name&gt; #推送某一标签到远程仓库\n$ git push &lt;remote name&gt; --tags #推送全部标签到远程\n#删除远程标签，要先删除本地标签，再推送远程。格式如下：\n$ git tag -d &lt;tag name&gt; #删除本地标签\n$ git push &lt;remote name&gt; :refs/tags/&lt;tag name&gt; #推送远程\n</code></pre>\n<h2 id=\"17-Alias\"><a href=\"#17-Alias\" class=\"headerlink\" title=\"17.Alias\"></a>17.Alias</h2><pre><code class=\"bash\">$ git config --global alias.co checkout #设置全局简写\n$ git config --global alias.st status \n$ git config --global alias.ci commit\n$ git config --global alias.br branch\n$ git config --global alias.lol &quot;log --pretty=oneline&quot;\n$ git config --global alias.glol &quot;log --graph --pretty=oneline --abbrev-commit&quot;\n#全局的配置文件在用户目录下名为：.gitconfig中记录。每个仓库的配置文件在仓库下的.git文件下config文件中记录\n</code></pre>\n<h2 id=\"18-Setting-up-a-proxy\"><a href=\"#18-Setting-up-a-proxy\" class=\"headerlink\" title=\"18.Setting up a proxy\"></a>18.Setting up a proxy</h2><pre><code class=\"bash\"># 设置只对github代理\n$ git config --global http.https://github.com.proxy socks5://127.0.0.1:本地代理端口号\n# 取消代理\n$ git config --global --unset http.proxy\n$ git config --global --unset http.https://github.com.proxy\n</code></pre>\n<h2 id=\"19-Git-Large-File-Storage\"><a href=\"#19-Git-Large-File-Storage\" class=\"headerlink\" title=\"19.Git Large File Storage\"></a>19.Git Large File Storage</h2><p>去 Git Large File Storage <a href=\"https://git-lfs.github.com/\" target=\"_blank\" rel=\"noopener\">官网</a>下载安装</p>\n<pre><code class=\"bash\"># 提供Git对大文件存储支持\n# 在每个git版本库下执行一下命令以提供大文件存储功能\n$ git lfs install\n$ git lfs track &quot;*.psd&quot;\n$ git add .gitattributes\n$ git commit -m &quot;添加对psd文件的支持&quot;\n</code></pre>\n<p>在git版本库的目录下修改 .gitattributes 即可快速添加支持文件<br>例如在 .gitattributes 添加如下配置文件:</p>\n<pre><code class=\"bash\"># Image formats:\n*.tga filter=lfs diff=lfs merge=lfs -text\n*.png filter=lfs diff=lfs merge=lfs -text\n*.tif filter=lfs diff=lfs merge=lfs -text\n*.jpg filter=lfs diff=lfs merge=lfs -text\n*.gif filter=lfs diff=lfs merge=lfs -text\n*.psd filter=lfs diff=lfs merge=lfs -text\n\n# Audio formats:\n*.mp3 filter=lfs diff=lfs merge=lfs -text\n*.wav filter=lfs diff=lfs merge=lfs -text\n*.aiff filter=lfs diff=lfs merge=lfs -text\n\n# 3D model formats:\n*.fbx filter=lfs diff=lfs merge=lfs -text\n*.obj filter=lfs diff=lfs merge=lfs -text\n\n# Unity formats:\n*.sbsar filter=lfs diff=lfs merge=lfs -text\n*.unity filter=lfs diff=lfs merge=lfs -text\n\n# Other binary formats\n*.dll filter=lfs diff=lfs merge=lfs -text\n</code></pre>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><ul>\n<li><strong>Q1: Git push到远程时，遇到 “fatal: TaskCanceledException encountered” 错误</strong><ul>\n<li><strong>A1:</strong><ul>\n<li>在终端输入：<pre><code class=\"bash\">git config –global credential.helper store\n</code></pre>\n</li>\n<li>在.gitconfig文件中，可以看到多了一项：<pre><code class=\"bash\">[credential]\nhelper = store\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Q2: windows Git Bash 输入python无响应</strong><ul>\n<li><strong>A2:</strong><ul>\n<li>安装Git Bash 的时候有提示，MinTTY不支持交互操作，如Python和Node, 用winpty + program就可以运行了</li>\n<li>有三种方法：<ol>\n<li>利用winpty接口<pre><code class=\"bash\">winpty python\n</code></pre>\n</li>\n<li>显示使用python -i<pre><code class=\"bash\">python -i\n</code></pre>\n</li>\n<li>用git的alias按键映射，映射上述两方案<pre><code class=\"bash\"># 在 /etc/bash.bashrc 这个文件中加入\nalias python=&#39;winpty python&#39;\n#然后重启bash，因为它每次重启时会读取bashrc文件来进行初始配置。\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"mi5魔改8000mAh大电池","date":"2019-05-16T12:38:53.000Z","author":"SmalBox","top":false,"_content":"# mi5魔改8000mAh大电池\n\n## **前言**\n\nmi5原装的3000mAh电池实在是撑不住现在这些软件耗电大户，无奈原装电池救不了他，那就找点魔改的电池来终结一天N充的血崩续航。\n\n## **系统选择**\n\n   - mi5 的续航在miui10上崩的是体无完肤。虽然18年下半年的最后几个开发版加入了2D人脸解锁功能，但是也不足以让这个发热功耗差的系统再留在这了。\n   - 在论坛里借鉴了各路推荐，最后经过对比，miui8的最后一个android6的版本是发热续航流畅控制的最好的版本。\n   - **MIUI版本号：8.1.6.0 稳定版**\n   - **Android版本号：6.0.1**\n\n## **开始魔改**\n\n   1. **先来看看工具**，淘宝买的电池附送的工具。\n      ![tool](tool.jpg)\n      - 能用上的工具：\n         - 铲子铲电池\n         - 螺丝刀\n         - 卡针\n         - 吸盘\n         - 上下后盖\n   2. **电池**，因为电池很厚，盖不上原厂后盖，就需要一个保护套当后盖，最后成品有后盖的图。\n      ![battery](battery.jpg)\n      - 这里是8000mAh的电池，他家的电池发货比较慢，客服回复也慢，但是东西不错。\n   3. **吸盘吸开原装玻璃后盖**\n      ![mi5Back](mi5Back.jpg)\n   4. **用螺丝刀把上主板的扣板卸下**\n      ![mi5BackInner1](mi5BackInner1.jpg)\n   5. **断开电池接口，撕下电池易拉胶，用撬板取下电池**\n      ![mi5BackInner2](mi5BackInner2.jpg)\n      *(注：这里的锡箔纸是我之前给手机改散热时弄上去的。锡箔纸下涂了硅脂，将主板热量导出去。)*\n   6. **撕下电池下面的两个易拉胶贴，按入电池槽，接上电池接口**\n      ![mi5BackNewBattery](mi5BackNewBattery.jpg)\n   7. **扣上主办盖子**\n      ![mi5BackNewBattery2](mi5BackNewBattery2.jpg)\n   8. **盖上工具中的上下后盖**\n      ![mi5BackNewCover](mi5BackNewCover.jpg)\n   9. **用热熔胶将电池附近露出的缝隙部分填满**\n      ![mi5BackNewCoverGlue](mi5BackNewCoverGlue.jpg)\n   10. **扣上保护后盖**\n      ![mi5BackCover](mi5BackCover.jpg)\n\n## **测试**\n\n   - **重量**\n      - 原机裸机：129g\n      - 钢化膜+魔改后整体：228g\n      - 重量大概就是iphone XS MAX 加上保护套的重量差不多\n   - **厚度**\n      - 原机厚度：7.25mm\n      - 魔改后厚度：10.5mm\n      - 因为保护壳有收边弧度，所以拿起来厚度还可以接受\n   - **续航**\n      - 使用AccuBattery测试电池容量在7100mAh+\n      - 实测日常轻度使用2天12小时剩余20%\n      - 实测中度使用可两天充一次电\n      - 实测一直玩游戏“街头篮球”50分钟消耗10%，估算满电能玩8小时18分钟左右游戏\n\n## **总结**\n\n   - **优点**\n      - 超强续航，安全感爆棚。真正解决一天N充。\n   - **缺点**\n      - 重量、厚度都有所增加，不过在能接受的范围内。\n      - 安全性有所降低，后盖只用保护壳保护，在防摔防水上会有一定的妥协。我是用了热熔胶封住缝隙，粘住手机边框和后壳来增加了稳定性。","source":"_posts/mi5魔改8000mAh大电池.md","raw":"---\ntitle: mi5魔改8000mAh大电池\ndate: 2019-05-16 20:38:53\nauthor: SmalBox\ncategories: DIY\ntop: false\ntags:\n  - 手机\n  - 电池\n---\n# mi5魔改8000mAh大电池\n\n## **前言**\n\nmi5原装的3000mAh电池实在是撑不住现在这些软件耗电大户，无奈原装电池救不了他，那就找点魔改的电池来终结一天N充的血崩续航。\n\n## **系统选择**\n\n   - mi5 的续航在miui10上崩的是体无完肤。虽然18年下半年的最后几个开发版加入了2D人脸解锁功能，但是也不足以让这个发热功耗差的系统再留在这了。\n   - 在论坛里借鉴了各路推荐，最后经过对比，miui8的最后一个android6的版本是发热续航流畅控制的最好的版本。\n   - **MIUI版本号：8.1.6.0 稳定版**\n   - **Android版本号：6.0.1**\n\n## **开始魔改**\n\n   1. **先来看看工具**，淘宝买的电池附送的工具。\n      ![tool](tool.jpg)\n      - 能用上的工具：\n         - 铲子铲电池\n         - 螺丝刀\n         - 卡针\n         - 吸盘\n         - 上下后盖\n   2. **电池**，因为电池很厚，盖不上原厂后盖，就需要一个保护套当后盖，最后成品有后盖的图。\n      ![battery](battery.jpg)\n      - 这里是8000mAh的电池，他家的电池发货比较慢，客服回复也慢，但是东西不错。\n   3. **吸盘吸开原装玻璃后盖**\n      ![mi5Back](mi5Back.jpg)\n   4. **用螺丝刀把上主板的扣板卸下**\n      ![mi5BackInner1](mi5BackInner1.jpg)\n   5. **断开电池接口，撕下电池易拉胶，用撬板取下电池**\n      ![mi5BackInner2](mi5BackInner2.jpg)\n      *(注：这里的锡箔纸是我之前给手机改散热时弄上去的。锡箔纸下涂了硅脂，将主板热量导出去。)*\n   6. **撕下电池下面的两个易拉胶贴，按入电池槽，接上电池接口**\n      ![mi5BackNewBattery](mi5BackNewBattery.jpg)\n   7. **扣上主办盖子**\n      ![mi5BackNewBattery2](mi5BackNewBattery2.jpg)\n   8. **盖上工具中的上下后盖**\n      ![mi5BackNewCover](mi5BackNewCover.jpg)\n   9. **用热熔胶将电池附近露出的缝隙部分填满**\n      ![mi5BackNewCoverGlue](mi5BackNewCoverGlue.jpg)\n   10. **扣上保护后盖**\n      ![mi5BackCover](mi5BackCover.jpg)\n\n## **测试**\n\n   - **重量**\n      - 原机裸机：129g\n      - 钢化膜+魔改后整体：228g\n      - 重量大概就是iphone XS MAX 加上保护套的重量差不多\n   - **厚度**\n      - 原机厚度：7.25mm\n      - 魔改后厚度：10.5mm\n      - 因为保护壳有收边弧度，所以拿起来厚度还可以接受\n   - **续航**\n      - 使用AccuBattery测试电池容量在7100mAh+\n      - 实测日常轻度使用2天12小时剩余20%\n      - 实测中度使用可两天充一次电\n      - 实测一直玩游戏“街头篮球”50分钟消耗10%，估算满电能玩8小时18分钟左右游戏\n\n## **总结**\n\n   - **优点**\n      - 超强续航，安全感爆棚。真正解决一天N充。\n   - **缺点**\n      - 重量、厚度都有所增加，不过在能接受的范围内。\n      - 安全性有所降低，后盖只用保护壳保护，在防摔防水上会有一定的妥协。我是用了热熔胶封住缝隙，粘住手机边框和后壳来增加了稳定性。","slug":"mi5魔改8000mAh大电池","published":1,"updated":"2019-11-24T16:25:24.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptihc000dbsfo8ooas79t","content":"<h1 id=\"mi5魔改8000mAh大电池\"><a href=\"#mi5魔改8000mAh大电池\" class=\"headerlink\" title=\"mi5魔改8000mAh大电池\"></a>mi5魔改8000mAh大电池</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>mi5原装的3000mAh电池实在是撑不住现在这些软件耗电大户，无奈原装电池救不了他，那就找点魔改的电池来终结一天N充的血崩续航。</p>\n<h2 id=\"系统选择\"><a href=\"#系统选择\" class=\"headerlink\" title=\"系统选择\"></a><strong>系统选择</strong></h2><ul>\n<li>mi5 的续航在miui10上崩的是体无完肤。虽然18年下半年的最后几个开发版加入了2D人脸解锁功能，但是也不足以让这个发热功耗差的系统再留在这了。</li>\n<li>在论坛里借鉴了各路推荐，最后经过对比，miui8的最后一个android6的版本是发热续航流畅控制的最好的版本。</li>\n<li><strong>MIUI版本号：8.1.6.0 稳定版</strong></li>\n<li><strong>Android版本号：6.0.1</strong></li>\n</ul>\n<h2 id=\"开始魔改\"><a href=\"#开始魔改\" class=\"headerlink\" title=\"开始魔改\"></a><strong>开始魔改</strong></h2><ol>\n<li><strong>先来看看工具</strong>，淘宝买的电池附送的工具。<br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/tool.jpg\" alt=\"tool\"><ul>\n<li>能用上的工具：<ul>\n<li>铲子铲电池</li>\n<li>螺丝刀</li>\n<li>卡针</li>\n<li>吸盘</li>\n<li>上下后盖</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>电池</strong>，因为电池很厚，盖不上原厂后盖，就需要一个保护套当后盖，最后成品有后盖的图。<br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/battery.jpg\" alt=\"battery\"><ul>\n<li>这里是8000mAh的电池，他家的电池发货比较慢，客服回复也慢，但是东西不错。</li>\n</ul>\n</li>\n<li><strong>吸盘吸开原装玻璃后盖</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5Back.jpg\" alt=\"mi5Back\"></li>\n<li><strong>用螺丝刀把上主板的扣板卸下</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackInner1.jpg\" alt=\"mi5BackInner1\"></li>\n<li><strong>断开电池接口，撕下电池易拉胶，用撬板取下电池</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackInner2.jpg\" alt=\"mi5BackInner2\"><br><em>(注：这里的锡箔纸是我之前给手机改散热时弄上去的。锡箔纸下涂了硅脂，将主板热量导出去。)</em></li>\n<li><strong>撕下电池下面的两个易拉胶贴，按入电池槽，接上电池接口</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackNewBattery.jpg\" alt=\"mi5BackNewBattery\"></li>\n<li><strong>扣上主办盖子</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackNewBattery2.jpg\" alt=\"mi5BackNewBattery2\"></li>\n<li><strong>盖上工具中的上下后盖</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackNewCover.jpg\" alt=\"mi5BackNewCover\"></li>\n<li><strong>用热熔胶将电池附近露出的缝隙部分填满</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackNewCoverGlue.jpg\" alt=\"mi5BackNewCoverGlue\"></li>\n<li><strong>扣上保护后盖</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackCover.jpg\" alt=\"mi5BackCover\"></li>\n</ol>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a><strong>测试</strong></h2><ul>\n<li><strong>重量</strong><ul>\n<li>原机裸机：129g</li>\n<li>钢化膜+魔改后整体：228g</li>\n<li>重量大概就是iphone XS MAX 加上保护套的重量差不多</li>\n</ul>\n</li>\n<li><strong>厚度</strong><ul>\n<li>原机厚度：7.25mm</li>\n<li>魔改后厚度：10.5mm</li>\n<li>因为保护壳有收边弧度，所以拿起来厚度还可以接受</li>\n</ul>\n</li>\n<li><strong>续航</strong><ul>\n<li>使用AccuBattery测试电池容量在7100mAh+</li>\n<li>实测日常轻度使用2天12小时剩余20%</li>\n<li>实测中度使用可两天充一次电</li>\n<li>实测一直玩游戏“街头篮球”50分钟消耗10%，估算满电能玩8小时18分钟左右游戏</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><ul>\n<li><strong>优点</strong><ul>\n<li>超强续航，安全感爆棚。真正解决一天N充。</li>\n</ul>\n</li>\n<li><strong>缺点</strong><ul>\n<li>重量、厚度都有所增加，不过在能接受的范围内。</li>\n<li>安全性有所降低，后盖只用保护壳保护，在防摔防水上会有一定的妥协。我是用了热熔胶封住缝隙，粘住手机边框和后壳来增加了稳定性。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"mi5魔改8000mAh大电池\"><a href=\"#mi5魔改8000mAh大电池\" class=\"headerlink\" title=\"mi5魔改8000mAh大电池\"></a>mi5魔改8000mAh大电池</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>mi5原装的3000mAh电池实在是撑不住现在这些软件耗电大户，无奈原装电池救不了他，那就找点魔改的电池来终结一天N充的血崩续航。</p>\n<h2 id=\"系统选择\"><a href=\"#系统选择\" class=\"headerlink\" title=\"系统选择\"></a><strong>系统选择</strong></h2><ul>\n<li>mi5 的续航在miui10上崩的是体无完肤。虽然18年下半年的最后几个开发版加入了2D人脸解锁功能，但是也不足以让这个发热功耗差的系统再留在这了。</li>\n<li>在论坛里借鉴了各路推荐，最后经过对比，miui8的最后一个android6的版本是发热续航流畅控制的最好的版本。</li>\n<li><strong>MIUI版本号：8.1.6.0 稳定版</strong></li>\n<li><strong>Android版本号：6.0.1</strong></li>\n</ul>\n<h2 id=\"开始魔改\"><a href=\"#开始魔改\" class=\"headerlink\" title=\"开始魔改\"></a><strong>开始魔改</strong></h2><ol>\n<li><strong>先来看看工具</strong>，淘宝买的电池附送的工具。<br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/tool.jpg\" alt=\"tool\"><ul>\n<li>能用上的工具：<ul>\n<li>铲子铲电池</li>\n<li>螺丝刀</li>\n<li>卡针</li>\n<li>吸盘</li>\n<li>上下后盖</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>电池</strong>，因为电池很厚，盖不上原厂后盖，就需要一个保护套当后盖，最后成品有后盖的图。<br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/battery.jpg\" alt=\"battery\"><ul>\n<li>这里是8000mAh的电池，他家的电池发货比较慢，客服回复也慢，但是东西不错。</li>\n</ul>\n</li>\n<li><strong>吸盘吸开原装玻璃后盖</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5Back.jpg\" alt=\"mi5Back\"></li>\n<li><strong>用螺丝刀把上主板的扣板卸下</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackInner1.jpg\" alt=\"mi5BackInner1\"></li>\n<li><strong>断开电池接口，撕下电池易拉胶，用撬板取下电池</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackInner2.jpg\" alt=\"mi5BackInner2\"><br><em>(注：这里的锡箔纸是我之前给手机改散热时弄上去的。锡箔纸下涂了硅脂，将主板热量导出去。)</em></li>\n<li><strong>撕下电池下面的两个易拉胶贴，按入电池槽，接上电池接口</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackNewBattery.jpg\" alt=\"mi5BackNewBattery\"></li>\n<li><strong>扣上主办盖子</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackNewBattery2.jpg\" alt=\"mi5BackNewBattery2\"></li>\n<li><strong>盖上工具中的上下后盖</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackNewCover.jpg\" alt=\"mi5BackNewCover\"></li>\n<li><strong>用热熔胶将电池附近露出的缝隙部分填满</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackNewCoverGlue.jpg\" alt=\"mi5BackNewCoverGlue\"></li>\n<li><strong>扣上保护后盖</strong><br><img src=\"/2019/05/16/mi5-mo-gai-8000mah-da-dian-chi/mi5BackCover.jpg\" alt=\"mi5BackCover\"></li>\n</ol>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a><strong>测试</strong></h2><ul>\n<li><strong>重量</strong><ul>\n<li>原机裸机：129g</li>\n<li>钢化膜+魔改后整体：228g</li>\n<li>重量大概就是iphone XS MAX 加上保护套的重量差不多</li>\n</ul>\n</li>\n<li><strong>厚度</strong><ul>\n<li>原机厚度：7.25mm</li>\n<li>魔改后厚度：10.5mm</li>\n<li>因为保护壳有收边弧度，所以拿起来厚度还可以接受</li>\n</ul>\n</li>\n<li><strong>续航</strong><ul>\n<li>使用AccuBattery测试电池容量在7100mAh+</li>\n<li>实测日常轻度使用2天12小时剩余20%</li>\n<li>实测中度使用可两天充一次电</li>\n<li>实测一直玩游戏“街头篮球”50分钟消耗10%，估算满电能玩8小时18分钟左右游戏</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><ul>\n<li><strong>优点</strong><ul>\n<li>超强续航，安全感爆棚。真正解决一天N充。</li>\n</ul>\n</li>\n<li><strong>缺点</strong><ul>\n<li>重量、厚度都有所增加，不过在能接受的范围内。</li>\n<li>安全性有所降低，后盖只用保护壳保护，在防摔防水上会有一定的妥协。我是用了热熔胶封住缝隙，粘住手机边框和后壳来增加了稳定性。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"screen代替nohup运行后台进程","date":"2018-11-08T11:37:56.000Z","author":"Smalbox","_content":"# screen代替nohup运行后台进程\n\n## **前言**\n\n在linux中常用nohup和&配合将程序放在后台运行，但是当远程用ssh登陆时会遇到退出远程后进程就被杀掉了。\n\n这里用screen来守护进程不会被杀掉。\n\n## **具体流程**\n\n1. 创建一个screen会话\n   ``` bash\n   $screen -S screenName\n   ```\n2. 启动脚本，服务之类的任何想要后台运行的东西\n3. 退出screen会话\n   ``` bash\n   $screen -d\n   ```\n4. 如果想恢复会话（重新连接）\n   ``` bash\n   $screen -r screenName\n   ```\n5. 查看是否有screen会话及其状态\n   ``` bash\n   $screen -ls\n   ```\n\n*（此方法适用于bash，zsh等终端。可使用 man screen 查看详细信息）*","source":"_posts/screen代替nohup运行后台进程.md","raw":"---\ntitle: screen代替nohup运行后台进程\ndate: 2018-11-08 19:37:56\nauthor: Smalbox\ncategories: Linux\ntags:\n  - nohup\n  - screen\n  - 后台运行程序\n---\n# screen代替nohup运行后台进程\n\n## **前言**\n\n在linux中常用nohup和&配合将程序放在后台运行，但是当远程用ssh登陆时会遇到退出远程后进程就被杀掉了。\n\n这里用screen来守护进程不会被杀掉。\n\n## **具体流程**\n\n1. 创建一个screen会话\n   ``` bash\n   $screen -S screenName\n   ```\n2. 启动脚本，服务之类的任何想要后台运行的东西\n3. 退出screen会话\n   ``` bash\n   $screen -d\n   ```\n4. 如果想恢复会话（重新连接）\n   ``` bash\n   $screen -r screenName\n   ```\n5. 查看是否有screen会话及其状态\n   ``` bash\n   $screen -ls\n   ```\n\n*（此方法适用于bash，zsh等终端。可使用 man screen 查看详细信息）*","slug":"screen代替nohup运行后台进程","published":1,"updated":"2019-11-24T16:25:24.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptihf000ebsfo7law4ubq","content":"<h1 id=\"screen代替nohup运行后台进程\"><a href=\"#screen代替nohup运行后台进程\" class=\"headerlink\" title=\"screen代替nohup运行后台进程\"></a>screen代替nohup运行后台进程</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>在linux中常用nohup和&amp;配合将程序放在后台运行，但是当远程用ssh登陆时会遇到退出远程后进程就被杀掉了。</p>\n<p>这里用screen来守护进程不会被杀掉。</p>\n<h2 id=\"具体流程\"><a href=\"#具体流程\" class=\"headerlink\" title=\"具体流程\"></a><strong>具体流程</strong></h2><ol>\n<li>创建一个screen会话<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token variable\">$screen</span> -S screenName\n</code></pre>\n</li>\n<li>启动脚本，服务之类的任何想要后台运行的东西</li>\n<li>退出screen会话<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token variable\">$screen</span> -d\n</code></pre>\n</li>\n<li>如果想恢复会话（重新连接）<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token variable\">$screen</span> -r screenName\n</code></pre>\n</li>\n<li>查看是否有screen会话及其状态<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token variable\">$screen</span> -ls\n</code></pre>\n</li>\n</ol>\n<p><em>（此方法适用于bash，zsh等终端。可使用 man screen 查看详细信息）</em></p>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"screen代替nohup运行后台进程\"><a href=\"#screen代替nohup运行后台进程\" class=\"headerlink\" title=\"screen代替nohup运行后台进程\"></a>screen代替nohup运行后台进程</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>在linux中常用nohup和&amp;配合将程序放在后台运行，但是当远程用ssh登陆时会遇到退出远程后进程就被杀掉了。</p>\n<p>这里用screen来守护进程不会被杀掉。</p>\n<h2 id=\"具体流程\"><a href=\"#具体流程\" class=\"headerlink\" title=\"具体流程\"></a><strong>具体流程</strong></h2><ol>\n<li>创建一个screen会话<pre><code class=\"bash\">$screen -S screenName\n</code></pre>\n</li>\n<li>启动脚本，服务之类的任何想要后台运行的东西</li>\n<li>退出screen会话<pre><code class=\"bash\">$screen -d\n</code></pre>\n</li>\n<li>如果想恢复会话（重新连接）<pre><code class=\"bash\">$screen -r screenName\n</code></pre>\n</li>\n<li>查看是否有screen会话及其状态<pre><code class=\"bash\">$screen -ls\n</code></pre>\n</li>\n</ol>\n<p><em>（此方法适用于bash，zsh等终端。可使用 man screen 查看详细信息）</em></p>\n"},{"title":"安装Gitment及常见问题解决","date":"2018-10-24T11:13:59.000Z","author":"SmalBox","_content":"# 安装Gitment评论模块 & 常见问题解决\n\n## **前言**\n\n本文记录了本博客添加gitment评论模块的过程，并对配置过程中碰到的问题与其解决方案作出阐述。\n因每个hexo选择的主题不一样，所以主题的文件结构会有所不同，具体操作也会有所不同，所以本文也尽可能的写出配置思路，来帮助不同主题的hexo博主配置自己主题的gitment评论模块。\n\n对gitment的介绍就不多说了，就是利用GitHub的issue来做评论，能同步issue里的留言。具体详细可以去看项目介绍：[Gitment项目地址](https://github.com/imsun/gitment).\n\n> 大致描述一下gitment的配置：\n  - 首先是两个配置文件，一个\u001dcss文件一个js文件。gitment的开发者用远程连接的方式将两个文件引入hexo中。但是实际操作中会遇到问题（最后常见问题中会写解决方案），其中的js文件中需要访问作者自己搭建的服务器，但是现在作者的服务器不好使了，会导致全都配置好了，但是报错。所以要下载到本地的自己项目中，然后在项目中自己引用这两个文件（具体操作本文安装部分会写到）。\n\n  - 其次就是由于主题不同，有的主题的作者在开始设计主题的时候就为用户写好了gitment的配置代码，只需用户在主题的_config.yml中开启并填写好配置参数即可。有的主题没有预制好gitment的配置代码，就需要用户自己去在样式模板中添加gitment代码。\n\n## **概览**\n\n  1. 安装gitment到主题\n  2. 注册OAuth application\n  3. 配置gitment到hexo主题中\n  4. 初始化评论\n  5. 常见问题解决\n\n### **1.安装gitment到主题**\n\n由于有的hexo主题预置gitment模块，有的没有，所以分两种情况来说。\n\n  1. **主题已经集成了gitment模块 看这里～**\n  - 需要博主自己查看一下自己的主题结构，找到 **themes** 下的 **_config.yml** 文件，在文件中找到gitment模块的相关参数，然后在 **enable** 选项后面写上 **true** 即可完成安装过程。\n\n  如图所示： ![gitmentConfig](gitmentConfig.png)\n\n  2. **主题没有集成gitment模块 根本配置在这里～**\n  - 如果在自己的 **themes** 的 **_config.yml** 中没有看到 **gitment**相关选项，就要自己配置。\n  - 这时就要用到gitment作者的安装方法了。前言中说到的两个文件一个css一个js，只要将这两个文件引入自己主题的母板中就完成了安装。由于作者的提供是js文件中需要改动，所以这里要将提供是文件下载下来到自己的博客中，根据自己的文件结构防治css和js文件。然后在模板文件中引用两个文件。\n  \n  - [css文件下载地址](https://imsun.github.io/gitment/style/default.css)\n  - [js文件下载地址](https://imsun.github.io/gitment/dist/gitment.browser.js)\n\n  ``` html\n  <!--(将以下添加到模板文件中（这个引用路径是一个例子，根据自己的目录引用)-->\n\n  <link rel=\"stylesheet\" href=\"/libs/gitment/default.css\">\n  <script src=\"/libs/gitment/gitment.browser.js\"></script>\n  ```\n\n*（注：本质上安装就是在主题模板文件中引入一个css和一个js文件。集成gitment模块的主题只不过是做到了代码分离，让需要配置的参数在_config.yml中统一配置。gitment作者给出的方法是在给没有集成的主题中的根本引入办法。如果你能看懂主题作者的组织结构，那完全可以给自己的主题集成gitment模块。因主题结构不一样我就不详细举例了。）*\n\n### **2.注册OAuth application**\n\n因为gitment是利用了github的issue，所以要注册OAuth application，来获取配置参数为接下来的配置做准备。\n\n[点击此处](https://github.com/settings/applications/new)来注册，一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://smalbox.club）。\n\n注册后会给两个字符串 **Client ID** 和 **Client Secret** , 这两个下面配置的时候要用。\n\n### **3.配置Gitment到hexo主题中**\n\n同样的，也是一种预置gitment和自己配置分两种来说。\n\n  1. **主题已经集成了gitment模块 看这里～** \n  - 只需在 **_config.yml** 中找到刚才开启gitment的那里，下面有四个参数要添加。\n  \n  如图所示：![gitmentConfiged](gitmentConfiged.jpeg)\n\n  2. **主题没有集成gitment模块 根本配置在这里～**\n  - 在刚才添加的母版中继续添加如下代码：\n\n``` html\n<div id=\"container\"></div>\n<script>\nvar gitment = new Gitment({\n  owner: '你的 GitHub ID',\n  repo: '存储评论的 repo',\n  oauth: {\n    client_id: '你的 client ID',\n    client_secret: '你的 client secret',\n  },\n})\ngitment.render('container')\n</script>\n```\n  - 将以上的代码中的四个参数按照提示填好即可。\n\n### **4.初始化评论**\n\n理论上按照以上配置完发布即可看到评论区了。只不过每一个帖子下面的评论区都要初始化才能开始评论。\n\n根据gitment作者的说法，只要到用博主的github账号登录后点击初始化就可以使用了。\n\n### **5.常见问题解决**\n\n  - 评论点击登录，登录GitHub之后跳转回来的时候不能正常跳回刚才贴纸那页。每次跳到主页。\n\n**解决办法：** 在注册OAuth application时的回调地址有问题，尝试写绑定的域名，而不是用 “https://用户名.github.io”\n\n  - 报错 “[object ProgressEvent]”\n\n**原因：** 在母版中调用的js文件中，有访问gitment作者的服务器代码，而作者的服务器不好使了。\n\n**解决办法：** 自己搭建一个服务器（需要有一个vps来辅助搭建服务器，当然下面我也会提供一个我搭建好的服务器）\n\n  1. 在服务器中clone作者的服务器源码\n\n``` bash\ngit clone https://github.com/SmalBox/gh-oauth-server.git\n```\n  2. 进入项目，下载依赖，并启动\n\n``` bash\nnpm install && nohup npm start &\n```\n*(注：如果运行失败，可能是nodejs没有安装好，请安装nodejs。然后再重新运行命令,如果成功,在项目目录下的nohup.out文件中的最后，会提示正在监听3000端口。这里需要用nginx将证书搞定，用https访问，否则默认http还是会报错。证书的问题我就不啰嗦了，证书参考[这个帖子的 11.后续优化 部分](https://www.bugprogrammer.me/2018/05/19/phpnginxmysql.html#more),端口转发请参考[这个帖子](https://segmentfault.com/a/1190000002797606))*\n\n  3. 替换js文件中的作者服务器为自己服务器\n\n在作者的js文件中搜索以下字符串：\n``` bash\nhttps://gh-oauth.imsun.net\n```\n将其替换成刚才搭建服务器的地址即可。\n\n**OK大功告成，可以去测试一下了。可以在本站的下面回复评论测试。**\n\n**如果有任何问题，可以在下面评论或者通过邮件联系我。**\n","source":"_posts/安装Gitment及常见问题解决.md","raw":"---\ntitle: 安装Gitment及常见问题解决\ndate: 2018-10-24 19:13:59\nauthor: SmalBox\ncategories: 前端\ntags:\n  - Gitment\n---\n# 安装Gitment评论模块 & 常见问题解决\n\n## **前言**\n\n本文记录了本博客添加gitment评论模块的过程，并对配置过程中碰到的问题与其解决方案作出阐述。\n因每个hexo选择的主题不一样，所以主题的文件结构会有所不同，具体操作也会有所不同，所以本文也尽可能的写出配置思路，来帮助不同主题的hexo博主配置自己主题的gitment评论模块。\n\n对gitment的介绍就不多说了，就是利用GitHub的issue来做评论，能同步issue里的留言。具体详细可以去看项目介绍：[Gitment项目地址](https://github.com/imsun/gitment).\n\n> 大致描述一下gitment的配置：\n  - 首先是两个配置文件，一个\u001dcss文件一个js文件。gitment的开发者用远程连接的方式将两个文件引入hexo中。但是实际操作中会遇到问题（最后常见问题中会写解决方案），其中的js文件中需要访问作者自己搭建的服务器，但是现在作者的服务器不好使了，会导致全都配置好了，但是报错。所以要下载到本地的自己项目中，然后在项目中自己引用这两个文件（具体操作本文安装部分会写到）。\n\n  - 其次就是由于主题不同，有的主题的作者在开始设计主题的时候就为用户写好了gitment的配置代码，只需用户在主题的_config.yml中开启并填写好配置参数即可。有的主题没有预制好gitment的配置代码，就需要用户自己去在样式模板中添加gitment代码。\n\n## **概览**\n\n  1. 安装gitment到主题\n  2. 注册OAuth application\n  3. 配置gitment到hexo主题中\n  4. 初始化评论\n  5. 常见问题解决\n\n### **1.安装gitment到主题**\n\n由于有的hexo主题预置gitment模块，有的没有，所以分两种情况来说。\n\n  1. **主题已经集成了gitment模块 看这里～**\n  - 需要博主自己查看一下自己的主题结构，找到 **themes** 下的 **_config.yml** 文件，在文件中找到gitment模块的相关参数，然后在 **enable** 选项后面写上 **true** 即可完成安装过程。\n\n  如图所示： ![gitmentConfig](gitmentConfig.png)\n\n  2. **主题没有集成gitment模块 根本配置在这里～**\n  - 如果在自己的 **themes** 的 **_config.yml** 中没有看到 **gitment**相关选项，就要自己配置。\n  - 这时就要用到gitment作者的安装方法了。前言中说到的两个文件一个css一个js，只要将这两个文件引入自己主题的母板中就完成了安装。由于作者的提供是js文件中需要改动，所以这里要将提供是文件下载下来到自己的博客中，根据自己的文件结构防治css和js文件。然后在模板文件中引用两个文件。\n  \n  - [css文件下载地址](https://imsun.github.io/gitment/style/default.css)\n  - [js文件下载地址](https://imsun.github.io/gitment/dist/gitment.browser.js)\n\n  ``` html\n  <!--(将以下添加到模板文件中（这个引用路径是一个例子，根据自己的目录引用)-->\n\n  <link rel=\"stylesheet\" href=\"/libs/gitment/default.css\">\n  <script src=\"/libs/gitment/gitment.browser.js\"></script>\n  ```\n\n*（注：本质上安装就是在主题模板文件中引入一个css和一个js文件。集成gitment模块的主题只不过是做到了代码分离，让需要配置的参数在_config.yml中统一配置。gitment作者给出的方法是在给没有集成的主题中的根本引入办法。如果你能看懂主题作者的组织结构，那完全可以给自己的主题集成gitment模块。因主题结构不一样我就不详细举例了。）*\n\n### **2.注册OAuth application**\n\n因为gitment是利用了github的issue，所以要注册OAuth application，来获取配置参数为接下来的配置做准备。\n\n[点击此处](https://github.com/settings/applications/new)来注册，一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://smalbox.club）。\n\n注册后会给两个字符串 **Client ID** 和 **Client Secret** , 这两个下面配置的时候要用。\n\n### **3.配置Gitment到hexo主题中**\n\n同样的，也是一种预置gitment和自己配置分两种来说。\n\n  1. **主题已经集成了gitment模块 看这里～** \n  - 只需在 **_config.yml** 中找到刚才开启gitment的那里，下面有四个参数要添加。\n  \n  如图所示：![gitmentConfiged](gitmentConfiged.jpeg)\n\n  2. **主题没有集成gitment模块 根本配置在这里～**\n  - 在刚才添加的母版中继续添加如下代码：\n\n``` html\n<div id=\"container\"></div>\n<script>\nvar gitment = new Gitment({\n  owner: '你的 GitHub ID',\n  repo: '存储评论的 repo',\n  oauth: {\n    client_id: '你的 client ID',\n    client_secret: '你的 client secret',\n  },\n})\ngitment.render('container')\n</script>\n```\n  - 将以上的代码中的四个参数按照提示填好即可。\n\n### **4.初始化评论**\n\n理论上按照以上配置完发布即可看到评论区了。只不过每一个帖子下面的评论区都要初始化才能开始评论。\n\n根据gitment作者的说法，只要到用博主的github账号登录后点击初始化就可以使用了。\n\n### **5.常见问题解决**\n\n  - 评论点击登录，登录GitHub之后跳转回来的时候不能正常跳回刚才贴纸那页。每次跳到主页。\n\n**解决办法：** 在注册OAuth application时的回调地址有问题，尝试写绑定的域名，而不是用 “https://用户名.github.io”\n\n  - 报错 “[object ProgressEvent]”\n\n**原因：** 在母版中调用的js文件中，有访问gitment作者的服务器代码，而作者的服务器不好使了。\n\n**解决办法：** 自己搭建一个服务器（需要有一个vps来辅助搭建服务器，当然下面我也会提供一个我搭建好的服务器）\n\n  1. 在服务器中clone作者的服务器源码\n\n``` bash\ngit clone https://github.com/SmalBox/gh-oauth-server.git\n```\n  2. 进入项目，下载依赖，并启动\n\n``` bash\nnpm install && nohup npm start &\n```\n*(注：如果运行失败，可能是nodejs没有安装好，请安装nodejs。然后再重新运行命令,如果成功,在项目目录下的nohup.out文件中的最后，会提示正在监听3000端口。这里需要用nginx将证书搞定，用https访问，否则默认http还是会报错。证书的问题我就不啰嗦了，证书参考[这个帖子的 11.后续优化 部分](https://www.bugprogrammer.me/2018/05/19/phpnginxmysql.html#more),端口转发请参考[这个帖子](https://segmentfault.com/a/1190000002797606))*\n\n  3. 替换js文件中的作者服务器为自己服务器\n\n在作者的js文件中搜索以下字符串：\n``` bash\nhttps://gh-oauth.imsun.net\n```\n将其替换成刚才搭建服务器的地址即可。\n\n**OK大功告成，可以去测试一下了。可以在本站的下面回复评论测试。**\n\n**如果有任何问题，可以在下面评论或者通过邮件联系我。**\n","slug":"安装Gitment及常见问题解决","published":1,"updated":"2020-01-02T14:10:55.686Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptihi000ibsfodadfz09p","content":"<h1 id=\"安装Gitment评论模块-amp-常见问题解决\"><a href=\"#安装Gitment评论模块-amp-常见问题解决\" class=\"headerlink\" title=\"安装Gitment评论模块 &amp; 常见问题解决\"></a>安装Gitment评论模块 &amp; 常见问题解决</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>本文记录了本博客添加gitment评论模块的过程，并对配置过程中碰到的问题与其解决方案作出阐述。<br>因每个hexo选择的主题不一样，所以主题的文件结构会有所不同，具体操作也会有所不同，所以本文也尽可能的写出配置思路，来帮助不同主题的hexo博主配置自己主题的gitment评论模块。</p>\n<p>对gitment的介绍就不多说了，就是利用GitHub的issue来做评论，能同步issue里的留言。具体详细可以去看项目介绍：<a href=\"https://github.com/imsun/gitment\" target=\"_blank\" rel=\"noopener\">Gitment项目地址</a>.</p>\n<blockquote>\n<p>大致描述一下gitment的配置：</p>\n<ul>\n<li>首先是两个配置文件，一个\u001dcss文件一个js文件。gitment的开发者用远程连接的方式将两个文件引入hexo中。但是实际操作中会遇到问题（最后常见问题中会写解决方案），其中的js文件中需要访问作者自己搭建的服务器，但是现在作者的服务器不好使了，会导致全都配置好了，但是报错。所以要下载到本地的自己项目中，然后在项目中自己引用这两个文件（具体操作本文安装部分会写到）。</li>\n</ul>\n</blockquote>\n<ul>\n<li>其次就是由于主题不同，有的主题的作者在开始设计主题的时候就为用户写好了gitment的配置代码，只需用户在主题的_config.yml中开启并填写好配置参数即可。有的主题没有预制好gitment的配置代码，就需要用户自己去在样式模板中添加gitment代码。</li>\n</ul>\n<h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a><strong>概览</strong></h2><ol>\n<li>安装gitment到主题</li>\n<li>注册OAuth application</li>\n<li>配置gitment到hexo主题中</li>\n<li>初始化评论</li>\n<li>常见问题解决</li>\n</ol>\n<h3 id=\"1-安装gitment到主题\"><a href=\"#1-安装gitment到主题\" class=\"headerlink\" title=\"1.安装gitment到主题\"></a><strong>1.安装gitment到主题</strong></h3><p>由于有的hexo主题预置gitment模块，有的没有，所以分两种情况来说。</p>\n<ol>\n<li><strong>主题已经集成了gitment模块 看这里～</strong></li>\n</ol>\n<ul>\n<li><p>需要博主自己查看一下自己的主题结构，找到 <strong>themes</strong> 下的 <strong>_config.yml</strong> 文件，在文件中找到gitment模块的相关参数，然后在 <strong>enable</strong> 选项后面写上 <strong>true</strong> 即可完成安装过程。</p>\n<p>如图所示： <img src=\"/2018/10/24/an-zhuang-gitment-ji-chang-jian-wen-ti-jie-jue/gitmentConfig.png\" alt=\"gitmentConfig\"></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>主题没有集成gitment模块 根本配置在这里～</strong></li>\n</ol>\n<ul>\n<li>如果在自己的 <strong>themes</strong> 的 <strong>_config.yml</strong> 中没有看到 <strong>gitment</strong>相关选项，就要自己配置。</li>\n<li><p>这时就要用到gitment作者的安装方法了。前言中说到的两个文件一个css一个js，只要将这两个文件引入自己主题的母板中就完成了安装。由于作者的提供是js文件中需要改动，所以这里要将提供是文件下载下来到自己的博客中，根据自己的文件结构防治css和js文件。然后在模板文件中引用两个文件。</p>\n</li>\n<li><p><a href=\"https://imsun.github.io/gitment/style/default.css\" target=\"_blank\" rel=\"noopener\">css文件下载地址</a></p>\n</li>\n<li><p><a href=\"https://imsun.github.io/gitment/dist/gitment.browser.js\" target=\"_blank\" rel=\"noopener\">js文件下载地址</a></p>\n<pre class=\" language-html\"><code class=\"language-html\"><span class=\"token comment\" spellcheck=\"true\">&lt;!--(将以下添加到模板文件中（这个引用路径是一个例子，根据自己的目录引用)--></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>link</span> <span class=\"token attr-name\">rel</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>stylesheet<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/libs/gitment/default.css<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/libs/gitment/gitment.browser.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n</li>\n</ul>\n<p><em>（注：本质上安装就是在主题模板文件中引入一个css和一个js文件。集成gitment模块的主题只不过是做到了代码分离，让需要配置的参数在_config.yml中统一配置。gitment作者给出的方法是在给没有集成的主题中的根本引入办法。如果你能看懂主题作者的组织结构，那完全可以给自己的主题集成gitment模块。因主题结构不一样我就不详细举例了。）</em></p>\n<h3 id=\"2-注册OAuth-application\"><a href=\"#2-注册OAuth-application\" class=\"headerlink\" title=\"2.注册OAuth application\"></a><strong>2.注册OAuth application</strong></h3><p>因为gitment是利用了github的issue，所以要注册OAuth application，来获取配置参数为接下来的配置做准备。</p>\n<p><a href=\"https://github.com/settings/applications/new\" target=\"_blank\" rel=\"noopener\">点击此处</a>来注册，一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 <a href=\"https://smalbox.club）。\" target=\"_blank\" rel=\"noopener\">https://smalbox.club）。</a></p>\n<p>注册后会给两个字符串 <strong>Client ID</strong> 和 <strong>Client Secret</strong> , 这两个下面配置的时候要用。</p>\n<h3 id=\"3-配置Gitment到hexo主题中\"><a href=\"#3-配置Gitment到hexo主题中\" class=\"headerlink\" title=\"3.配置Gitment到hexo主题中\"></a><strong>3.配置Gitment到hexo主题中</strong></h3><p>同样的，也是一种预置gitment和自己配置分两种来说。</p>\n<ol>\n<li><strong>主题已经集成了gitment模块 看这里～</strong> </li>\n</ol>\n<ul>\n<li><p>只需在 <strong>_config.yml</strong> 中找到刚才开启gitment的那里，下面有四个参数要添加。</p>\n<p>如图所示：<img src=\"/2018/10/24/an-zhuang-gitment-ji-chang-jian-wen-ti-jie-jue/gitmentConfiged.jpeg\" alt=\"gitmentConfiged\"></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>主题没有集成gitment模块 根本配置在这里～</strong></li>\n</ol>\n<ul>\n<li>在刚才添加的母版中继续添加如下代码：</li>\n</ul>\n<pre class=\" language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>container<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n<span class=\"token keyword\">var</span> gitment <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Gitment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  owner<span class=\"token punctuation\">:</span> <span class=\"token string\">'你的 GitHub ID'</span><span class=\"token punctuation\">,</span>\n  repo<span class=\"token punctuation\">:</span> <span class=\"token string\">'存储评论的 repo'</span><span class=\"token punctuation\">,</span>\n  oauth<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    client_id<span class=\"token punctuation\">:</span> <span class=\"token string\">'你的 client ID'</span><span class=\"token punctuation\">,</span>\n    client_secret<span class=\"token punctuation\">:</span> <span class=\"token string\">'你的 client secret'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\ngitment<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<ul>\n<li>将以上的代码中的四个参数按照提示填好即可。</li>\n</ul>\n<h3 id=\"4-初始化评论\"><a href=\"#4-初始化评论\" class=\"headerlink\" title=\"4.初始化评论\"></a><strong>4.初始化评论</strong></h3><p>理论上按照以上配置完发布即可看到评论区了。只不过每一个帖子下面的评论区都要初始化才能开始评论。</p>\n<p>根据gitment作者的说法，只要到用博主的github账号登录后点击初始化就可以使用了。</p>\n<h3 id=\"5-常见问题解决\"><a href=\"#5-常见问题解决\" class=\"headerlink\" title=\"5.常见问题解决\"></a><strong>5.常见问题解决</strong></h3><ul>\n<li>评论点击登录，登录GitHub之后跳转回来的时候不能正常跳回刚才贴纸那页。每次跳到主页。</li>\n</ul>\n<p><strong>解决办法：</strong> 在注册OAuth application时的回调地址有问题，尝试写绑定的域名，而不是用 “https://用户名.github.io”</p>\n<ul>\n<li>报错 “[object ProgressEvent]”</li>\n</ul>\n<p><strong>原因：</strong> 在母版中调用的js文件中，有访问gitment作者的服务器代码，而作者的服务器不好使了。</p>\n<p><strong>解决办法：</strong> 自己搭建一个服务器（需要有一个vps来辅助搭建服务器，当然下面我也会提供一个我搭建好的服务器）</p>\n<ol>\n<li>在服务器中clone作者的服务器源码</li>\n</ol>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> clone https://github.com/SmalBox/gh-oauth-server.git\n</code></pre>\n<ol start=\"2\">\n<li>进入项目，下载依赖，并启动</li>\n</ol>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">nohup</span> <span class=\"token function\">npm</span> start <span class=\"token operator\">&amp;</span>\n</code></pre>\n<p><em>(注：如果运行失败，可能是nodejs没有安装好，请安装nodejs。然后再重新运行命令,如果成功,在项目目录下的nohup.out文件中的最后，会提示正在监听3000端口。这里需要用nginx将证书搞定，用https访问，否则默认http还是会报错。证书的问题我就不啰嗦了，证书参考<a href=\"https://www.bugprogrammer.me/2018/05/19/phpnginxmysql.html#more\" target=\"_blank\" rel=\"noopener\">这个帖子的 11.后续优化 部分</a>,端口转发请参考<a href=\"https://segmentfault.com/a/1190000002797606\" target=\"_blank\" rel=\"noopener\">这个帖子</a>)</em></p>\n<ol start=\"3\">\n<li>替换js文件中的作者服务器为自己服务器</li>\n</ol>\n<p>在作者的js文件中搜索以下字符串：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">https://gh-oauth.imsun.net\n</code></pre>\n<p>将其替换成刚才搭建服务器的地址即可。</p>\n<p><strong>OK大功告成，可以去测试一下了。可以在本站的下面回复评论测试。</strong></p>\n<p><strong>如果有任何问题，可以在下面评论或者通过邮件联系我。</strong></p>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"安装Gitment评论模块-amp-常见问题解决\"><a href=\"#安装Gitment评论模块-amp-常见问题解决\" class=\"headerlink\" title=\"安装Gitment评论模块 &amp; 常见问题解决\"></a>安装Gitment评论模块 &amp; 常见问题解决</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>本文记录了本博客添加gitment评论模块的过程，并对配置过程中碰到的问题与其解决方案作出阐述。<br>因每个hexo选择的主题不一样，所以主题的文件结构会有所不同，具体操作也会有所不同，所以本文也尽可能的写出配置思路，来帮助不同主题的hexo博主配置自己主题的gitment评论模块。</p>\n<p>对gitment的介绍就不多说了，就是利用GitHub的issue来做评论，能同步issue里的留言。具体详细可以去看项目介绍：<a href=\"https://github.com/imsun/gitment\" target=\"_blank\" rel=\"noopener\">Gitment项目地址</a>.</p>\n<blockquote>\n<p>大致描述一下gitment的配置：</p>\n<ul>\n<li>首先是两个配置文件，一个\u001dcss文件一个js文件。gitment的开发者用远程连接的方式将两个文件引入hexo中。但是实际操作中会遇到问题（最后常见问题中会写解决方案），其中的js文件中需要访问作者自己搭建的服务器，但是现在作者的服务器不好使了，会导致全都配置好了，但是报错。所以要下载到本地的自己项目中，然后在项目中自己引用这两个文件（具体操作本文安装部分会写到）。</li>\n</ul>\n</blockquote>\n<ul>\n<li>其次就是由于主题不同，有的主题的作者在开始设计主题的时候就为用户写好了gitment的配置代码，只需用户在主题的_config.yml中开启并填写好配置参数即可。有的主题没有预制好gitment的配置代码，就需要用户自己去在样式模板中添加gitment代码。</li>\n</ul>\n<h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a><strong>概览</strong></h2><ol>\n<li>安装gitment到主题</li>\n<li>注册OAuth application</li>\n<li>配置gitment到hexo主题中</li>\n<li>初始化评论</li>\n<li>常见问题解决</li>\n</ol>\n<h3 id=\"1-安装gitment到主题\"><a href=\"#1-安装gitment到主题\" class=\"headerlink\" title=\"1.安装gitment到主题\"></a><strong>1.安装gitment到主题</strong></h3><p>由于有的hexo主题预置gitment模块，有的没有，所以分两种情况来说。</p>\n<ol>\n<li><strong>主题已经集成了gitment模块 看这里～</strong></li>\n</ol>\n<ul>\n<li><p>需要博主自己查看一下自己的主题结构，找到 <strong>themes</strong> 下的 <strong>_config.yml</strong> 文件，在文件中找到gitment模块的相关参数，然后在 <strong>enable</strong> 选项后面写上 <strong>true</strong> 即可完成安装过程。</p>\n<p>如图所示： <img src=\"/2018/10/24/an-zhuang-gitment-ji-chang-jian-wen-ti-jie-jue/gitmentConfig.png\" alt=\"gitmentConfig\"></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>主题没有集成gitment模块 根本配置在这里～</strong></li>\n</ol>\n<ul>\n<li>如果在自己的 <strong>themes</strong> 的 <strong>_config.yml</strong> 中没有看到 <strong>gitment</strong>相关选项，就要自己配置。</li>\n<li><p>这时就要用到gitment作者的安装方法了。前言中说到的两个文件一个css一个js，只要将这两个文件引入自己主题的母板中就完成了安装。由于作者的提供是js文件中需要改动，所以这里要将提供是文件下载下来到自己的博客中，根据自己的文件结构防治css和js文件。然后在模板文件中引用两个文件。</p>\n</li>\n<li><p><a href=\"https://imsun.github.io/gitment/style/default.css\" target=\"_blank\" rel=\"noopener\">css文件下载地址</a></p>\n</li>\n<li><p><a href=\"https://imsun.github.io/gitment/dist/gitment.browser.js\" target=\"_blank\" rel=\"noopener\">js文件下载地址</a></p>\n<pre><code class=\"html\">&lt;!--(将以下添加到模板文件中（这个引用路径是一个例子，根据自己的目录引用)--&gt;\n\n&lt;link rel=&quot;stylesheet&quot; href=&quot;/libs/gitment/default.css&quot;&gt;\n&lt;script src=&quot;/libs/gitment/gitment.browser.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n</li>\n</ul>\n<p><em>（注：本质上安装就是在主题模板文件中引入一个css和一个js文件。集成gitment模块的主题只不过是做到了代码分离，让需要配置的参数在_config.yml中统一配置。gitment作者给出的方法是在给没有集成的主题中的根本引入办法。如果你能看懂主题作者的组织结构，那完全可以给自己的主题集成gitment模块。因主题结构不一样我就不详细举例了。）</em></p>\n<h3 id=\"2-注册OAuth-application\"><a href=\"#2-注册OAuth-application\" class=\"headerlink\" title=\"2.注册OAuth application\"></a><strong>2.注册OAuth application</strong></h3><p>因为gitment是利用了github的issue，所以要注册OAuth application，来获取配置参数为接下来的配置做准备。</p>\n<p><a href=\"https://github.com/settings/applications/new\" target=\"_blank\" rel=\"noopener\">点击此处</a>来注册，一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 <a href=\"https://smalbox.club）。\" target=\"_blank\" rel=\"noopener\">https://smalbox.club）。</a></p>\n<p>注册后会给两个字符串 <strong>Client ID</strong> 和 <strong>Client Secret</strong> , 这两个下面配置的时候要用。</p>\n<h3 id=\"3-配置Gitment到hexo主题中\"><a href=\"#3-配置Gitment到hexo主题中\" class=\"headerlink\" title=\"3.配置Gitment到hexo主题中\"></a><strong>3.配置Gitment到hexo主题中</strong></h3><p>同样的，也是一种预置gitment和自己配置分两种来说。</p>\n<ol>\n<li><strong>主题已经集成了gitment模块 看这里～</strong> </li>\n</ol>\n<ul>\n<li><p>只需在 <strong>_config.yml</strong> 中找到刚才开启gitment的那里，下面有四个参数要添加。</p>\n<p>如图所示：<img src=\"/2018/10/24/an-zhuang-gitment-ji-chang-jian-wen-ti-jie-jue/gitmentConfiged.jpeg\" alt=\"gitmentConfiged\"></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>主题没有集成gitment模块 根本配置在这里～</strong></li>\n</ol>\n<ul>\n<li>在刚才添加的母版中继续添加如下代码：</li>\n</ul>\n<pre><code class=\"html\">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;\n&lt;script&gt;\nvar gitment = new Gitment({\n  owner: &#39;你的 GitHub ID&#39;,\n  repo: &#39;存储评论的 repo&#39;,\n  oauth: {\n    client_id: &#39;你的 client ID&#39;,\n    client_secret: &#39;你的 client secret&#39;,\n  },\n})\ngitment.render(&#39;container&#39;)\n&lt;/script&gt;\n</code></pre>\n<ul>\n<li>将以上的代码中的四个参数按照提示填好即可。</li>\n</ul>\n<h3 id=\"4-初始化评论\"><a href=\"#4-初始化评论\" class=\"headerlink\" title=\"4.初始化评论\"></a><strong>4.初始化评论</strong></h3><p>理论上按照以上配置完发布即可看到评论区了。只不过每一个帖子下面的评论区都要初始化才能开始评论。</p>\n<p>根据gitment作者的说法，只要到用博主的github账号登录后点击初始化就可以使用了。</p>\n<h3 id=\"5-常见问题解决\"><a href=\"#5-常见问题解决\" class=\"headerlink\" title=\"5.常见问题解决\"></a><strong>5.常见问题解决</strong></h3><ul>\n<li>评论点击登录，登录GitHub之后跳转回来的时候不能正常跳回刚才贴纸那页。每次跳到主页。</li>\n</ul>\n<p><strong>解决办法：</strong> 在注册OAuth application时的回调地址有问题，尝试写绑定的域名，而不是用 “https://用户名.github.io”</p>\n<ul>\n<li>报错 “[object ProgressEvent]”</li>\n</ul>\n<p><strong>原因：</strong> 在母版中调用的js文件中，有访问gitment作者的服务器代码，而作者的服务器不好使了。</p>\n<p><strong>解决办法：</strong> 自己搭建一个服务器（需要有一个vps来辅助搭建服务器，当然下面我也会提供一个我搭建好的服务器）</p>\n<ol>\n<li>在服务器中clone作者的服务器源码</li>\n</ol>\n<pre><code class=\"bash\">git clone https://github.com/SmalBox/gh-oauth-server.git\n</code></pre>\n<ol start=\"2\">\n<li>进入项目，下载依赖，并启动</li>\n</ol>\n<pre><code class=\"bash\">npm install &amp;&amp; nohup npm start &amp;\n</code></pre>\n<p><em>(注：如果运行失败，可能是nodejs没有安装好，请安装nodejs。然后再重新运行命令,如果成功,在项目目录下的nohup.out文件中的最后，会提示正在监听3000端口。这里需要用nginx将证书搞定，用https访问，否则默认http还是会报错。证书的问题我就不啰嗦了，证书参考<a href=\"https://www.bugprogrammer.me/2018/05/19/phpnginxmysql.html#more\" target=\"_blank\" rel=\"noopener\">这个帖子的 11.后续优化 部分</a>,端口转发请参考<a href=\"https://segmentfault.com/a/1190000002797606\" target=\"_blank\" rel=\"noopener\">这个帖子</a>)</em></p>\n<ol start=\"3\">\n<li>替换js文件中的作者服务器为自己服务器</li>\n</ol>\n<p>在作者的js文件中搜索以下字符串：</p>\n<pre><code class=\"bash\">https://gh-oauth.imsun.net\n</code></pre>\n<p>将其替换成刚才搭建服务器的地址即可。</p>\n<p><strong>OK大功告成，可以去测试一下了。可以在本站的下面回复评论测试。</strong></p>\n<p><strong>如果有任何问题，可以在下面评论或者通过邮件联系我。</strong></p>\n"},{"title":"抢救群晖系统简述","author":"SmalBox","cover":false,"top":false,"date":"2019-07-14T03:43:05.000Z","_content":"# 抢救群晖系统简述\n\n## **前言**\n\n群晖（Synology）在接电的时候崩出了火花，导致硬盘短路跪了，系统也莫名跪了。好在组的raid1，有一块硬盘是好的，还能抢救。\n\n抢救的关键是要知道崩了的系统的机型版本，否则引导不起来系统。\n\n   - 抢救思路\n      1. 用**虚拟机**安装一个**同型号**、**同版本**的群晖系统\n      2. 虚拟机进入**PE**，在PE中对刚安装的群晖系统进行备份\n      3. 用PE **U盘** 进入群晖机器，将备份的系统恢复到群晖机器中\n      4. 制作新的群晖**引导U盘**\n\n   - 我的硬件背景\n      - 产品型号：DS3617xs\n      - 系统版本：6.1-15047\n      - 硬盘阵列：raid1\n\n## **软件下载**\n   - **软件清单：**\n      ``` bash\n        ├── DS367xs-15047-6_1-安装包引导\n        │   ├── DS3617xs-15047-安装包\n        │   │   └── DSM_DS3617xs_15047.pat\n        │   └── ds3617_61-引导\n        │       └── synoboot.img\n        ├── PE\n        │   ├── PE镜像\n        │   │   └── Win10PE_Ver.3.6.iso\n        │   └── u盘PE及恢复软件\n        │       ├── ATIH2019.23.3.1.x64.PE.exe\n        │       └── WePE_64_V2.0.exe\n        └── 抢救群晖系统-工具\n            ├── DiskImage_1_6_WinAll_Setup.exe\n            ├── SynologyAssistantSetup-6.0-7319群晖助手.exe\n            ├── chipeasy1.630芯片无忧.exe\n            └── win32_disk_imager启动盘制作工具.zip\n      ```\n   - 所需软件都**分别打包**，可**按需下载**\n   - **下载地址**\n      - 链接: https://pan.baidu.com/s/1rrzoI7m4eZVnSyiKmewmRw \n      - 提取码: ka9b\n\n## **启动前准备**\n\n   1. **创建磁盘**\n      - 管理员权限运行cmd或powershell输入：\n      ``` bash\n        diskpart # 进入diskpart工具\n        create vdisk file=c:\\synoboot.vhd maximum=50 type=expandable # file后路径填一个本机可用路径即可\n        attach vdisk # 选中创建的路径\n        create partition primary # 创建主分区\n      ```\n   2. **引导写入磁盘**\n      - 用Roadkil's Disk Image软件将引导写入1创建的磁盘\n   3. **调整虚拟机bios进入系统**\n      - 打开电源时进入固件，在boot中调整启动项。保存重启进入系统。\n\n## **系统备份**\n\n   1. 加入一个光驱，选择一个PE iso镜像。调整启动项，重启进入PE\n   2. 在PE中用Acronis True Image Home for PE备份系统（2.4g的那个分区）\n\n## **系统还原**\n\n   1. 进入要还原的NAS的PE。用Acronis True Image Home for PE还原系统到对应位置\n\n## **制作U盘引导**\n\n   1. 用ChipGenius先查看U盘的 vid uid\n   2. 格式化U盘，然后用Win32DiskImager将引导刷入U盘\n   3. 修改grub.cfg中 vid uid 的值\n      - 挂载引导盘符\n        - 以管理员权限运行cmd或powershell输入：\n        ``` bash\n            diskpart # 启动diskpart工具\n            list disk #  列出系统中拥有的磁盘\n            select disk 0  # 选择EFI引导分区所在的磁盘，请根据实际情况选择\n            list partition  # 列出所选磁盘拥有的分区\n            select partition 1  # 选择EFI引导分区，类型为系统的分区，就是EFI引导分区\n            set id=ebd0a0a2-b9e5-4433-87c0-68b6b72699c7  # 设置磁盘ID\n            assign letter=p  # 为所选分区分配盘符，请分配空闲盘符\n\n            remove letter=p  # 修改完成后，移除盘符（如果不移除，重启计算机以后，会自动移除）\n        ```\n      - 修改grub.cfg\n         - 以管理员权限运行cmd或powershell输入：\n         ``` bash\n            notepad\n         ```\n         - 在打开的记事本中，点击打开。在跳出的文件管理器中操作efi中的grub.cfg文件。将其中的 vid uid 值改成u盘的值\n\n## **总结**\n\n   - 抢救对机型、系统版本非常严格，如果不对很有可能引导失败\n   - 本文给出了对应机型所需要的工具，如果非本机型，可自行下载更换**引导镜像**、**安装包**，其他步骤不变\n   - 本文是**简述版**，**无图**，*（**抢救过程中有问题，可评论或邮件联系我**）*","source":"_posts/抢救群晖系统简述.md","raw":"---\ntitle: 抢救群晖系统简述\nauthor: SmalBox\ncover: false\ntop: false\ndate: 2019-07-14 11:43:05\ncategories: Linux\ntags:\n  - 群晖Synology\n  - 抢救系统\n---\n# 抢救群晖系统简述\n\n## **前言**\n\n群晖（Synology）在接电的时候崩出了火花，导致硬盘短路跪了，系统也莫名跪了。好在组的raid1，有一块硬盘是好的，还能抢救。\n\n抢救的关键是要知道崩了的系统的机型版本，否则引导不起来系统。\n\n   - 抢救思路\n      1. 用**虚拟机**安装一个**同型号**、**同版本**的群晖系统\n      2. 虚拟机进入**PE**，在PE中对刚安装的群晖系统进行备份\n      3. 用PE **U盘** 进入群晖机器，将备份的系统恢复到群晖机器中\n      4. 制作新的群晖**引导U盘**\n\n   - 我的硬件背景\n      - 产品型号：DS3617xs\n      - 系统版本：6.1-15047\n      - 硬盘阵列：raid1\n\n## **软件下载**\n   - **软件清单：**\n      ``` bash\n        ├── DS367xs-15047-6_1-安装包引导\n        │   ├── DS3617xs-15047-安装包\n        │   │   └── DSM_DS3617xs_15047.pat\n        │   └── ds3617_61-引导\n        │       └── synoboot.img\n        ├── PE\n        │   ├── PE镜像\n        │   │   └── Win10PE_Ver.3.6.iso\n        │   └── u盘PE及恢复软件\n        │       ├── ATIH2019.23.3.1.x64.PE.exe\n        │       └── WePE_64_V2.0.exe\n        └── 抢救群晖系统-工具\n            ├── DiskImage_1_6_WinAll_Setup.exe\n            ├── SynologyAssistantSetup-6.0-7319群晖助手.exe\n            ├── chipeasy1.630芯片无忧.exe\n            └── win32_disk_imager启动盘制作工具.zip\n      ```\n   - 所需软件都**分别打包**，可**按需下载**\n   - **下载地址**\n      - 链接: https://pan.baidu.com/s/1rrzoI7m4eZVnSyiKmewmRw \n      - 提取码: ka9b\n\n## **启动前准备**\n\n   1. **创建磁盘**\n      - 管理员权限运行cmd或powershell输入：\n      ``` bash\n        diskpart # 进入diskpart工具\n        create vdisk file=c:\\synoboot.vhd maximum=50 type=expandable # file后路径填一个本机可用路径即可\n        attach vdisk # 选中创建的路径\n        create partition primary # 创建主分区\n      ```\n   2. **引导写入磁盘**\n      - 用Roadkil's Disk Image软件将引导写入1创建的磁盘\n   3. **调整虚拟机bios进入系统**\n      - 打开电源时进入固件，在boot中调整启动项。保存重启进入系统。\n\n## **系统备份**\n\n   1. 加入一个光驱，选择一个PE iso镜像。调整启动项，重启进入PE\n   2. 在PE中用Acronis True Image Home for PE备份系统（2.4g的那个分区）\n\n## **系统还原**\n\n   1. 进入要还原的NAS的PE。用Acronis True Image Home for PE还原系统到对应位置\n\n## **制作U盘引导**\n\n   1. 用ChipGenius先查看U盘的 vid uid\n   2. 格式化U盘，然后用Win32DiskImager将引导刷入U盘\n   3. 修改grub.cfg中 vid uid 的值\n      - 挂载引导盘符\n        - 以管理员权限运行cmd或powershell输入：\n        ``` bash\n            diskpart # 启动diskpart工具\n            list disk #  列出系统中拥有的磁盘\n            select disk 0  # 选择EFI引导分区所在的磁盘，请根据实际情况选择\n            list partition  # 列出所选磁盘拥有的分区\n            select partition 1  # 选择EFI引导分区，类型为系统的分区，就是EFI引导分区\n            set id=ebd0a0a2-b9e5-4433-87c0-68b6b72699c7  # 设置磁盘ID\n            assign letter=p  # 为所选分区分配盘符，请分配空闲盘符\n\n            remove letter=p  # 修改完成后，移除盘符（如果不移除，重启计算机以后，会自动移除）\n        ```\n      - 修改grub.cfg\n         - 以管理员权限运行cmd或powershell输入：\n         ``` bash\n            notepad\n         ```\n         - 在打开的记事本中，点击打开。在跳出的文件管理器中操作efi中的grub.cfg文件。将其中的 vid uid 值改成u盘的值\n\n## **总结**\n\n   - 抢救对机型、系统版本非常严格，如果不对很有可能引导失败\n   - 本文给出了对应机型所需要的工具，如果非本机型，可自行下载更换**引导镜像**、**安装包**，其他步骤不变\n   - 本文是**简述版**，**无图**，*（**抢救过程中有问题，可评论或邮件联系我**）*","slug":"抢救群晖系统简述","published":1,"updated":"2020-04-04T13:06:36.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptihl000kbsfoya845ses","content":"<h1 id=\"抢救群晖系统简述\"><a href=\"#抢救群晖系统简述\" class=\"headerlink\" title=\"抢救群晖系统简述\"></a>抢救群晖系统简述</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>群晖（Synology）在接电的时候崩出了火花，导致硬盘短路跪了，系统也莫名跪了。好在组的raid1，有一块硬盘是好的，还能抢救。</p>\n<p>抢救的关键是要知道崩了的系统的机型版本，否则引导不起来系统。</p>\n<ul>\n<li><p>抢救思路</p>\n<ol>\n<li>用<strong>虚拟机</strong>安装一个<strong>同型号</strong>、<strong>同版本</strong>的群晖系统</li>\n<li>虚拟机进入<strong>PE</strong>，在PE中对刚安装的群晖系统进行备份</li>\n<li>用PE <strong>U盘</strong> 进入群晖机器，将备份的系统恢复到群晖机器中</li>\n<li>制作新的群晖<strong>引导U盘</strong></li>\n</ol>\n</li>\n<li><p>我的硬件背景</p>\n<ul>\n<li>产品型号：DS3617xs</li>\n<li>系统版本：6.1-15047</li>\n<li>硬盘阵列：raid1</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"软件下载\"><a href=\"#软件下载\" class=\"headerlink\" title=\"软件下载\"></a><strong>软件下载</strong></h2><ul>\n<li><strong>软件清单：</strong><pre class=\" language-bash\"><code class=\"language-bash\">   ├── DS367xs-15047-6_1-安装包引导\n   │   ├── DS3617xs-15047-安装包\n   │   │   └── DSM_DS3617xs_15047.pat\n   │   └── ds3617_61-引导\n   │       └── synoboot.img\n   ├── PE\n   │   ├── PE镜像\n   │   │   └── Win10PE_Ver.3.6.iso\n   │   └── u盘PE及恢复软件\n   │       ├── ATIH2019.23.3.1.x64.PE.exe\n   │       └── WePE_64_V2.0.exe\n   └── 抢救群晖系统-工具\n       ├── DiskImage_1_6_WinAll_Setup.exe\n       ├── SynologyAssistantSetup-6.0-7319群晖助手.exe\n       ├── chipeasy1.630芯片无忧.exe\n       └── win32_disk_imager启动盘制作工具.zip\n</code></pre>\n</li>\n<li>所需软件都<strong>分别打包</strong>，可<strong>按需下载</strong></li>\n<li><strong>下载地址</strong><ul>\n<li>链接: <a href=\"https://pan.baidu.com/s/1rrzoI7m4eZVnSyiKmewmRw\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1rrzoI7m4eZVnSyiKmewmRw</a> </li>\n<li>提取码: ka9b</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"启动前准备\"><a href=\"#启动前准备\" class=\"headerlink\" title=\"启动前准备\"></a><strong>启动前准备</strong></h2><ol>\n<li><strong>创建磁盘</strong><ul>\n<li>管理员权限运行cmd或powershell输入：<pre class=\" language-bash\"><code class=\"language-bash\">diskpart <span class=\"token comment\" spellcheck=\"true\"># 进入diskpart工具</span>\ncreate vdisk file<span class=\"token operator\">=</span>c:\\synoboot.vhd maximum<span class=\"token operator\">=</span>50 type<span class=\"token operator\">=</span>expandable <span class=\"token comment\" spellcheck=\"true\"># file后路径填一个本机可用路径即可</span>\nattach vdisk <span class=\"token comment\" spellcheck=\"true\"># 选中创建的路径</span>\ncreate partition primary <span class=\"token comment\" spellcheck=\"true\"># 创建主分区</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>引导写入磁盘</strong><ul>\n<li>用Roadkil’s Disk Image软件将引导写入1创建的磁盘</li>\n</ul>\n</li>\n<li><strong>调整虚拟机bios进入系统</strong><ul>\n<li>打开电源时进入固件，在boot中调整启动项。保存重启进入系统。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"系统备份\"><a href=\"#系统备份\" class=\"headerlink\" title=\"系统备份\"></a><strong>系统备份</strong></h2><ol>\n<li>加入一个光驱，选择一个PE iso镜像。调整启动项，重启进入PE</li>\n<li>在PE中用Acronis True Image Home for PE备份系统（2.4g的那个分区）</li>\n</ol>\n<h2 id=\"系统还原\"><a href=\"#系统还原\" class=\"headerlink\" title=\"系统还原\"></a><strong>系统还原</strong></h2><ol>\n<li>进入要还原的NAS的PE。用Acronis True Image Home for PE还原系统到对应位置</li>\n</ol>\n<h2 id=\"制作U盘引导\"><a href=\"#制作U盘引导\" class=\"headerlink\" title=\"制作U盘引导\"></a><strong>制作U盘引导</strong></h2><ol>\n<li>用ChipGenius先查看U盘的 vid uid</li>\n<li>格式化U盘，然后用Win32DiskImager将引导刷入U盘</li>\n<li><p>修改grub.cfg中 vid uid 的值</p>\n<ul>\n<li><p>挂载引导盘符</p>\n<ul>\n<li><p>以管理员权限运行cmd或powershell输入：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">  diskpart <span class=\"token comment\" spellcheck=\"true\"># 启动diskpart工具</span>\n  list disk <span class=\"token comment\" spellcheck=\"true\">#  列出系统中拥有的磁盘</span>\n  <span class=\"token keyword\">select</span> disk 0  <span class=\"token comment\" spellcheck=\"true\"># 选择EFI引导分区所在的磁盘，请根据实际情况选择</span>\n  list partition  <span class=\"token comment\" spellcheck=\"true\"># 列出所选磁盘拥有的分区</span>\n  <span class=\"token keyword\">select</span> partition 1  <span class=\"token comment\" spellcheck=\"true\"># 选择EFI引导分区，类型为系统的分区，就是EFI引导分区</span>\n  <span class=\"token keyword\">set</span> id<span class=\"token operator\">=</span>ebd0a0a2-b9e5-4433-87c0-68b6b72699c7  <span class=\"token comment\" spellcheck=\"true\"># 设置磁盘ID</span>\n  assign letter<span class=\"token operator\">=</span>p  <span class=\"token comment\" spellcheck=\"true\"># 为所选分区分配盘符，请分配空闲盘符</span>\n\n  remove letter<span class=\"token operator\">=</span>p  <span class=\"token comment\" spellcheck=\"true\"># 修改完成后，移除盘符（如果不移除，重启计算机以后，会自动移除）</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li>修改grub.cfg<ul>\n<li>以管理员权限运行cmd或powershell输入：<pre class=\" language-bash\"><code class=\"language-bash\"> notepad\n</code></pre>\n</li>\n<li>在打开的记事本中，点击打开。在跳出的文件管理器中操作efi中的grub.cfg文件。将其中的 vid uid 值改成u盘的值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><ul>\n<li>抢救对机型、系统版本非常严格，如果不对很有可能引导失败</li>\n<li>本文给出了对应机型所需要的工具，如果非本机型，可自行下载更换<strong>引导镜像</strong>、<strong>安装包</strong>，其他步骤不变</li>\n<li>本文是<strong>简述版</strong>，<strong>无图</strong>，<em>（<strong>抢救过程中有问题，可评论或邮件联系我</strong>）</em></li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"抢救群晖系统简述\"><a href=\"#抢救群晖系统简述\" class=\"headerlink\" title=\"抢救群晖系统简述\"></a>抢救群晖系统简述</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>群晖（Synology）在接电的时候崩出了火花，导致硬盘短路跪了，系统也莫名跪了。好在组的raid1，有一块硬盘是好的，还能抢救。</p>\n<p>抢救的关键是要知道崩了的系统的机型版本，否则引导不起来系统。</p>\n<ul>\n<li><p>抢救思路</p>\n<ol>\n<li>用<strong>虚拟机</strong>安装一个<strong>同型号</strong>、<strong>同版本</strong>的群晖系统</li>\n<li>虚拟机进入<strong>PE</strong>，在PE中对刚安装的群晖系统进行备份</li>\n<li>用PE <strong>U盘</strong> 进入群晖机器，将备份的系统恢复到群晖机器中</li>\n<li>制作新的群晖<strong>引导U盘</strong></li>\n</ol>\n</li>\n<li><p>我的硬件背景</p>\n<ul>\n<li>产品型号：DS3617xs</li>\n<li>系统版本：6.1-15047</li>\n<li>硬盘阵列：raid1</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"软件下载\"><a href=\"#软件下载\" class=\"headerlink\" title=\"软件下载\"></a><strong>软件下载</strong></h2><ul>\n<li><strong>软件清单：</strong><pre><code class=\"bash\">   ├── DS367xs-15047-6_1-安装包引导\n   │   ├── DS3617xs-15047-安装包\n   │   │   └── DSM_DS3617xs_15047.pat\n   │   └── ds3617_61-引导\n   │       └── synoboot.img\n   ├── PE\n   │   ├── PE镜像\n   │   │   └── Win10PE_Ver.3.6.iso\n   │   └── u盘PE及恢复软件\n   │       ├── ATIH2019.23.3.1.x64.PE.exe\n   │       └── WePE_64_V2.0.exe\n   └── 抢救群晖系统-工具\n       ├── DiskImage_1_6_WinAll_Setup.exe\n       ├── SynologyAssistantSetup-6.0-7319群晖助手.exe\n       ├── chipeasy1.630芯片无忧.exe\n       └── win32_disk_imager启动盘制作工具.zip\n</code></pre>\n</li>\n<li>所需软件都<strong>分别打包</strong>，可<strong>按需下载</strong></li>\n<li><strong>下载地址</strong><ul>\n<li>链接: <a href=\"https://pan.baidu.com/s/1rrzoI7m4eZVnSyiKmewmRw\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1rrzoI7m4eZVnSyiKmewmRw</a> </li>\n<li>提取码: ka9b</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"启动前准备\"><a href=\"#启动前准备\" class=\"headerlink\" title=\"启动前准备\"></a><strong>启动前准备</strong></h2><ol>\n<li><strong>创建磁盘</strong><ul>\n<li>管理员权限运行cmd或powershell输入：<pre><code class=\"bash\">diskpart # 进入diskpart工具\ncreate vdisk file=c:\\synoboot.vhd maximum=50 type=expandable # file后路径填一个本机可用路径即可\nattach vdisk # 选中创建的路径\ncreate partition primary # 创建主分区\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>引导写入磁盘</strong><ul>\n<li>用Roadkil’s Disk Image软件将引导写入1创建的磁盘</li>\n</ul>\n</li>\n<li><strong>调整虚拟机bios进入系统</strong><ul>\n<li>打开电源时进入固件，在boot中调整启动项。保存重启进入系统。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"系统备份\"><a href=\"#系统备份\" class=\"headerlink\" title=\"系统备份\"></a><strong>系统备份</strong></h2><ol>\n<li>加入一个光驱，选择一个PE iso镜像。调整启动项，重启进入PE</li>\n<li>在PE中用Acronis True Image Home for PE备份系统（2.4g的那个分区）</li>\n</ol>\n<h2 id=\"系统还原\"><a href=\"#系统还原\" class=\"headerlink\" title=\"系统还原\"></a><strong>系统还原</strong></h2><ol>\n<li>进入要还原的NAS的PE。用Acronis True Image Home for PE还原系统到对应位置</li>\n</ol>\n<h2 id=\"制作U盘引导\"><a href=\"#制作U盘引导\" class=\"headerlink\" title=\"制作U盘引导\"></a><strong>制作U盘引导</strong></h2><ol>\n<li>用ChipGenius先查看U盘的 vid uid</li>\n<li>格式化U盘，然后用Win32DiskImager将引导刷入U盘</li>\n<li><p>修改grub.cfg中 vid uid 的值</p>\n<ul>\n<li><p>挂载引导盘符</p>\n<ul>\n<li><p>以管理员权限运行cmd或powershell输入：</p>\n<pre><code class=\"bash\">  diskpart # 启动diskpart工具\n  list disk #  列出系统中拥有的磁盘\n  select disk 0  # 选择EFI引导分区所在的磁盘，请根据实际情况选择\n  list partition  # 列出所选磁盘拥有的分区\n  select partition 1  # 选择EFI引导分区，类型为系统的分区，就是EFI引导分区\n  set id=ebd0a0a2-b9e5-4433-87c0-68b6b72699c7  # 设置磁盘ID\n  assign letter=p  # 为所选分区分配盘符，请分配空闲盘符\n\n  remove letter=p  # 修改完成后，移除盘符（如果不移除，重启计算机以后，会自动移除）\n</code></pre>\n</li>\n</ul>\n</li>\n<li>修改grub.cfg<ul>\n<li>以管理员权限运行cmd或powershell输入：<pre><code class=\"bash\"> notepad\n</code></pre>\n</li>\n<li>在打开的记事本中，点击打开。在跳出的文件管理器中操作efi中的grub.cfg文件。将其中的 vid uid 值改成u盘的值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><ul>\n<li>抢救对机型、系统版本非常严格，如果不对很有可能引导失败</li>\n<li>本文给出了对应机型所需要的工具，如果非本机型，可自行下载更换<strong>引导镜像</strong>、<strong>安装包</strong>，其他步骤不变</li>\n<li>本文是<strong>简述版</strong>，<strong>无图</strong>，<em>（<strong>抢救过程中有问题，可评论或邮件联系我</strong>）</em></li>\n</ul>\n"},{"title":"笔记本(K680e)改侧键开机","date":"2019-04-23T09:52:57.000Z","author":"SmalBox","top":false,"_content":"# 笔记本(K680e)改侧键开机\n\n## **前言**\n\n想把神船本当主机用，无奈开机键在本子C面，必须要打开盖子才能开机，实在是太麻烦。于是准备将开机键改装到本子的侧面，这样就能实现在合着盖子的情况下，按侧面的按钮开机，让神船本成为移动主机。\n\n   - **改装思路**\n     1. 本子的开机键附近有一个**安全锁孔**，可以利用他的空间做开机按钮\n     2. 用万用表找到开机键要**短接**的两个触点\n     3. 将触点**用导线引出**，加装一个开关做外接开关\n     4. 做一个**开关按键**\n     5. 用**热熔胶**固定开关\n     6. **理线**还原机器\n\n## **成品**\n\n   - 先看一下成品吧\n      ![finishedProduct](finishedProduct.jpg)\n   - 图中**白色按钮**就是新的**侧开关键**，使用方法和本机开关一样，点击开机，长按断电关机。\n\n## **过程**\n\n   1. 根据改装思路找到**安全锁孔**，如图：\n     ![safeHole](safeHole.jpg)\n     ![safeHoleInner](safeHoleInner.jpg)\n\n   2. 拆机，找到**开机键**的小开关\n      - 开关有**四个**触角接到PCB板上，*（这里用**万用表的电阻挡测量**其中两个触角，找到接上触点没有偏转，但是按下开关有偏转的两个触点，我的是**对角线**的两个触点，可以先试试）*\n      - 根据找到的**触点**，用导线将两个触点接出来。*（因为触点太小，所以焊锡很难接的牢固，下图看到我接的很丑，就是因为很难接牢，重复了好多次。最后还是用了101胶点了两下确定牢固）*\n      - **下图是接好的样子：**\n      ![weldButton](weldButton.jpg)\n\n   3. 找一个**开关**\n      - 手头上有一个坏掉的鼠标，就想着把鼠标的**按键开关**做开机开关\n      - **如图这个绿色鼠标开关：**\n         ![mouse](mouse.jpg)\n      - 由于这个开关有三个脚，所以用万用表的点阻挡测试开关那两个脚是需要的。原理同测试本子开关一样，**连接上表不转，按住开关，表转，说明这俩个脚就是要用的引脚**\n      - **如图将两个引脚连接上：**\n         ![mouseButton](mouseButton.jpg)\n\n   4. 做一个**按钮**\n      - 由于我手里有3D打印其他东西的废料，所以就就地取材，直接用电烙铁将它切成要用的形状。\n      - 当然如果有别的成块的塑料之类的东西也可以尝试。\n      - 具体方法是将**电烙铁的头**卸下，换上**美工刀**的一段**刀片**，给电烙铁通电加热，将塑料切所要的形状，最后给按钮烫出一个**小底托**即可。\n      - *（**可以用任何别的东西代替，我也可以提供3D打印的按钮，这里我图快，就凑合了一个，没有打印**）*\n      - *（**注意！！！长度控制在放到孔中基本上和机器外边缘平齐，防止误触！！！**）*\n      - **按钮如图：**\n         ![button](button.jpg)\n\n   5. 将按钮装进**安全孔**\n      - **如图将按钮装进安全孔的样子：**\n         - 外部\n            ![safeHoleButton](safeHoleButton.jpg)\n            ![safeHoleButton2](safeHoleButton2.jpg)\n         - 内部\n            ![safeHoleButtonInner](safeHoleButtonInner.jpg)\n\n   6. 将**开关**装进**安全孔**\n      - 先将鼠标上拆下来的开关放进去看看大小位置，*（**注意！！！按钮不要长出机器边缘，否则容易误触**）*\n      - **如图：**\n         ![clickButton](clickButton.jpg)\n      - 用热熔枪将开关固定到合适的位置，*（**注意不要将活动的外面按钮粘住**）*\n      - **如图：**\n         ![holdClickButton](holdClickButton.jpg)\n\n   7. **理线**\n      - 这个就根据机型内部具体情况进行理线了，大多数机器内部都还是有一定空隙，可以将线藏进去。\n\n   8. **扣盖子还原**\n      - 这部分因机型而异了。\n      - 我在还原的时候发现我占用了一个侧边的螺丝孔，所以边缘的一个螺丝上不了了，但是只要理线合理，缝隙还是可以接受的。\n      - 因为占用的是安全锁孔，所以盖子上肯定有一个塑料挡着，这时就需要将其多余的地方用镊子掐掉，掐掉的是非受力点，所以对本子是没有他打损伤的。外观是完全看不到的。\n\n## **总结**\n\n  - **优点**\n    1. 可以**合盖开机**\n    2. **手感清脆**，取决于找到的开关\n\n  - **缺点**\n    1. 占用了一个**安全锁**位置\n    2. 占用了一个边角**螺丝位**\n    3. 原开机按钮失灵了（可能是点胶的时候粘住了），好在原来的按钮也不好用，失灵了也还好，毕竟**侧键更好用**。\n\n  - 借鉴神船本的改装经验，可以给**其他本子**改装侧边开机键。一般笔记本中的空隙还是可以容纳得下引出来的线的。\n  - 如果可以淘到**更小的开关**，就可以不破环或者较少对本子的破坏完成改造。\n  - 按钮可以用其他东西替代，如果能买到类似安全锁孔的按钮那就是最完美的了。实在没有，用3d打印机打印也是可以的，我这回着急弄，就没有打印，直接切的料。*（**如果有需要可以邮箱联系我定制3D打印开关**）*\n","source":"_posts/笔记本-K680e-改侧键开机.md","raw":"---\ntitle: 笔记本(K680e)改侧键开机\ndate: 2019-04-23 17:52:57\nauthor: SmalBox\ncategories: DIY\ntop: false\ntags:\n  - 笔记本\n  - diy\n  - 改侧开机键\n---\n# 笔记本(K680e)改侧键开机\n\n## **前言**\n\n想把神船本当主机用，无奈开机键在本子C面，必须要打开盖子才能开机，实在是太麻烦。于是准备将开机键改装到本子的侧面，这样就能实现在合着盖子的情况下，按侧面的按钮开机，让神船本成为移动主机。\n\n   - **改装思路**\n     1. 本子的开机键附近有一个**安全锁孔**，可以利用他的空间做开机按钮\n     2. 用万用表找到开机键要**短接**的两个触点\n     3. 将触点**用导线引出**，加装一个开关做外接开关\n     4. 做一个**开关按键**\n     5. 用**热熔胶**固定开关\n     6. **理线**还原机器\n\n## **成品**\n\n   - 先看一下成品吧\n      ![finishedProduct](finishedProduct.jpg)\n   - 图中**白色按钮**就是新的**侧开关键**，使用方法和本机开关一样，点击开机，长按断电关机。\n\n## **过程**\n\n   1. 根据改装思路找到**安全锁孔**，如图：\n     ![safeHole](safeHole.jpg)\n     ![safeHoleInner](safeHoleInner.jpg)\n\n   2. 拆机，找到**开机键**的小开关\n      - 开关有**四个**触角接到PCB板上，*（这里用**万用表的电阻挡测量**其中两个触角，找到接上触点没有偏转，但是按下开关有偏转的两个触点，我的是**对角线**的两个触点，可以先试试）*\n      - 根据找到的**触点**，用导线将两个触点接出来。*（因为触点太小，所以焊锡很难接的牢固，下图看到我接的很丑，就是因为很难接牢，重复了好多次。最后还是用了101胶点了两下确定牢固）*\n      - **下图是接好的样子：**\n      ![weldButton](weldButton.jpg)\n\n   3. 找一个**开关**\n      - 手头上有一个坏掉的鼠标，就想着把鼠标的**按键开关**做开机开关\n      - **如图这个绿色鼠标开关：**\n         ![mouse](mouse.jpg)\n      - 由于这个开关有三个脚，所以用万用表的点阻挡测试开关那两个脚是需要的。原理同测试本子开关一样，**连接上表不转，按住开关，表转，说明这俩个脚就是要用的引脚**\n      - **如图将两个引脚连接上：**\n         ![mouseButton](mouseButton.jpg)\n\n   4. 做一个**按钮**\n      - 由于我手里有3D打印其他东西的废料，所以就就地取材，直接用电烙铁将它切成要用的形状。\n      - 当然如果有别的成块的塑料之类的东西也可以尝试。\n      - 具体方法是将**电烙铁的头**卸下，换上**美工刀**的一段**刀片**，给电烙铁通电加热，将塑料切所要的形状，最后给按钮烫出一个**小底托**即可。\n      - *（**可以用任何别的东西代替，我也可以提供3D打印的按钮，这里我图快，就凑合了一个，没有打印**）*\n      - *（**注意！！！长度控制在放到孔中基本上和机器外边缘平齐，防止误触！！！**）*\n      - **按钮如图：**\n         ![button](button.jpg)\n\n   5. 将按钮装进**安全孔**\n      - **如图将按钮装进安全孔的样子：**\n         - 外部\n            ![safeHoleButton](safeHoleButton.jpg)\n            ![safeHoleButton2](safeHoleButton2.jpg)\n         - 内部\n            ![safeHoleButtonInner](safeHoleButtonInner.jpg)\n\n   6. 将**开关**装进**安全孔**\n      - 先将鼠标上拆下来的开关放进去看看大小位置，*（**注意！！！按钮不要长出机器边缘，否则容易误触**）*\n      - **如图：**\n         ![clickButton](clickButton.jpg)\n      - 用热熔枪将开关固定到合适的位置，*（**注意不要将活动的外面按钮粘住**）*\n      - **如图：**\n         ![holdClickButton](holdClickButton.jpg)\n\n   7. **理线**\n      - 这个就根据机型内部具体情况进行理线了，大多数机器内部都还是有一定空隙，可以将线藏进去。\n\n   8. **扣盖子还原**\n      - 这部分因机型而异了。\n      - 我在还原的时候发现我占用了一个侧边的螺丝孔，所以边缘的一个螺丝上不了了，但是只要理线合理，缝隙还是可以接受的。\n      - 因为占用的是安全锁孔，所以盖子上肯定有一个塑料挡着，这时就需要将其多余的地方用镊子掐掉，掐掉的是非受力点，所以对本子是没有他打损伤的。外观是完全看不到的。\n\n## **总结**\n\n  - **优点**\n    1. 可以**合盖开机**\n    2. **手感清脆**，取决于找到的开关\n\n  - **缺点**\n    1. 占用了一个**安全锁**位置\n    2. 占用了一个边角**螺丝位**\n    3. 原开机按钮失灵了（可能是点胶的时候粘住了），好在原来的按钮也不好用，失灵了也还好，毕竟**侧键更好用**。\n\n  - 借鉴神船本的改装经验，可以给**其他本子**改装侧边开机键。一般笔记本中的空隙还是可以容纳得下引出来的线的。\n  - 如果可以淘到**更小的开关**，就可以不破环或者较少对本子的破坏完成改造。\n  - 按钮可以用其他东西替代，如果能买到类似安全锁孔的按钮那就是最完美的了。实在没有，用3d打印机打印也是可以的，我这回着急弄，就没有打印，直接切的料。*（**如果有需要可以邮箱联系我定制3D打印开关**）*\n","slug":"笔记本-K680e-改侧键开机","published":1,"updated":"2019-11-24T16:25:24.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptiho000pbsfo1ywgrbyo","content":"<h1 id=\"笔记本-K680e-改侧键开机\"><a href=\"#笔记本-K680e-改侧键开机\" class=\"headerlink\" title=\"笔记本(K680e)改侧键开机\"></a>笔记本(K680e)改侧键开机</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>想把神船本当主机用，无奈开机键在本子C面，必须要打开盖子才能开机，实在是太麻烦。于是准备将开机键改装到本子的侧面，这样就能实现在合着盖子的情况下，按侧面的按钮开机，让神船本成为移动主机。</p>\n<ul>\n<li><strong>改装思路</strong><ol>\n<li>本子的开机键附近有一个<strong>安全锁孔</strong>，可以利用他的空间做开机按钮</li>\n<li>用万用表找到开机键要<strong>短接</strong>的两个触点</li>\n<li>将触点<strong>用导线引出</strong>，加装一个开关做外接开关</li>\n<li>做一个<strong>开关按键</strong></li>\n<li>用<strong>热熔胶</strong>固定开关</li>\n<li><strong>理线</strong>还原机器</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"成品\"><a href=\"#成品\" class=\"headerlink\" title=\"成品\"></a><strong>成品</strong></h2><ul>\n<li>先看一下成品吧<br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/finishedProduct.jpg\" alt=\"finishedProduct\"></li>\n<li>图中<strong>白色按钮</strong>就是新的<strong>侧开关键</strong>，使用方法和本机开关一样，点击开机，长按断电关机。</li>\n</ul>\n<h2 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a><strong>过程</strong></h2><ol>\n<li><p>根据改装思路找到<strong>安全锁孔</strong>，如图：<br><img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHole.jpg\" alt=\"safeHole\"><br><img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHoleInner.jpg\" alt=\"safeHoleInner\"></p>\n</li>\n<li><p>拆机，找到<strong>开机键</strong>的小开关</p>\n<ul>\n<li>开关有<strong>四个</strong>触角接到PCB板上，<em>（这里用<strong>万用表的电阻挡测量</strong>其中两个触角，找到接上触点没有偏转，但是按下开关有偏转的两个触点，我的是<strong>对角线</strong>的两个触点，可以先试试）</em></li>\n<li>根据找到的<strong>触点</strong>，用导线将两个触点接出来。<em>（因为触点太小，所以焊锡很难接的牢固，下图看到我接的很丑，就是因为很难接牢，重复了好多次。最后还是用了101胶点了两下确定牢固）</em></li>\n<li><strong>下图是接好的样子：</strong><br><img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/weldButton.jpg\" alt=\"weldButton\"></li>\n</ul>\n</li>\n<li><p>找一个<strong>开关</strong></p>\n<ul>\n<li>手头上有一个坏掉的鼠标，就想着把鼠标的<strong>按键开关</strong>做开机开关</li>\n<li><strong>如图这个绿色鼠标开关：</strong><br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/mouse.jpg\" alt=\"mouse\"></li>\n<li>由于这个开关有三个脚，所以用万用表的点阻挡测试开关那两个脚是需要的。原理同测试本子开关一样，<strong>连接上表不转，按住开关，表转，说明这俩个脚就是要用的引脚</strong></li>\n<li><strong>如图将两个引脚连接上：</strong><br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/mouseButton.jpg\" alt=\"mouseButton\"></li>\n</ul>\n</li>\n<li><p>做一个<strong>按钮</strong></p>\n<ul>\n<li>由于我手里有3D打印其他东西的废料，所以就就地取材，直接用电烙铁将它切成要用的形状。</li>\n<li>当然如果有别的成块的塑料之类的东西也可以尝试。</li>\n<li>具体方法是将<strong>电烙铁的头</strong>卸下，换上<strong>美工刀</strong>的一段<strong>刀片</strong>，给电烙铁通电加热，将塑料切所要的形状，最后给按钮烫出一个<strong>小底托</strong>即可。</li>\n<li><em>（<strong>可以用任何别的东西代替，我也可以提供3D打印的按钮，这里我图快，就凑合了一个，没有打印</strong>）</em></li>\n<li><em>（<strong>注意！！！长度控制在放到孔中基本上和机器外边缘平齐，防止误触！！！</strong>）</em></li>\n<li><strong>按钮如图：</strong><br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/button.jpg\" alt=\"button\"></li>\n</ul>\n</li>\n<li><p>将按钮装进<strong>安全孔</strong></p>\n<ul>\n<li><strong>如图将按钮装进安全孔的样子：</strong><ul>\n<li>外部<br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHoleButton.jpg\" alt=\"safeHoleButton\"><br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHoleButton2.jpg\" alt=\"safeHoleButton2\"></li>\n<li>内部<br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHoleButtonInner.jpg\" alt=\"safeHoleButtonInner\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>将<strong>开关</strong>装进<strong>安全孔</strong></p>\n<ul>\n<li>先将鼠标上拆下来的开关放进去看看大小位置，<em>（<strong>注意！！！按钮不要长出机器边缘，否则容易误触</strong>）</em></li>\n<li><strong>如图：</strong><br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/clickButton.jpg\" alt=\"clickButton\"></li>\n<li>用热熔枪将开关固定到合适的位置，<em>（<strong>注意不要将活动的外面按钮粘住</strong>）</em></li>\n<li><strong>如图：</strong><br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/holdClickButton.jpg\" alt=\"holdClickButton\"></li>\n</ul>\n</li>\n<li><p><strong>理线</strong></p>\n<ul>\n<li>这个就根据机型内部具体情况进行理线了，大多数机器内部都还是有一定空隙，可以将线藏进去。</li>\n</ul>\n</li>\n<li><p><strong>扣盖子还原</strong></p>\n<ul>\n<li>这部分因机型而异了。</li>\n<li>我在还原的时候发现我占用了一个侧边的螺丝孔，所以边缘的一个螺丝上不了了，但是只要理线合理，缝隙还是可以接受的。</li>\n<li>因为占用的是安全锁孔，所以盖子上肯定有一个塑料挡着，这时就需要将其多余的地方用镊子掐掉，掐掉的是非受力点，所以对本子是没有他打损伤的。外观是完全看不到的。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><ul>\n<li><p><strong>优点</strong></p>\n<ol>\n<li>可以<strong>合盖开机</strong></li>\n<li><strong>手感清脆</strong>，取决于找到的开关</li>\n</ol>\n</li>\n<li><p><strong>缺点</strong></p>\n<ol>\n<li>占用了一个<strong>安全锁</strong>位置</li>\n<li>占用了一个边角<strong>螺丝位</strong></li>\n<li>原开机按钮失灵了（可能是点胶的时候粘住了），好在原来的按钮也不好用，失灵了也还好，毕竟<strong>侧键更好用</strong>。</li>\n</ol>\n</li>\n<li><p>借鉴神船本的改装经验，可以给<strong>其他本子</strong>改装侧边开机键。一般笔记本中的空隙还是可以容纳得下引出来的线的。</p>\n</li>\n<li>如果可以淘到<strong>更小的开关</strong>，就可以不破环或者较少对本子的破坏完成改造。</li>\n<li>按钮可以用其他东西替代，如果能买到类似安全锁孔的按钮那就是最完美的了。实在没有，用3d打印机打印也是可以的，我这回着急弄，就没有打印，直接切的料。<em>（<strong>如果有需要可以邮箱联系我定制3D打印开关</strong>）</em></li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"笔记本-K680e-改侧键开机\"><a href=\"#笔记本-K680e-改侧键开机\" class=\"headerlink\" title=\"笔记本(K680e)改侧键开机\"></a>笔记本(K680e)改侧键开机</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>想把神船本当主机用，无奈开机键在本子C面，必须要打开盖子才能开机，实在是太麻烦。于是准备将开机键改装到本子的侧面，这样就能实现在合着盖子的情况下，按侧面的按钮开机，让神船本成为移动主机。</p>\n<ul>\n<li><strong>改装思路</strong><ol>\n<li>本子的开机键附近有一个<strong>安全锁孔</strong>，可以利用他的空间做开机按钮</li>\n<li>用万用表找到开机键要<strong>短接</strong>的两个触点</li>\n<li>将触点<strong>用导线引出</strong>，加装一个开关做外接开关</li>\n<li>做一个<strong>开关按键</strong></li>\n<li>用<strong>热熔胶</strong>固定开关</li>\n<li><strong>理线</strong>还原机器</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"成品\"><a href=\"#成品\" class=\"headerlink\" title=\"成品\"></a><strong>成品</strong></h2><ul>\n<li>先看一下成品吧<br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/finishedProduct.jpg\" alt=\"finishedProduct\"></li>\n<li>图中<strong>白色按钮</strong>就是新的<strong>侧开关键</strong>，使用方法和本机开关一样，点击开机，长按断电关机。</li>\n</ul>\n<h2 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a><strong>过程</strong></h2><ol>\n<li><p>根据改装思路找到<strong>安全锁孔</strong>，如图：<br><img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHole.jpg\" alt=\"safeHole\"><br><img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHoleInner.jpg\" alt=\"safeHoleInner\"></p>\n</li>\n<li><p>拆机，找到<strong>开机键</strong>的小开关</p>\n<ul>\n<li>开关有<strong>四个</strong>触角接到PCB板上，<em>（这里用<strong>万用表的电阻挡测量</strong>其中两个触角，找到接上触点没有偏转，但是按下开关有偏转的两个触点，我的是<strong>对角线</strong>的两个触点，可以先试试）</em></li>\n<li>根据找到的<strong>触点</strong>，用导线将两个触点接出来。<em>（因为触点太小，所以焊锡很难接的牢固，下图看到我接的很丑，就是因为很难接牢，重复了好多次。最后还是用了101胶点了两下确定牢固）</em></li>\n<li><strong>下图是接好的样子：</strong><br><img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/weldButton.jpg\" alt=\"weldButton\"></li>\n</ul>\n</li>\n<li><p>找一个<strong>开关</strong></p>\n<ul>\n<li>手头上有一个坏掉的鼠标，就想着把鼠标的<strong>按键开关</strong>做开机开关</li>\n<li><strong>如图这个绿色鼠标开关：</strong><br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/mouse.jpg\" alt=\"mouse\"></li>\n<li>由于这个开关有三个脚，所以用万用表的点阻挡测试开关那两个脚是需要的。原理同测试本子开关一样，<strong>连接上表不转，按住开关，表转，说明这俩个脚就是要用的引脚</strong></li>\n<li><strong>如图将两个引脚连接上：</strong><br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/mouseButton.jpg\" alt=\"mouseButton\"></li>\n</ul>\n</li>\n<li><p>做一个<strong>按钮</strong></p>\n<ul>\n<li>由于我手里有3D打印其他东西的废料，所以就就地取材，直接用电烙铁将它切成要用的形状。</li>\n<li>当然如果有别的成块的塑料之类的东西也可以尝试。</li>\n<li>具体方法是将<strong>电烙铁的头</strong>卸下，换上<strong>美工刀</strong>的一段<strong>刀片</strong>，给电烙铁通电加热，将塑料切所要的形状，最后给按钮烫出一个<strong>小底托</strong>即可。</li>\n<li><em>（<strong>可以用任何别的东西代替，我也可以提供3D打印的按钮，这里我图快，就凑合了一个，没有打印</strong>）</em></li>\n<li><em>（<strong>注意！！！长度控制在放到孔中基本上和机器外边缘平齐，防止误触！！！</strong>）</em></li>\n<li><strong>按钮如图：</strong><br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/button.jpg\" alt=\"button\"></li>\n</ul>\n</li>\n<li><p>将按钮装进<strong>安全孔</strong></p>\n<ul>\n<li><strong>如图将按钮装进安全孔的样子：</strong><ul>\n<li>外部<br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHoleButton.jpg\" alt=\"safeHoleButton\"><br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHoleButton2.jpg\" alt=\"safeHoleButton2\"></li>\n<li>内部<br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/safeHoleButtonInner.jpg\" alt=\"safeHoleButtonInner\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>将<strong>开关</strong>装进<strong>安全孔</strong></p>\n<ul>\n<li>先将鼠标上拆下来的开关放进去看看大小位置，<em>（<strong>注意！！！按钮不要长出机器边缘，否则容易误触</strong>）</em></li>\n<li><strong>如图：</strong><br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/clickButton.jpg\" alt=\"clickButton\"></li>\n<li>用热熔枪将开关固定到合适的位置，<em>（<strong>注意不要将活动的外面按钮粘住</strong>）</em></li>\n<li><strong>如图：</strong><br> <img src=\"/2019/04/23/bi-ji-ben-k680e-gai-ce-jian-kai-ji/holdClickButton.jpg\" alt=\"holdClickButton\"></li>\n</ul>\n</li>\n<li><p><strong>理线</strong></p>\n<ul>\n<li>这个就根据机型内部具体情况进行理线了，大多数机器内部都还是有一定空隙，可以将线藏进去。</li>\n</ul>\n</li>\n<li><p><strong>扣盖子还原</strong></p>\n<ul>\n<li>这部分因机型而异了。</li>\n<li>我在还原的时候发现我占用了一个侧边的螺丝孔，所以边缘的一个螺丝上不了了，但是只要理线合理，缝隙还是可以接受的。</li>\n<li>因为占用的是安全锁孔，所以盖子上肯定有一个塑料挡着，这时就需要将其多余的地方用镊子掐掉，掐掉的是非受力点，所以对本子是没有他打损伤的。外观是完全看不到的。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><ul>\n<li><p><strong>优点</strong></p>\n<ol>\n<li>可以<strong>合盖开机</strong></li>\n<li><strong>手感清脆</strong>，取决于找到的开关</li>\n</ol>\n</li>\n<li><p><strong>缺点</strong></p>\n<ol>\n<li>占用了一个<strong>安全锁</strong>位置</li>\n<li>占用了一个边角<strong>螺丝位</strong></li>\n<li>原开机按钮失灵了（可能是点胶的时候粘住了），好在原来的按钮也不好用，失灵了也还好，毕竟<strong>侧键更好用</strong>。</li>\n</ol>\n</li>\n<li><p>借鉴神船本的改装经验，可以给<strong>其他本子</strong>改装侧边开机键。一般笔记本中的空隙还是可以容纳得下引出来的线的。</p>\n</li>\n<li>如果可以淘到<strong>更小的开关</strong>，就可以不破环或者较少对本子的破坏完成改造。</li>\n<li>按钮可以用其他东西替代，如果能买到类似安全锁孔的按钮那就是最完美的了。实在没有，用3d打印机打印也是可以的，我这回着急弄，就没有打印，直接切的料。<em>（<strong>如果有需要可以邮箱联系我定制3D打印开关</strong>）</em></li>\n</ul>\n"},{"title":"组装小红点机械键盘 tex yoda 2 & 定制键盘盖","date":"2018-10-21T04:50:03.000Z","author":"SmalBox","_content":"# 组装小红点机械键盘 TexYoda2 & 定制键盘盖\n\n![TexYoda2night](TexYoda2night.jpg)\n\n## **前言**\n\n  > 最近淘到了TexYoda2的diy套件，自己动手组装了一下。并且由于指点杆极其脆弱，又做了一个防尘盖来保护键盘(由于太过小众TB也没有，只好自己动手做了)，特此记录。\n  \n  > 实际体验，在win下，默认移动速度太快，需要调到最低的速度，并配合设置里的鼠标速度来调节。在mac下也要跳到最低的移动速度，而且键盘的**鼠标中键是原生好使的**，可以实现滚动。\n\n### **组装键盘**\n\n  > 组装键盘需要准备的工具：\n\n  1. TexYoda2套件\n  2. cherry轴（64个）\n  3. 电烙铁+吸锡器\n\n#### TexYoda2套件\n  > 先来看看大包裹。嗯～，顺丰就是靠谱，可以捏大泡泡了。\n\n  ![TexYoda2Pkg](TexYoda2Pkg.jpg)\n\n  > 拆包，看看这朴素的盒子，不错，这很环保。\n\n  ![TexYoda2Box](TexYoda2Box.jpg)\n\n  > OK,来打开看看套件什么样子。\n\n  > 首先第一层是ABS键帽，看着挺不错的样子，相对于第一代，第二代键帽可以透光，有正刻侧刻。GBH是打磨过的，为小红点让道。对了键帽里的 esc 键可以替换成一个 tex logo 的键帽很不错。\n\n  ![TexYoda2Keycap](TexYoda2Keycap.jpg)\n\n  > 拿开键帽，一个折叠式的隔层，画着操作说明，嗯这个盒子做的不错。\n\n  ![TexYoda2AssemblyInstructions](TexYoda2AssemblyInstructions.jpg)\n\n  > 打开隔层，来看看第二层。键盘壳、主板、定位板、鼠标三键主板放在一起，还有一个装各种配件的盒子，一个指点杆模块，几张贴纸。\n\n  ![TexYoda2Box2](TexYoda2Box2.jpg)\n\n  > 先来看一下指点杆套件，嗯～，很细，要小心，听说是粘上去了，很脆弱。附送了三种类型的帽子，现在的thinkpad都是默认小红毯的，可能是大多数人都喜欢小红毯吧，不过我试了三种，感觉还是凹的用起来最省力，不过他是最高的一个，打字很快的时候有时候会碰到他，但是还好几乎没什么大影响。\n\n  ![TexYoda2Trackpoint1](TexYoda2Trackpoint1.jpg)\n\n  > 再给指点杆一个特写\n  \n  ![TexYoda2Trackpoint2](TexYoda2Trackpoint2.jpg)\n\n  > TexYoda2的主板是黑色的，相较于1代绿色的看起来高端一点的样子。外壳是cnc加工的，细节重量手感都非常好。二代虽然取消了 usb hub 功能，但是把接口换成了type-c，很好用，实测手机type-c线也可以给它用，他的线也可以给手机用。主板和钢板的留口可以允许多种键盘布局，非常方便。\n\n  ![TexYoda2Shell1](TexYoda2Shell1.jpg)\n\n  > 再来两张特写\n\n  ![TexYoda2Shell2](TexYoda2Shell2.jpg)\n\n  ![TexYoda2Shell3](TexYoda2Shell3.jpg)\n\n  > 主板背面有键盘物理跳线开关。二代支持全键盘自定义，和12个自定义宏，并且可以同时保存3套键盘布局在键盘中。简直不要太方便啊。win mac linux 各准备一套键位或者给游戏留一套键位也可以。\n\n  > 二代的键盘是有存储能力的，应该是512kb。在TexoYoda2的官方网站就可以定制键位，然后下载下来，存储到键盘中。打开条线6，键盘就可像一个U盘一样被读取，然后存入网站配置并下载好的文件即可。网站上可以定制三种布局，分别对应条线的1 2 3，打开相应条线即可使用其布局。至于4 5 是干什么用的，目前还没搞清楚。\n\n  > 设置布局的网站在这里：[https://yoda2.tex-design.com.tw/#layout](https://yoda2.tex-design.com.tw/#layout)\n\n  ![TexYodaShell4](TexYoda2Shell4.jpg)\n\n  > 最后来看看这一大堆的附件，有一个数据线，是90度接口的很不错。一个 tex 的理线带。 一包 led 灯。鼠标三件的定位板。鼠标三键灯键帽（这三个貌似是pbt材质的，不透光磨砂质感）。一套卫星轴套件。两个金属键盘脚撑，和防滑垫。\n\n  ![TexYoda2Accessories1](TexYoda2Accessories1.jpg)\n\n  > 第一次安装卫星轴，找口看了半天，发现里面的那个最下面是有个小口可以让金属棒翘着插进去的。有不一样的豁口，所以插进去不会差错。\n\n  ![TexYoda2SatelliteAxis1](TexYoda2SatelliteAxis1.jpg)\n\n  ![TexYoda2SatelliteAxis2](TexYoda2SatelliteAxis2.jpg)\n\n#### cherry轴\n\n  > 我选配的轴是：\n  \n   - 鼠标三键： 线性银轴\n   - 空格： 黑轴\n   - 其他： 茶轴 \n  \n  > 至于是三脚还是五脚轴，我选的是三脚轴，毕竟便宜嘛。主板是支持五脚轴的，有钱可以上五脚。\n\n#### 焊接\n\n  > 焊接就不上图了，无非就是把轴放到钢板里，放上主板，先焊轴后焊灯。需要注意点就是灯的长脚是正极，对应好板子上的正极即可。焊接灯的时候把针脚弯一点，不让灯掉下去就可以。\n\n  > 焊完接电脑测试，win平台有 Keyboardtestutility 这个软件可以用来测试键盘是否焊接好了。\n  \n  > 测试软件：[KeyboardTestUtility](https://pan.baidu.com/s/1oBvK3LtMniiyZxkCWEtMQA)  密码:tqrx\n\n  > 一切都没问题了，就可以上指点杆了，很简单穿过主板，接上排线。把鼠标三键的主板上的接口接到主板上。可以上盖了。\n\n#### 收尾\n\n  > 安装键帽，这个，按上去就好了。根据不同的习惯，可以调整键帽的安装。比如alt和win之类的。\n\n  > 最后给指点杆上扣一个金属帽子，拧上螺丝，一定要轻，螺丝不松就行，不用太紧。\n\n  > 来个安装好的图\n\n  ![TexYoda2Feature2](TexYoda2Feature2.jpg)\n\n  ![TexYoda2Feature3](TexYoda2Feature3.jpg)\n\n### **键盘盖**\n\n  > 一开始我只是想怎么保护指点杆，毕竟它那么脆弱。尤其是在放到包里的时候，挤压随时会对他产生致命的威胁。经过考虑觉得还是要一个盖子来全方位的保护键盘正面不被挤压。\n\n  > 没想到万能的TB在这个问题上也翻了车。除了hhkb那个官方的300块的盖子以外，几乎很少有键盘配盖子。很多人对盖子，大多是没啥用的态度。无奈TexYoda也是小众，盖子就更小众了。只好自己定制一个了。\n\n  > 当然让这一切成为可能的关键就是，**3d打印机**(*如果有需要，我可以提供打印机，帮助解决这一步。具体可以通过邮箱联系我*)。\n\n  > 盖子用料及工具：\n\n  1. 一块2mm厚的亚克力板\n  2. 直径3mm，长6mm的螺丝及其螺丝帽 * 16组\n  3. 给家具用的贴膜一张\n  4. 3d打印机极其耗材（我用的是PLA）\n  5. 电烙铁+美工刀改装的电热刀（如果有其他更强大的切割亚克力板的工具可以都上）\n  6. 电钻\n\n  > 盖子顶部 **宽度 12cm 长度 28cm** ，**侧面 长度 28cm 高度 1.9cm** 。\n\n  - 亚克力板先按照尺寸用电热刀切好。\n  - 下载模型:[点击下载模型](https://pan.baidu.com/s/1aiAOrdUdaHInRGBiMHjZXA)  密码：grod\n  - 将盖子的左右极其中间的固定架用3d打印机打好。\n  - 将打好的固定架和亚克力板组装好，亚克力板肯定会长一点，这时候用电热刀进行细微的切割让其正确安装。\n  - 插好后用电钻在固定的地方开孔，并在开孔后在孔的边缘多磨掉一圈，好让螺丝嵌入到固定架中，而不是螺丝头突出来。（当然了这步开孔可以在设计古井家的时候就把孔开好，不过我懒了一下，直接用电钻搞定哈哈。）\n  - 开孔完成后，将边缘打磨好，可以开始贴膜了。\n  - 这步应该是比较考验技巧的时候，商家说用洗洁精泡泡水在被贴的表面清洁，并多撒点好贴膜，防止膜一下子就沾上。实际呢，我发现洗洁精的水，容易在亚克力板上留下痕迹，很难看，最后我是用易挥发的酒精完成的，虽然还是有一些气泡吧。\n  - 最后最后，安装好所有的固定架，完活～\n\n  > 成品：\n\n  ![TexYoda2Feature1](TexYoda2Feature1.jpg)\n\n","source":"_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖.md","raw":"---\ntitle: 组装小红点机械键盘 tex yoda 2 & 定制键盘盖\ndate: 2018-10-21 12:50:03\nauthor: SmalBox\ncategories: DIY\ntags:\n  - 小红点\n  - yex yoda 2\n  - 定制键盘盖\n---\n# 组装小红点机械键盘 TexYoda2 & 定制键盘盖\n\n![TexYoda2night](TexYoda2night.jpg)\n\n## **前言**\n\n  > 最近淘到了TexYoda2的diy套件，自己动手组装了一下。并且由于指点杆极其脆弱，又做了一个防尘盖来保护键盘(由于太过小众TB也没有，只好自己动手做了)，特此记录。\n  \n  > 实际体验，在win下，默认移动速度太快，需要调到最低的速度，并配合设置里的鼠标速度来调节。在mac下也要跳到最低的移动速度，而且键盘的**鼠标中键是原生好使的**，可以实现滚动。\n\n### **组装键盘**\n\n  > 组装键盘需要准备的工具：\n\n  1. TexYoda2套件\n  2. cherry轴（64个）\n  3. 电烙铁+吸锡器\n\n#### TexYoda2套件\n  > 先来看看大包裹。嗯～，顺丰就是靠谱，可以捏大泡泡了。\n\n  ![TexYoda2Pkg](TexYoda2Pkg.jpg)\n\n  > 拆包，看看这朴素的盒子，不错，这很环保。\n\n  ![TexYoda2Box](TexYoda2Box.jpg)\n\n  > OK,来打开看看套件什么样子。\n\n  > 首先第一层是ABS键帽，看着挺不错的样子，相对于第一代，第二代键帽可以透光，有正刻侧刻。GBH是打磨过的，为小红点让道。对了键帽里的 esc 键可以替换成一个 tex logo 的键帽很不错。\n\n  ![TexYoda2Keycap](TexYoda2Keycap.jpg)\n\n  > 拿开键帽，一个折叠式的隔层，画着操作说明，嗯这个盒子做的不错。\n\n  ![TexYoda2AssemblyInstructions](TexYoda2AssemblyInstructions.jpg)\n\n  > 打开隔层，来看看第二层。键盘壳、主板、定位板、鼠标三键主板放在一起，还有一个装各种配件的盒子，一个指点杆模块，几张贴纸。\n\n  ![TexYoda2Box2](TexYoda2Box2.jpg)\n\n  > 先来看一下指点杆套件，嗯～，很细，要小心，听说是粘上去了，很脆弱。附送了三种类型的帽子，现在的thinkpad都是默认小红毯的，可能是大多数人都喜欢小红毯吧，不过我试了三种，感觉还是凹的用起来最省力，不过他是最高的一个，打字很快的时候有时候会碰到他，但是还好几乎没什么大影响。\n\n  ![TexYoda2Trackpoint1](TexYoda2Trackpoint1.jpg)\n\n  > 再给指点杆一个特写\n  \n  ![TexYoda2Trackpoint2](TexYoda2Trackpoint2.jpg)\n\n  > TexYoda2的主板是黑色的，相较于1代绿色的看起来高端一点的样子。外壳是cnc加工的，细节重量手感都非常好。二代虽然取消了 usb hub 功能，但是把接口换成了type-c，很好用，实测手机type-c线也可以给它用，他的线也可以给手机用。主板和钢板的留口可以允许多种键盘布局，非常方便。\n\n  ![TexYoda2Shell1](TexYoda2Shell1.jpg)\n\n  > 再来两张特写\n\n  ![TexYoda2Shell2](TexYoda2Shell2.jpg)\n\n  ![TexYoda2Shell3](TexYoda2Shell3.jpg)\n\n  > 主板背面有键盘物理跳线开关。二代支持全键盘自定义，和12个自定义宏，并且可以同时保存3套键盘布局在键盘中。简直不要太方便啊。win mac linux 各准备一套键位或者给游戏留一套键位也可以。\n\n  > 二代的键盘是有存储能力的，应该是512kb。在TexoYoda2的官方网站就可以定制键位，然后下载下来，存储到键盘中。打开条线6，键盘就可像一个U盘一样被读取，然后存入网站配置并下载好的文件即可。网站上可以定制三种布局，分别对应条线的1 2 3，打开相应条线即可使用其布局。至于4 5 是干什么用的，目前还没搞清楚。\n\n  > 设置布局的网站在这里：[https://yoda2.tex-design.com.tw/#layout](https://yoda2.tex-design.com.tw/#layout)\n\n  ![TexYodaShell4](TexYoda2Shell4.jpg)\n\n  > 最后来看看这一大堆的附件，有一个数据线，是90度接口的很不错。一个 tex 的理线带。 一包 led 灯。鼠标三件的定位板。鼠标三键灯键帽（这三个貌似是pbt材质的，不透光磨砂质感）。一套卫星轴套件。两个金属键盘脚撑，和防滑垫。\n\n  ![TexYoda2Accessories1](TexYoda2Accessories1.jpg)\n\n  > 第一次安装卫星轴，找口看了半天，发现里面的那个最下面是有个小口可以让金属棒翘着插进去的。有不一样的豁口，所以插进去不会差错。\n\n  ![TexYoda2SatelliteAxis1](TexYoda2SatelliteAxis1.jpg)\n\n  ![TexYoda2SatelliteAxis2](TexYoda2SatelliteAxis2.jpg)\n\n#### cherry轴\n\n  > 我选配的轴是：\n  \n   - 鼠标三键： 线性银轴\n   - 空格： 黑轴\n   - 其他： 茶轴 \n  \n  > 至于是三脚还是五脚轴，我选的是三脚轴，毕竟便宜嘛。主板是支持五脚轴的，有钱可以上五脚。\n\n#### 焊接\n\n  > 焊接就不上图了，无非就是把轴放到钢板里，放上主板，先焊轴后焊灯。需要注意点就是灯的长脚是正极，对应好板子上的正极即可。焊接灯的时候把针脚弯一点，不让灯掉下去就可以。\n\n  > 焊完接电脑测试，win平台有 Keyboardtestutility 这个软件可以用来测试键盘是否焊接好了。\n  \n  > 测试软件：[KeyboardTestUtility](https://pan.baidu.com/s/1oBvK3LtMniiyZxkCWEtMQA)  密码:tqrx\n\n  > 一切都没问题了，就可以上指点杆了，很简单穿过主板，接上排线。把鼠标三键的主板上的接口接到主板上。可以上盖了。\n\n#### 收尾\n\n  > 安装键帽，这个，按上去就好了。根据不同的习惯，可以调整键帽的安装。比如alt和win之类的。\n\n  > 最后给指点杆上扣一个金属帽子，拧上螺丝，一定要轻，螺丝不松就行，不用太紧。\n\n  > 来个安装好的图\n\n  ![TexYoda2Feature2](TexYoda2Feature2.jpg)\n\n  ![TexYoda2Feature3](TexYoda2Feature3.jpg)\n\n### **键盘盖**\n\n  > 一开始我只是想怎么保护指点杆，毕竟它那么脆弱。尤其是在放到包里的时候，挤压随时会对他产生致命的威胁。经过考虑觉得还是要一个盖子来全方位的保护键盘正面不被挤压。\n\n  > 没想到万能的TB在这个问题上也翻了车。除了hhkb那个官方的300块的盖子以外，几乎很少有键盘配盖子。很多人对盖子，大多是没啥用的态度。无奈TexYoda也是小众，盖子就更小众了。只好自己定制一个了。\n\n  > 当然让这一切成为可能的关键就是，**3d打印机**(*如果有需要，我可以提供打印机，帮助解决这一步。具体可以通过邮箱联系我*)。\n\n  > 盖子用料及工具：\n\n  1. 一块2mm厚的亚克力板\n  2. 直径3mm，长6mm的螺丝及其螺丝帽 * 16组\n  3. 给家具用的贴膜一张\n  4. 3d打印机极其耗材（我用的是PLA）\n  5. 电烙铁+美工刀改装的电热刀（如果有其他更强大的切割亚克力板的工具可以都上）\n  6. 电钻\n\n  > 盖子顶部 **宽度 12cm 长度 28cm** ，**侧面 长度 28cm 高度 1.9cm** 。\n\n  - 亚克力板先按照尺寸用电热刀切好。\n  - 下载模型:[点击下载模型](https://pan.baidu.com/s/1aiAOrdUdaHInRGBiMHjZXA)  密码：grod\n  - 将盖子的左右极其中间的固定架用3d打印机打好。\n  - 将打好的固定架和亚克力板组装好，亚克力板肯定会长一点，这时候用电热刀进行细微的切割让其正确安装。\n  - 插好后用电钻在固定的地方开孔，并在开孔后在孔的边缘多磨掉一圈，好让螺丝嵌入到固定架中，而不是螺丝头突出来。（当然了这步开孔可以在设计古井家的时候就把孔开好，不过我懒了一下，直接用电钻搞定哈哈。）\n  - 开孔完成后，将边缘打磨好，可以开始贴膜了。\n  - 这步应该是比较考验技巧的时候，商家说用洗洁精泡泡水在被贴的表面清洁，并多撒点好贴膜，防止膜一下子就沾上。实际呢，我发现洗洁精的水，容易在亚克力板上留下痕迹，很难看，最后我是用易挥发的酒精完成的，虽然还是有一些气泡吧。\n  - 最后最后，安装好所有的固定架，完活～\n\n  > 成品：\n\n  ![TexYoda2Feature1](TexYoda2Feature1.jpg)\n\n","slug":"组装小红点机械键盘-tex-yoda-2-定制键盘盖","published":1,"updated":"2019-11-24T16:25:24.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptihr000rbsfox3bghrbk","content":"<h1 id=\"组装小红点机械键盘-TexYoda2-amp-定制键盘盖\"><a href=\"#组装小红点机械键盘-TexYoda2-amp-定制键盘盖\" class=\"headerlink\" title=\"组装小红点机械键盘 TexYoda2 &amp; 定制键盘盖\"></a>组装小红点机械键盘 TexYoda2 &amp; 定制键盘盖</h1><p><img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2night.jpg\" alt=\"TexYoda2night\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><blockquote>\n<p>最近淘到了TexYoda2的diy套件，自己动手组装了一下。并且由于指点杆极其脆弱，又做了一个防尘盖来保护键盘(由于太过小众TB也没有，只好自己动手做了)，特此记录。</p>\n</blockquote>\n<blockquote>\n<p>实际体验，在win下，默认移动速度太快，需要调到最低的速度，并配合设置里的鼠标速度来调节。在mac下也要跳到最低的移动速度，而且键盘的<strong>鼠标中键是原生好使的</strong>，可以实现滚动。</p>\n</blockquote>\n<h3 id=\"组装键盘\"><a href=\"#组装键盘\" class=\"headerlink\" title=\"组装键盘\"></a><strong>组装键盘</strong></h3><blockquote>\n<p>组装键盘需要准备的工具：</p>\n</blockquote>\n<ol>\n<li>TexYoda2套件</li>\n<li>cherry轴（64个）</li>\n<li>电烙铁+吸锡器</li>\n</ol>\n<h4 id=\"TexYoda2套件\"><a href=\"#TexYoda2套件\" class=\"headerlink\" title=\"TexYoda2套件\"></a>TexYoda2套件</h4><blockquote>\n<p>先来看看大包裹。嗯～，顺丰就是靠谱，可以捏大泡泡了。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Pkg.jpg\" alt=\"TexYoda2Pkg\"></p>\n<blockquote>\n<p>拆包，看看这朴素的盒子，不错，这很环保。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Box.jpg\" alt=\"TexYoda2Box\"></p>\n<blockquote>\n<p>OK,来打开看看套件什么样子。</p>\n</blockquote>\n<blockquote>\n<p>首先第一层是ABS键帽，看着挺不错的样子，相对于第一代，第二代键帽可以透光，有正刻侧刻。GBH是打磨过的，为小红点让道。对了键帽里的 esc 键可以替换成一个 tex logo 的键帽很不错。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Keycap.jpg\" alt=\"TexYoda2Keycap\"></p>\n<blockquote>\n<p>拿开键帽，一个折叠式的隔层，画着操作说明，嗯这个盒子做的不错。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2AssemblyInstructions.jpg\" alt=\"TexYoda2AssemblyInstructions\"></p>\n<blockquote>\n<p>打开隔层，来看看第二层。键盘壳、主板、定位板、鼠标三键主板放在一起，还有一个装各种配件的盒子，一个指点杆模块，几张贴纸。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Box2.jpg\" alt=\"TexYoda2Box2\"></p>\n<blockquote>\n<p>先来看一下指点杆套件，嗯～，很细，要小心，听说是粘上去了，很脆弱。附送了三种类型的帽子，现在的thinkpad都是默认小红毯的，可能是大多数人都喜欢小红毯吧，不过我试了三种，感觉还是凹的用起来最省力，不过他是最高的一个，打字很快的时候有时候会碰到他，但是还好几乎没什么大影响。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Trackpoint1.jpg\" alt=\"TexYoda2Trackpoint1\"></p>\n<blockquote>\n<p>再给指点杆一个特写</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Trackpoint2.jpg\" alt=\"TexYoda2Trackpoint2\"></p>\n<blockquote>\n<p>TexYoda2的主板是黑色的，相较于1代绿色的看起来高端一点的样子。外壳是cnc加工的，细节重量手感都非常好。二代虽然取消了 usb hub 功能，但是把接口换成了type-c，很好用，实测手机type-c线也可以给它用，他的线也可以给手机用。主板和钢板的留口可以允许多种键盘布局，非常方便。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Shell1.jpg\" alt=\"TexYoda2Shell1\"></p>\n<blockquote>\n<p>再来两张特写</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Shell2.jpg\" alt=\"TexYoda2Shell2\"></p>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Shell3.jpg\" alt=\"TexYoda2Shell3\"></p>\n<blockquote>\n<p>主板背面有键盘物理跳线开关。二代支持全键盘自定义，和12个自定义宏，并且可以同时保存3套键盘布局在键盘中。简直不要太方便啊。win mac linux 各准备一套键位或者给游戏留一套键位也可以。</p>\n</blockquote>\n<blockquote>\n<p>二代的键盘是有存储能力的，应该是512kb。在TexoYoda2的官方网站就可以定制键位，然后下载下来，存储到键盘中。打开条线6，键盘就可像一个U盘一样被读取，然后存入网站配置并下载好的文件即可。网站上可以定制三种布局，分别对应条线的1 2 3，打开相应条线即可使用其布局。至于4 5 是干什么用的，目前还没搞清楚。</p>\n</blockquote>\n<blockquote>\n<p>设置布局的网站在这里：<a href=\"https://yoda2.tex-design.com.tw/#layout\" target=\"_blank\" rel=\"noopener\">https://yoda2.tex-design.com.tw/#layout</a></p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Shell4.jpg\" alt=\"TexYodaShell4\"></p>\n<blockquote>\n<p>最后来看看这一大堆的附件，有一个数据线，是90度接口的很不错。一个 tex 的理线带。 一包 led 灯。鼠标三件的定位板。鼠标三键灯键帽（这三个貌似是pbt材质的，不透光磨砂质感）。一套卫星轴套件。两个金属键盘脚撑，和防滑垫。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Accessories1.jpg\" alt=\"TexYoda2Accessories1\"></p>\n<blockquote>\n<p>第一次安装卫星轴，找口看了半天，发现里面的那个最下面是有个小口可以让金属棒翘着插进去的。有不一样的豁口，所以插进去不会差错。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2SatelliteAxis1.jpg\" alt=\"TexYoda2SatelliteAxis1\"></p>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2SatelliteAxis2.jpg\" alt=\"TexYoda2SatelliteAxis2\"></p>\n<h4 id=\"cherry轴\"><a href=\"#cherry轴\" class=\"headerlink\" title=\"cherry轴\"></a>cherry轴</h4><blockquote>\n<p>我选配的轴是：</p>\n</blockquote>\n<ul>\n<li>鼠标三键： 线性银轴</li>\n<li>空格： 黑轴</li>\n<li><p>其他： 茶轴 </p>\n<blockquote>\n<p>至于是三脚还是五脚轴，我选的是三脚轴，毕竟便宜嘛。主板是支持五脚轴的，有钱可以上五脚。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"焊接\"><a href=\"#焊接\" class=\"headerlink\" title=\"焊接\"></a>焊接</h4><blockquote>\n<p>焊接就不上图了，无非就是把轴放到钢板里，放上主板，先焊轴后焊灯。需要注意点就是灯的长脚是正极，对应好板子上的正极即可。焊接灯的时候把针脚弯一点，不让灯掉下去就可以。</p>\n</blockquote>\n<blockquote>\n<p>焊完接电脑测试，win平台有 Keyboardtestutility 这个软件可以用来测试键盘是否焊接好了。</p>\n</blockquote>\n<blockquote>\n<p>测试软件：<a href=\"https://pan.baidu.com/s/1oBvK3LtMniiyZxkCWEtMQA\" target=\"_blank\" rel=\"noopener\">KeyboardTestUtility</a>  密码:tqrx</p>\n</blockquote>\n<blockquote>\n<p>一切都没问题了，就可以上指点杆了，很简单穿过主板，接上排线。把鼠标三键的主板上的接口接到主板上。可以上盖了。</p>\n</blockquote>\n<h4 id=\"收尾\"><a href=\"#收尾\" class=\"headerlink\" title=\"收尾\"></a>收尾</h4><blockquote>\n<p>安装键帽，这个，按上去就好了。根据不同的习惯，可以调整键帽的安装。比如alt和win之类的。</p>\n</blockquote>\n<blockquote>\n<p>最后给指点杆上扣一个金属帽子，拧上螺丝，一定要轻，螺丝不松就行，不用太紧。</p>\n</blockquote>\n<blockquote>\n<p>来个安装好的图</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Feature2.jpg\" alt=\"TexYoda2Feature2\"></p>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Feature3.jpg\" alt=\"TexYoda2Feature3\"></p>\n<h3 id=\"键盘盖\"><a href=\"#键盘盖\" class=\"headerlink\" title=\"键盘盖\"></a><strong>键盘盖</strong></h3><blockquote>\n<p>一开始我只是想怎么保护指点杆，毕竟它那么脆弱。尤其是在放到包里的时候，挤压随时会对他产生致命的威胁。经过考虑觉得还是要一个盖子来全方位的保护键盘正面不被挤压。</p>\n</blockquote>\n<blockquote>\n<p>没想到万能的TB在这个问题上也翻了车。除了hhkb那个官方的300块的盖子以外，几乎很少有键盘配盖子。很多人对盖子，大多是没啥用的态度。无奈TexYoda也是小众，盖子就更小众了。只好自己定制一个了。</p>\n</blockquote>\n<blockquote>\n<p>当然让这一切成为可能的关键就是，<strong>3d打印机</strong>(<em>如果有需要，我可以提供打印机，帮助解决这一步。具体可以通过邮箱联系我</em>)。</p>\n</blockquote>\n<blockquote>\n<p>盖子用料及工具：</p>\n</blockquote>\n<ol>\n<li>一块2mm厚的亚克力板</li>\n<li>直径3mm，长6mm的螺丝及其螺丝帽 * 16组</li>\n<li>给家具用的贴膜一张</li>\n<li>3d打印机极其耗材（我用的是PLA）</li>\n<li>电烙铁+美工刀改装的电热刀（如果有其他更强大的切割亚克力板的工具可以都上）</li>\n<li><p>电钻</p>\n<blockquote>\n<p>盖子顶部 <strong>宽度 12cm 长度 28cm</strong> ，<strong>侧面 长度 28cm 高度 1.9cm</strong> 。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>亚克力板先按照尺寸用电热刀切好。</li>\n<li>下载模型:<a href=\"https://pan.baidu.com/s/1aiAOrdUdaHInRGBiMHjZXA\" target=\"_blank\" rel=\"noopener\">点击下载模型</a>  密码：grod</li>\n<li>将盖子的左右极其中间的固定架用3d打印机打好。</li>\n<li>将打好的固定架和亚克力板组装好，亚克力板肯定会长一点，这时候用电热刀进行细微的切割让其正确安装。</li>\n<li>插好后用电钻在固定的地方开孔，并在开孔后在孔的边缘多磨掉一圈，好让螺丝嵌入到固定架中，而不是螺丝头突出来。（当然了这步开孔可以在设计古井家的时候就把孔开好，不过我懒了一下，直接用电钻搞定哈哈。）</li>\n<li>开孔完成后，将边缘打磨好，可以开始贴膜了。</li>\n<li>这步应该是比较考验技巧的时候，商家说用洗洁精泡泡水在被贴的表面清洁，并多撒点好贴膜，防止膜一下子就沾上。实际呢，我发现洗洁精的水，容易在亚克力板上留下痕迹，很难看，最后我是用易挥发的酒精完成的，虽然还是有一些气泡吧。</li>\n<li><p>最后最后，安装好所有的固定架，完活～</p>\n<blockquote>\n<p>成品：</p>\n</blockquote>\n<p><img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Feature1.jpg\" alt=\"TexYoda2Feature1\"></p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"组装小红点机械键盘-TexYoda2-amp-定制键盘盖\"><a href=\"#组装小红点机械键盘-TexYoda2-amp-定制键盘盖\" class=\"headerlink\" title=\"组装小红点机械键盘 TexYoda2 &amp; 定制键盘盖\"></a>组装小红点机械键盘 TexYoda2 &amp; 定制键盘盖</h1><p><img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2night.jpg\" alt=\"TexYoda2night\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><blockquote>\n<p>最近淘到了TexYoda2的diy套件，自己动手组装了一下。并且由于指点杆极其脆弱，又做了一个防尘盖来保护键盘(由于太过小众TB也没有，只好自己动手做了)，特此记录。</p>\n</blockquote>\n<blockquote>\n<p>实际体验，在win下，默认移动速度太快，需要调到最低的速度，并配合设置里的鼠标速度来调节。在mac下也要跳到最低的移动速度，而且键盘的<strong>鼠标中键是原生好使的</strong>，可以实现滚动。</p>\n</blockquote>\n<h3 id=\"组装键盘\"><a href=\"#组装键盘\" class=\"headerlink\" title=\"组装键盘\"></a><strong>组装键盘</strong></h3><blockquote>\n<p>组装键盘需要准备的工具：</p>\n</blockquote>\n<ol>\n<li>TexYoda2套件</li>\n<li>cherry轴（64个）</li>\n<li>电烙铁+吸锡器</li>\n</ol>\n<h4 id=\"TexYoda2套件\"><a href=\"#TexYoda2套件\" class=\"headerlink\" title=\"TexYoda2套件\"></a>TexYoda2套件</h4><blockquote>\n<p>先来看看大包裹。嗯～，顺丰就是靠谱，可以捏大泡泡了。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Pkg.jpg\" alt=\"TexYoda2Pkg\"></p>\n<blockquote>\n<p>拆包，看看这朴素的盒子，不错，这很环保。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Box.jpg\" alt=\"TexYoda2Box\"></p>\n<blockquote>\n<p>OK,来打开看看套件什么样子。</p>\n</blockquote>\n<blockquote>\n<p>首先第一层是ABS键帽，看着挺不错的样子，相对于第一代，第二代键帽可以透光，有正刻侧刻。GBH是打磨过的，为小红点让道。对了键帽里的 esc 键可以替换成一个 tex logo 的键帽很不错。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Keycap.jpg\" alt=\"TexYoda2Keycap\"></p>\n<blockquote>\n<p>拿开键帽，一个折叠式的隔层，画着操作说明，嗯这个盒子做的不错。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2AssemblyInstructions.jpg\" alt=\"TexYoda2AssemblyInstructions\"></p>\n<blockquote>\n<p>打开隔层，来看看第二层。键盘壳、主板、定位板、鼠标三键主板放在一起，还有一个装各种配件的盒子，一个指点杆模块，几张贴纸。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Box2.jpg\" alt=\"TexYoda2Box2\"></p>\n<blockquote>\n<p>先来看一下指点杆套件，嗯～，很细，要小心，听说是粘上去了，很脆弱。附送了三种类型的帽子，现在的thinkpad都是默认小红毯的，可能是大多数人都喜欢小红毯吧，不过我试了三种，感觉还是凹的用起来最省力，不过他是最高的一个，打字很快的时候有时候会碰到他，但是还好几乎没什么大影响。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Trackpoint1.jpg\" alt=\"TexYoda2Trackpoint1\"></p>\n<blockquote>\n<p>再给指点杆一个特写</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Trackpoint2.jpg\" alt=\"TexYoda2Trackpoint2\"></p>\n<blockquote>\n<p>TexYoda2的主板是黑色的，相较于1代绿色的看起来高端一点的样子。外壳是cnc加工的，细节重量手感都非常好。二代虽然取消了 usb hub 功能，但是把接口换成了type-c，很好用，实测手机type-c线也可以给它用，他的线也可以给手机用。主板和钢板的留口可以允许多种键盘布局，非常方便。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Shell1.jpg\" alt=\"TexYoda2Shell1\"></p>\n<blockquote>\n<p>再来两张特写</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Shell2.jpg\" alt=\"TexYoda2Shell2\"></p>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Shell3.jpg\" alt=\"TexYoda2Shell3\"></p>\n<blockquote>\n<p>主板背面有键盘物理跳线开关。二代支持全键盘自定义，和12个自定义宏，并且可以同时保存3套键盘布局在键盘中。简直不要太方便啊。win mac linux 各准备一套键位或者给游戏留一套键位也可以。</p>\n</blockquote>\n<blockquote>\n<p>二代的键盘是有存储能力的，应该是512kb。在TexoYoda2的官方网站就可以定制键位，然后下载下来，存储到键盘中。打开条线6，键盘就可像一个U盘一样被读取，然后存入网站配置并下载好的文件即可。网站上可以定制三种布局，分别对应条线的1 2 3，打开相应条线即可使用其布局。至于4 5 是干什么用的，目前还没搞清楚。</p>\n</blockquote>\n<blockquote>\n<p>设置布局的网站在这里：<a href=\"https://yoda2.tex-design.com.tw/#layout\" target=\"_blank\" rel=\"noopener\">https://yoda2.tex-design.com.tw/#layout</a></p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Shell4.jpg\" alt=\"TexYodaShell4\"></p>\n<blockquote>\n<p>最后来看看这一大堆的附件，有一个数据线，是90度接口的很不错。一个 tex 的理线带。 一包 led 灯。鼠标三件的定位板。鼠标三键灯键帽（这三个貌似是pbt材质的，不透光磨砂质感）。一套卫星轴套件。两个金属键盘脚撑，和防滑垫。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Accessories1.jpg\" alt=\"TexYoda2Accessories1\"></p>\n<blockquote>\n<p>第一次安装卫星轴，找口看了半天，发现里面的那个最下面是有个小口可以让金属棒翘着插进去的。有不一样的豁口，所以插进去不会差错。</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2SatelliteAxis1.jpg\" alt=\"TexYoda2SatelliteAxis1\"></p>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2SatelliteAxis2.jpg\" alt=\"TexYoda2SatelliteAxis2\"></p>\n<h4 id=\"cherry轴\"><a href=\"#cherry轴\" class=\"headerlink\" title=\"cherry轴\"></a>cherry轴</h4><blockquote>\n<p>我选配的轴是：</p>\n</blockquote>\n<ul>\n<li>鼠标三键： 线性银轴</li>\n<li>空格： 黑轴</li>\n<li><p>其他： 茶轴 </p>\n<blockquote>\n<p>至于是三脚还是五脚轴，我选的是三脚轴，毕竟便宜嘛。主板是支持五脚轴的，有钱可以上五脚。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"焊接\"><a href=\"#焊接\" class=\"headerlink\" title=\"焊接\"></a>焊接</h4><blockquote>\n<p>焊接就不上图了，无非就是把轴放到钢板里，放上主板，先焊轴后焊灯。需要注意点就是灯的长脚是正极，对应好板子上的正极即可。焊接灯的时候把针脚弯一点，不让灯掉下去就可以。</p>\n</blockquote>\n<blockquote>\n<p>焊完接电脑测试，win平台有 Keyboardtestutility 这个软件可以用来测试键盘是否焊接好了。</p>\n</blockquote>\n<blockquote>\n<p>测试软件：<a href=\"https://pan.baidu.com/s/1oBvK3LtMniiyZxkCWEtMQA\" target=\"_blank\" rel=\"noopener\">KeyboardTestUtility</a>  密码:tqrx</p>\n</blockquote>\n<blockquote>\n<p>一切都没问题了，就可以上指点杆了，很简单穿过主板，接上排线。把鼠标三键的主板上的接口接到主板上。可以上盖了。</p>\n</blockquote>\n<h4 id=\"收尾\"><a href=\"#收尾\" class=\"headerlink\" title=\"收尾\"></a>收尾</h4><blockquote>\n<p>安装键帽，这个，按上去就好了。根据不同的习惯，可以调整键帽的安装。比如alt和win之类的。</p>\n</blockquote>\n<blockquote>\n<p>最后给指点杆上扣一个金属帽子，拧上螺丝，一定要轻，螺丝不松就行，不用太紧。</p>\n</blockquote>\n<blockquote>\n<p>来个安装好的图</p>\n</blockquote>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Feature2.jpg\" alt=\"TexYoda2Feature2\"></p>\n<p>  <img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Feature3.jpg\" alt=\"TexYoda2Feature3\"></p>\n<h3 id=\"键盘盖\"><a href=\"#键盘盖\" class=\"headerlink\" title=\"键盘盖\"></a><strong>键盘盖</strong></h3><blockquote>\n<p>一开始我只是想怎么保护指点杆，毕竟它那么脆弱。尤其是在放到包里的时候，挤压随时会对他产生致命的威胁。经过考虑觉得还是要一个盖子来全方位的保护键盘正面不被挤压。</p>\n</blockquote>\n<blockquote>\n<p>没想到万能的TB在这个问题上也翻了车。除了hhkb那个官方的300块的盖子以外，几乎很少有键盘配盖子。很多人对盖子，大多是没啥用的态度。无奈TexYoda也是小众，盖子就更小众了。只好自己定制一个了。</p>\n</blockquote>\n<blockquote>\n<p>当然让这一切成为可能的关键就是，<strong>3d打印机</strong>(<em>如果有需要，我可以提供打印机，帮助解决这一步。具体可以通过邮箱联系我</em>)。</p>\n</blockquote>\n<blockquote>\n<p>盖子用料及工具：</p>\n</blockquote>\n<ol>\n<li>一块2mm厚的亚克力板</li>\n<li>直径3mm，长6mm的螺丝及其螺丝帽 * 16组</li>\n<li>给家具用的贴膜一张</li>\n<li>3d打印机极其耗材（我用的是PLA）</li>\n<li>电烙铁+美工刀改装的电热刀（如果有其他更强大的切割亚克力板的工具可以都上）</li>\n<li><p>电钻</p>\n<blockquote>\n<p>盖子顶部 <strong>宽度 12cm 长度 28cm</strong> ，<strong>侧面 长度 28cm 高度 1.9cm</strong> 。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>亚克力板先按照尺寸用电热刀切好。</li>\n<li>下载模型:<a href=\"https://pan.baidu.com/s/1aiAOrdUdaHInRGBiMHjZXA\" target=\"_blank\" rel=\"noopener\">点击下载模型</a>  密码：grod</li>\n<li>将盖子的左右极其中间的固定架用3d打印机打好。</li>\n<li>将打好的固定架和亚克力板组装好，亚克力板肯定会长一点，这时候用电热刀进行细微的切割让其正确安装。</li>\n<li>插好后用电钻在固定的地方开孔，并在开孔后在孔的边缘多磨掉一圈，好让螺丝嵌入到固定架中，而不是螺丝头突出来。（当然了这步开孔可以在设计古井家的时候就把孔开好，不过我懒了一下，直接用电钻搞定哈哈。）</li>\n<li>开孔完成后，将边缘打磨好，可以开始贴膜了。</li>\n<li>这步应该是比较考验技巧的时候，商家说用洗洁精泡泡水在被贴的表面清洁，并多撒点好贴膜，防止膜一下子就沾上。实际呢，我发现洗洁精的水，容易在亚克力板上留下痕迹，很难看，最后我是用易挥发的酒精完成的，虽然还是有一些气泡吧。</li>\n<li><p>最后最后，安装好所有的固定架，完活～</p>\n<blockquote>\n<p>成品：</p>\n</blockquote>\n<p><img src=\"/2018/10/21/zu-zhuang-xiao-hong-dian-ji-jie-jian-pan-tex-yoda-2-ding-zhi-jian-pan-gai/TexYoda2Feature1.jpg\" alt=\"TexYoda2Feature1\"></p>\n</li>\n</ul>\n"},{"title":"笔记本超频内存条的'小秘密'","date":"2019-05-10T09:22:04.000Z","author":"SmalBox","_content":"# 笔记本超频内存条的'小秘密'\n\n## **前言**\n\n最近内存便宜，给 thinkpad S1 2017 升级16g内存。选择内存的过程中发现一些商家没有明说的'小秘密'，特此来分享一下。\n\n## **背景**\n\n   - 机器原装的是 DDR4 8g 2666频率 的内存条。\n   - 要选择一个 DDR4 16g 2666频率 的内存条。\n\n## **“小秘密”**\n\n   - 先上京东自营看了一圈，发现价格在480-800之间。\n   - 价格从低到高的牌子是：协德、威刚、十铨、金士顿、联想、三星、海力士、芝奇。\n   - 抛除牌子的原因，这几百块的差距是哪来的，就涉及到了商家宣传的手段了。\n      - **重点来了！！！**\n      - *都是同为2666的条子，便宜的条子在宣传上都是打着“游戏”、“发烧”为字眼的“超频条”。什么一键超频听起来高大上，实际上是需要主板支持 **XMP（Intel Extreme Memory Profiles）** 功能，在主板中打开这个功能内存可以自动超频。*\n      - *那么问题来了，**什么样的笔记本主板支持这个XMP呢？**。一般来讲，**游戏笔记本**可能会支持这个功能，其他的一般笔记本超级本之类的主板都不会给开放这个功能的。*\n      - 所以想买插上直接超频到2666的条子，那就考虑一下贵一点，比如三星、联想原厂之类的。这些条子使用了 **PNP（Plug-and-Play）** 技术，可以即插即用，直接超频。当然缺点是这类条子一般都比 **使用XMP技术的条子贵20%左右**。\n\n## **总结**\n\n   1. 无脑买条，直接上使用PNP技术的，无各种超频噱头的2666条子，小贵点。\n   2. 游戏本可以根据主板bios是否支持XMP技术，来选择XMP条子，确实省钱。\n   3. 不支持XMP技术主板的笔记本，根据需求选择。\n      - 如果要超频，只能选择PNP的条子。\n      - 如果比在乎超频，还想低价，选择XMP条子，频率使用默认的2133也未尝不可。","source":"_posts/笔记本超频内存条的-小秘密.md","raw":"---\ntitle: 笔记本超频内存条的'小秘密'\ndate: 2019-05-10 17:22:04\nauthor: SmalBox\ncategories: DIY\ntags:\n  - 笔记本\n  - 内存条\n---\n# 笔记本超频内存条的'小秘密'\n\n## **前言**\n\n最近内存便宜，给 thinkpad S1 2017 升级16g内存。选择内存的过程中发现一些商家没有明说的'小秘密'，特此来分享一下。\n\n## **背景**\n\n   - 机器原装的是 DDR4 8g 2666频率 的内存条。\n   - 要选择一个 DDR4 16g 2666频率 的内存条。\n\n## **“小秘密”**\n\n   - 先上京东自营看了一圈，发现价格在480-800之间。\n   - 价格从低到高的牌子是：协德、威刚、十铨、金士顿、联想、三星、海力士、芝奇。\n   - 抛除牌子的原因，这几百块的差距是哪来的，就涉及到了商家宣传的手段了。\n      - **重点来了！！！**\n      - *都是同为2666的条子，便宜的条子在宣传上都是打着“游戏”、“发烧”为字眼的“超频条”。什么一键超频听起来高大上，实际上是需要主板支持 **XMP（Intel Extreme Memory Profiles）** 功能，在主板中打开这个功能内存可以自动超频。*\n      - *那么问题来了，**什么样的笔记本主板支持这个XMP呢？**。一般来讲，**游戏笔记本**可能会支持这个功能，其他的一般笔记本超级本之类的主板都不会给开放这个功能的。*\n      - 所以想买插上直接超频到2666的条子，那就考虑一下贵一点，比如三星、联想原厂之类的。这些条子使用了 **PNP（Plug-and-Play）** 技术，可以即插即用，直接超频。当然缺点是这类条子一般都比 **使用XMP技术的条子贵20%左右**。\n\n## **总结**\n\n   1. 无脑买条，直接上使用PNP技术的，无各种超频噱头的2666条子，小贵点。\n   2. 游戏本可以根据主板bios是否支持XMP技术，来选择XMP条子，确实省钱。\n   3. 不支持XMP技术主板的笔记本，根据需求选择。\n      - 如果要超频，只能选择PNP的条子。\n      - 如果比在乎超频，还想低价，选择XMP条子，频率使用默认的2133也未尝不可。","slug":"笔记本超频内存条的-小秘密","published":1,"updated":"2019-11-24T16:25:24.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptihu000vbsfozxm3sl28","content":"<h1 id=\"笔记本超频内存条的’小秘密’\"><a href=\"#笔记本超频内存条的’小秘密’\" class=\"headerlink\" title=\"笔记本超频内存条的’小秘密’\"></a>笔记本超频内存条的’小秘密’</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>最近内存便宜，给 thinkpad S1 2017 升级16g内存。选择内存的过程中发现一些商家没有明说的’小秘密’，特此来分享一下。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a><strong>背景</strong></h2><ul>\n<li>机器原装的是 DDR4 8g 2666频率 的内存条。</li>\n<li>要选择一个 DDR4 16g 2666频率 的内存条。</li>\n</ul>\n<h2 id=\"“小秘密”\"><a href=\"#“小秘密”\" class=\"headerlink\" title=\"“小秘密”\"></a><strong>“小秘密”</strong></h2><ul>\n<li>先上京东自营看了一圈，发现价格在480-800之间。</li>\n<li>价格从低到高的牌子是：协德、威刚、十铨、金士顿、联想、三星、海力士、芝奇。</li>\n<li>抛除牌子的原因，这几百块的差距是哪来的，就涉及到了商家宣传的手段了。<ul>\n<li><strong>重点来了！！！</strong></li>\n<li><em>都是同为2666的条子，便宜的条子在宣传上都是打着“游戏”、“发烧”为字眼的“超频条”。什么一键超频听起来高大上，实际上是需要主板支持 <strong>XMP（Intel Extreme Memory Profiles）</strong> 功能，在主板中打开这个功能内存可以自动超频。</em></li>\n<li><em>那么问题来了，<strong>什么样的笔记本主板支持这个XMP呢？</strong>。一般来讲，<strong>游戏笔记本</strong>可能会支持这个功能，其他的一般笔记本超级本之类的主板都不会给开放这个功能的。</em></li>\n<li>所以想买插上直接超频到2666的条子，那就考虑一下贵一点，比如三星、联想原厂之类的。这些条子使用了 <strong>PNP（Plug-and-Play）</strong> 技术，可以即插即用，直接超频。当然缺点是这类条子一般都比 <strong>使用XMP技术的条子贵20%左右</strong>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><ol>\n<li>无脑买条，直接上使用PNP技术的，无各种超频噱头的2666条子，小贵点。</li>\n<li>游戏本可以根据主板bios是否支持XMP技术，来选择XMP条子，确实省钱。</li>\n<li>不支持XMP技术主板的笔记本，根据需求选择。<ul>\n<li>如果要超频，只能选择PNP的条子。</li>\n<li>如果比在乎超频，还想低价，选择XMP条子，频率使用默认的2133也未尝不可。</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"笔记本超频内存条的’小秘密’\"><a href=\"#笔记本超频内存条的’小秘密’\" class=\"headerlink\" title=\"笔记本超频内存条的’小秘密’\"></a>笔记本超频内存条的’小秘密’</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>最近内存便宜，给 thinkpad S1 2017 升级16g内存。选择内存的过程中发现一些商家没有明说的’小秘密’，特此来分享一下。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a><strong>背景</strong></h2><ul>\n<li>机器原装的是 DDR4 8g 2666频率 的内存条。</li>\n<li>要选择一个 DDR4 16g 2666频率 的内存条。</li>\n</ul>\n<h2 id=\"“小秘密”\"><a href=\"#“小秘密”\" class=\"headerlink\" title=\"“小秘密”\"></a><strong>“小秘密”</strong></h2><ul>\n<li>先上京东自营看了一圈，发现价格在480-800之间。</li>\n<li>价格从低到高的牌子是：协德、威刚、十铨、金士顿、联想、三星、海力士、芝奇。</li>\n<li>抛除牌子的原因，这几百块的差距是哪来的，就涉及到了商家宣传的手段了。<ul>\n<li><strong>重点来了！！！</strong></li>\n<li><em>都是同为2666的条子，便宜的条子在宣传上都是打着“游戏”、“发烧”为字眼的“超频条”。什么一键超频听起来高大上，实际上是需要主板支持 <strong>XMP（Intel Extreme Memory Profiles）</strong> 功能，在主板中打开这个功能内存可以自动超频。</em></li>\n<li><em>那么问题来了，<strong>什么样的笔记本主板支持这个XMP呢？</strong>。一般来讲，<strong>游戏笔记本</strong>可能会支持这个功能，其他的一般笔记本超级本之类的主板都不会给开放这个功能的。</em></li>\n<li>所以想买插上直接超频到2666的条子，那就考虑一下贵一点，比如三星、联想原厂之类的。这些条子使用了 <strong>PNP（Plug-and-Play）</strong> 技术，可以即插即用，直接超频。当然缺点是这类条子一般都比 <strong>使用XMP技术的条子贵20%左右</strong>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><ol>\n<li>无脑买条，直接上使用PNP技术的，无各种超频噱头的2666条子，小贵点。</li>\n<li>游戏本可以根据主板bios是否支持XMP技术，来选择XMP条子，确实省钱。</li>\n<li>不支持XMP技术主板的笔记本，根据需求选择。<ul>\n<li>如果要超频，只能选择PNP的条子。</li>\n<li>如果比在乎超频，还想低价，选择XMP条子，频率使用默认的2133也未尝不可。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"Unity导出Android工程","author":"SmalBox","cover":false,"top":false,"date":"2019-11-24T16:52:34.000Z","_content":"# unity导出apk & 导出工程到AndroidStudio二次开发\n\n本文将Uniyt导出Android工程的过程中需要注意的事项进行了阐述，对导出Android工程有其他疑问，可评论或邮箱联系我。\n\n## 0. 项目准备\n   - **unity 中配置 Android环境**\n      - Edit -> Preferences\n      - External Tools -> Adnroid 中选择好SDK JDK（默认安装Openjdk） NDK\n      - *（在可以用unity hub的版本里，直接可安装好这三个模块，其中jdk和ndk可以用默认的，sdk可以选择AndroidStudio中安装）*\n      - *(如果想要在 unity 中代理，须在在系统环境变量中添加HTTP_Proxy http://127.0.0.1:端口号 和 HTTPS_Proxy https://127.0.0.1:端口号)*\n\n   - **AndroidStudio中配置环境(在[Android中文网](https://developer.android.google.cn/)下载AndroidStudio，建议3.1版本便于下载SDK)**\n      - File -> Settings\n      - **搜索 HTTP Proxy 设置代理**\n         - Manual proxy configuration 中 设置 127.0.0.1 端口为本地外网开放端口\n         - 点击 check connection 输入 android.com 检测是否代理成功\n         *（设置代理成功可以下载sdk，更新包，在同步包时可以避免Gradle工具无法连接服务器，下载缓存而报错）*\n      - **搜索 Android SDK 安装设置SDK**\n         - 在 SDK Plantforms 中选择要安装的SDK和SDK工具\n         - 在 SDK Update Sites 中选择Force https://... sources to be fetched using http://... 和 disable SDK diff patching\n         - Apply后开始下载SDK\n\n## 1. 选择平台\n   - File -> BuildSettings 选择切换 android 平台\n\n## 2. 项目设置-玩家设置\n   - Edit -> ProjectSetting -> Player\n   - 填写 Company Name , Product Name\n\n## 3. 分辨率设置\n   - 启动是否全屏，是否渲染外部安全区域等\n   - 画面缩放\n   - 宽高比\n   - 默认方向\n   - 允许自动旋转的方向\n   - 其他设置\n\n## 4. 启动时的画面logo\n   - 可以在 Splash Image 中选择好启动标志和动画（免费个人版受到限制，无法取消unity自带logo）\n\n## 5. 其他设置\n   - **Ohter Settings**\n      - 选择 Auto Graphics API *(如不选择，默认Vulkan、OpenGLES3、OpenGLES2的顺序，某些设备会标识硬件不支持)\n   - 填写好 Package Name **注意：包名中不能有数字和特殊符号**\n   - 选择好 Minimum API Level 和 Target API Level （automatic（highest installed））\n   - Scripting Backend 用 mono\n   - install Location 选择 Automatic *(默认是 Prefer External , 会导致某些sd卡有问题的虚拟机或者真机无法安装)*\n\n## 6. 发布设置 签名打包\n   - **Publishing Settings**\n      - **首次没有签名key，选择创建新的keystore**\n         - 选择 Browse Keystore 在资源管理器中选择存储在哪里\n         - 在 Keystore password 中输入要创建key的密码，然后下面确认密码\n         - 在 Key 中 Alias 选择 Create a new key\n         - 在弹出框中填写好 Alias , Password , Confirm \n         - 点击 Create key\n         - 在 Password 中填写密码\n      - **在有签名时，选择 Use Existing Keystore**\n         - 选择 Browse Keystore 找到key\n         - 填写 Keystore password , confirm keystore password \n         - 选择 Alias 中key的名字 以及 对应的密码\n\n## 7. unity 直接生成apk\n   - Texture Compression ETC(default)\n   - ETC2 fallback 32-bit\n   - Build System Gradle *(在19之前的版本有这个选项可以选择internal，19的版本没有这个选项，只能使用Gradle)*\n   - 点击 Build 选择apk要存储的位置，开始生成apk\n\n## 8. unity 导出工程 AndroidStudio 二次开发\n   - 选择 Gradle , ExportProject , DevelopmentBuild\n   - 点击 Export ，导出项目\n   - **用AndroidStudio打开项目**\n      - AS会问，用AS的SDK还是项目的，推荐选择AS中的SDK，方便后续适配开发\n      - AS会问，Gradle是用的项目的还是下载最新的，推荐点cancel，使用项目的Gradle\n      - 在代理设置好，网络畅通的情况下，项目会由Gradle自动同步生成Android项目\n      - 在AS中创建好目标配置的虚拟机，就可以点击 Run 运行项目到目标硬件机器\n\n","source":"_posts/Unity导出Android工程.md","raw":"---\ntitle: Unity导出Android工程\nauthor: SmalBox\ncover: false\ntop: false\ndate: 2019-11-25 00:52:34\ncategories:\n   - Unity\ntags:\n   - Unity\n   - Android\n   - Export\n---\n# unity导出apk & 导出工程到AndroidStudio二次开发\n\n本文将Uniyt导出Android工程的过程中需要注意的事项进行了阐述，对导出Android工程有其他疑问，可评论或邮箱联系我。\n\n## 0. 项目准备\n   - **unity 中配置 Android环境**\n      - Edit -> Preferences\n      - External Tools -> Adnroid 中选择好SDK JDK（默认安装Openjdk） NDK\n      - *（在可以用unity hub的版本里，直接可安装好这三个模块，其中jdk和ndk可以用默认的，sdk可以选择AndroidStudio中安装）*\n      - *(如果想要在 unity 中代理，须在在系统环境变量中添加HTTP_Proxy http://127.0.0.1:端口号 和 HTTPS_Proxy https://127.0.0.1:端口号)*\n\n   - **AndroidStudio中配置环境(在[Android中文网](https://developer.android.google.cn/)下载AndroidStudio，建议3.1版本便于下载SDK)**\n      - File -> Settings\n      - **搜索 HTTP Proxy 设置代理**\n         - Manual proxy configuration 中 设置 127.0.0.1 端口为本地外网开放端口\n         - 点击 check connection 输入 android.com 检测是否代理成功\n         *（设置代理成功可以下载sdk，更新包，在同步包时可以避免Gradle工具无法连接服务器，下载缓存而报错）*\n      - **搜索 Android SDK 安装设置SDK**\n         - 在 SDK Plantforms 中选择要安装的SDK和SDK工具\n         - 在 SDK Update Sites 中选择Force https://... sources to be fetched using http://... 和 disable SDK diff patching\n         - Apply后开始下载SDK\n\n## 1. 选择平台\n   - File -> BuildSettings 选择切换 android 平台\n\n## 2. 项目设置-玩家设置\n   - Edit -> ProjectSetting -> Player\n   - 填写 Company Name , Product Name\n\n## 3. 分辨率设置\n   - 启动是否全屏，是否渲染外部安全区域等\n   - 画面缩放\n   - 宽高比\n   - 默认方向\n   - 允许自动旋转的方向\n   - 其他设置\n\n## 4. 启动时的画面logo\n   - 可以在 Splash Image 中选择好启动标志和动画（免费个人版受到限制，无法取消unity自带logo）\n\n## 5. 其他设置\n   - **Ohter Settings**\n      - 选择 Auto Graphics API *(如不选择，默认Vulkan、OpenGLES3、OpenGLES2的顺序，某些设备会标识硬件不支持)\n   - 填写好 Package Name **注意：包名中不能有数字和特殊符号**\n   - 选择好 Minimum API Level 和 Target API Level （automatic（highest installed））\n   - Scripting Backend 用 mono\n   - install Location 选择 Automatic *(默认是 Prefer External , 会导致某些sd卡有问题的虚拟机或者真机无法安装)*\n\n## 6. 发布设置 签名打包\n   - **Publishing Settings**\n      - **首次没有签名key，选择创建新的keystore**\n         - 选择 Browse Keystore 在资源管理器中选择存储在哪里\n         - 在 Keystore password 中输入要创建key的密码，然后下面确认密码\n         - 在 Key 中 Alias 选择 Create a new key\n         - 在弹出框中填写好 Alias , Password , Confirm \n         - 点击 Create key\n         - 在 Password 中填写密码\n      - **在有签名时，选择 Use Existing Keystore**\n         - 选择 Browse Keystore 找到key\n         - 填写 Keystore password , confirm keystore password \n         - 选择 Alias 中key的名字 以及 对应的密码\n\n## 7. unity 直接生成apk\n   - Texture Compression ETC(default)\n   - ETC2 fallback 32-bit\n   - Build System Gradle *(在19之前的版本有这个选项可以选择internal，19的版本没有这个选项，只能使用Gradle)*\n   - 点击 Build 选择apk要存储的位置，开始生成apk\n\n## 8. unity 导出工程 AndroidStudio 二次开发\n   - 选择 Gradle , ExportProject , DevelopmentBuild\n   - 点击 Export ，导出项目\n   - **用AndroidStudio打开项目**\n      - AS会问，用AS的SDK还是项目的，推荐选择AS中的SDK，方便后续适配开发\n      - AS会问，Gradle是用的项目的还是下载最新的，推荐点cancel，使用项目的Gradle\n      - 在代理设置好，网络畅通的情况下，项目会由Gradle自动同步生成Android项目\n      - 在AS中创建好目标配置的虚拟机，就可以点击 Run 运行项目到目标硬件机器\n\n","slug":"Unity导出Android工程","published":1,"updated":"2020-04-04T14:20:27.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptihx000xbsfowiihbnqt","content":"<h1 id=\"unity导出apk-amp-导出工程到AndroidStudio二次开发\"><a href=\"#unity导出apk-amp-导出工程到AndroidStudio二次开发\" class=\"headerlink\" title=\"unity导出apk &amp; 导出工程到AndroidStudio二次开发\"></a>unity导出apk &amp; 导出工程到AndroidStudio二次开发</h1><p>本文将Uniyt导出Android工程的过程中需要注意的事项进行了阐述，对导出Android工程有其他疑问，可评论或邮箱联系我。</p>\n<h2 id=\"0-项目准备\"><a href=\"#0-项目准备\" class=\"headerlink\" title=\"0. 项目准备\"></a>0. 项目准备</h2><ul>\n<li><p><strong>unity 中配置 Android环境</strong></p>\n<ul>\n<li>Edit -&gt; Preferences</li>\n<li>External Tools -&gt; Adnroid 中选择好SDK JDK（默认安装Openjdk） NDK</li>\n<li><em>（在可以用unity hub的版本里，直接可安装好这三个模块，其中jdk和ndk可以用默认的，sdk可以选择AndroidStudio中安装）</em></li>\n<li><em>(如果想要在 unity 中代理，须在在系统环境变量中添加HTTP_Proxy <a href=\"http://127.0.0.1:端口号\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:端口号</a> 和 HTTPS_Proxy <a href=\"https://127.0.0.1:端口号\" target=\"_blank\" rel=\"noopener\">https://127.0.0.1:端口号</a>)</em></li>\n</ul>\n</li>\n<li><p><strong>AndroidStudio中配置环境(在<a href=\"https://developer.android.google.cn/\" target=\"_blank\" rel=\"noopener\">Android中文网</a>下载AndroidStudio，建议3.1版本便于下载SDK)</strong></p>\n<ul>\n<li>File -&gt; Settings</li>\n<li><strong>搜索 HTTP Proxy 设置代理</strong><ul>\n<li>Manual proxy configuration 中 设置 127.0.0.1 端口为本地外网开放端口</li>\n<li>点击 check connection 输入 android.com 检测是否代理成功<br><em>（设置代理成功可以下载sdk，更新包，在同步包时可以避免Gradle工具无法连接服务器，下载缓存而报错）</em></li>\n</ul>\n</li>\n<li><strong>搜索 Android SDK 安装设置SDK</strong><ul>\n<li>在 SDK Plantforms 中选择要安装的SDK和SDK工具</li>\n<li>在 SDK Update Sites 中选择Force https://… sources to be fetched using http://… 和 disable SDK diff patching</li>\n<li>Apply后开始下载SDK</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-选择平台\"><a href=\"#1-选择平台\" class=\"headerlink\" title=\"1. 选择平台\"></a>1. 选择平台</h2><ul>\n<li>File -&gt; BuildSettings 选择切换 android 平台</li>\n</ul>\n<h2 id=\"2-项目设置-玩家设置\"><a href=\"#2-项目设置-玩家设置\" class=\"headerlink\" title=\"2. 项目设置-玩家设置\"></a>2. 项目设置-玩家设置</h2><ul>\n<li>Edit -&gt; ProjectSetting -&gt; Player</li>\n<li>填写 Company Name , Product Name</li>\n</ul>\n<h2 id=\"3-分辨率设置\"><a href=\"#3-分辨率设置\" class=\"headerlink\" title=\"3. 分辨率设置\"></a>3. 分辨率设置</h2><ul>\n<li>启动是否全屏，是否渲染外部安全区域等</li>\n<li>画面缩放</li>\n<li>宽高比</li>\n<li>默认方向</li>\n<li>允许自动旋转的方向</li>\n<li>其他设置</li>\n</ul>\n<h2 id=\"4-启动时的画面logo\"><a href=\"#4-启动时的画面logo\" class=\"headerlink\" title=\"4. 启动时的画面logo\"></a>4. 启动时的画面logo</h2><ul>\n<li>可以在 Splash Image 中选择好启动标志和动画（免费个人版受到限制，无法取消unity自带logo）</li>\n</ul>\n<h2 id=\"5-其他设置\"><a href=\"#5-其他设置\" class=\"headerlink\" title=\"5. 其他设置\"></a>5. 其他设置</h2><ul>\n<li><strong>Ohter Settings</strong><ul>\n<li>选择 Auto Graphics API *(如不选择，默认Vulkan、OpenGLES3、OpenGLES2的顺序，某些设备会标识硬件不支持)</li>\n</ul>\n</li>\n<li>填写好 Package Name <strong>注意：包名中不能有数字和特殊符号</strong></li>\n<li>选择好 Minimum API Level 和 Target API Level （automatic（highest installed））</li>\n<li>Scripting Backend 用 mono</li>\n<li>install Location 选择 Automatic <em>(默认是 Prefer External , 会导致某些sd卡有问题的虚拟机或者真机无法安装)</em></li>\n</ul>\n<h2 id=\"6-发布设置-签名打包\"><a href=\"#6-发布设置-签名打包\" class=\"headerlink\" title=\"6. 发布设置 签名打包\"></a>6. 发布设置 签名打包</h2><ul>\n<li><strong>Publishing Settings</strong><ul>\n<li><strong>首次没有签名key，选择创建新的keystore</strong><ul>\n<li>选择 Browse Keystore 在资源管理器中选择存储在哪里</li>\n<li>在 Keystore password 中输入要创建key的密码，然后下面确认密码</li>\n<li>在 Key 中 Alias 选择 Create a new key</li>\n<li>在弹出框中填写好 Alias , Password , Confirm </li>\n<li>点击 Create key</li>\n<li>在 Password 中填写密码</li>\n</ul>\n</li>\n<li><strong>在有签名时，选择 Use Existing Keystore</strong><ul>\n<li>选择 Browse Keystore 找到key</li>\n<li>填写 Keystore password , confirm keystore password </li>\n<li>选择 Alias 中key的名字 以及 对应的密码</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"7-unity-直接生成apk\"><a href=\"#7-unity-直接生成apk\" class=\"headerlink\" title=\"7. unity 直接生成apk\"></a>7. unity 直接生成apk</h2><ul>\n<li>Texture Compression ETC(default)</li>\n<li>ETC2 fallback 32-bit</li>\n<li>Build System Gradle <em>(在19之前的版本有这个选项可以选择internal，19的版本没有这个选项，只能使用Gradle)</em></li>\n<li>点击 Build 选择apk要存储的位置，开始生成apk</li>\n</ul>\n<h2 id=\"8-unity-导出工程-AndroidStudio-二次开发\"><a href=\"#8-unity-导出工程-AndroidStudio-二次开发\" class=\"headerlink\" title=\"8. unity 导出工程 AndroidStudio 二次开发\"></a>8. unity 导出工程 AndroidStudio 二次开发</h2><ul>\n<li>选择 Gradle , ExportProject , DevelopmentBuild</li>\n<li>点击 Export ，导出项目</li>\n<li><strong>用AndroidStudio打开项目</strong><ul>\n<li>AS会问，用AS的SDK还是项目的，推荐选择AS中的SDK，方便后续适配开发</li>\n<li>AS会问，Gradle是用的项目的还是下载最新的，推荐点cancel，使用项目的Gradle</li>\n<li>在代理设置好，网络畅通的情况下，项目会由Gradle自动同步生成Android项目</li>\n<li>在AS中创建好目标配置的虚拟机，就可以点击 Run 运行项目到目标硬件机器</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"unity导出apk-amp-导出工程到AndroidStudio二次开发\"><a href=\"#unity导出apk-amp-导出工程到AndroidStudio二次开发\" class=\"headerlink\" title=\"unity导出apk &amp; 导出工程到AndroidStudio二次开发\"></a>unity导出apk &amp; 导出工程到AndroidStudio二次开发</h1><p>本文将Uniyt导出Android工程的过程中需要注意的事项进行了阐述，对导出Android工程有其他疑问，可评论或邮箱联系我。</p>\n<h2 id=\"0-项目准备\"><a href=\"#0-项目准备\" class=\"headerlink\" title=\"0. 项目准备\"></a>0. 项目准备</h2><ul>\n<li><p><strong>unity 中配置 Android环境</strong></p>\n<ul>\n<li>Edit -&gt; Preferences</li>\n<li>External Tools -&gt; Adnroid 中选择好SDK JDK（默认安装Openjdk） NDK</li>\n<li><em>（在可以用unity hub的版本里，直接可安装好这三个模块，其中jdk和ndk可以用默认的，sdk可以选择AndroidStudio中安装）</em></li>\n<li><em>(如果想要在 unity 中代理，须在在系统环境变量中添加HTTP_Proxy <a href=\"http://127.0.0.1:端口号\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:端口号</a> 和 HTTPS_Proxy <a href=\"https://127.0.0.1:端口号\" target=\"_blank\" rel=\"noopener\">https://127.0.0.1:端口号</a>)</em></li>\n</ul>\n</li>\n<li><p><strong>AndroidStudio中配置环境(在<a href=\"https://developer.android.google.cn/\" target=\"_blank\" rel=\"noopener\">Android中文网</a>下载AndroidStudio，建议3.1版本便于下载SDK)</strong></p>\n<ul>\n<li>File -&gt; Settings</li>\n<li><strong>搜索 HTTP Proxy 设置代理</strong><ul>\n<li>Manual proxy configuration 中 设置 127.0.0.1 端口为本地外网开放端口</li>\n<li>点击 check connection 输入 android.com 检测是否代理成功<br><em>（设置代理成功可以下载sdk，更新包，在同步包时可以避免Gradle工具无法连接服务器，下载缓存而报错）</em></li>\n</ul>\n</li>\n<li><strong>搜索 Android SDK 安装设置SDK</strong><ul>\n<li>在 SDK Plantforms 中选择要安装的SDK和SDK工具</li>\n<li>在 SDK Update Sites 中选择Force https://… sources to be fetched using http://… 和 disable SDK diff patching</li>\n<li>Apply后开始下载SDK</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-选择平台\"><a href=\"#1-选择平台\" class=\"headerlink\" title=\"1. 选择平台\"></a>1. 选择平台</h2><ul>\n<li>File -&gt; BuildSettings 选择切换 android 平台</li>\n</ul>\n<h2 id=\"2-项目设置-玩家设置\"><a href=\"#2-项目设置-玩家设置\" class=\"headerlink\" title=\"2. 项目设置-玩家设置\"></a>2. 项目设置-玩家设置</h2><ul>\n<li>Edit -&gt; ProjectSetting -&gt; Player</li>\n<li>填写 Company Name , Product Name</li>\n</ul>\n<h2 id=\"3-分辨率设置\"><a href=\"#3-分辨率设置\" class=\"headerlink\" title=\"3. 分辨率设置\"></a>3. 分辨率设置</h2><ul>\n<li>启动是否全屏，是否渲染外部安全区域等</li>\n<li>画面缩放</li>\n<li>宽高比</li>\n<li>默认方向</li>\n<li>允许自动旋转的方向</li>\n<li>其他设置</li>\n</ul>\n<h2 id=\"4-启动时的画面logo\"><a href=\"#4-启动时的画面logo\" class=\"headerlink\" title=\"4. 启动时的画面logo\"></a>4. 启动时的画面logo</h2><ul>\n<li>可以在 Splash Image 中选择好启动标志和动画（免费个人版受到限制，无法取消unity自带logo）</li>\n</ul>\n<h2 id=\"5-其他设置\"><a href=\"#5-其他设置\" class=\"headerlink\" title=\"5. 其他设置\"></a>5. 其他设置</h2><ul>\n<li><strong>Ohter Settings</strong><ul>\n<li>选择 Auto Graphics API *(如不选择，默认Vulkan、OpenGLES3、OpenGLES2的顺序，某些设备会标识硬件不支持)</li>\n</ul>\n</li>\n<li>填写好 Package Name <strong>注意：包名中不能有数字和特殊符号</strong></li>\n<li>选择好 Minimum API Level 和 Target API Level （automatic（highest installed））</li>\n<li>Scripting Backend 用 mono</li>\n<li>install Location 选择 Automatic <em>(默认是 Prefer External , 会导致某些sd卡有问题的虚拟机或者真机无法安装)</em></li>\n</ul>\n<h2 id=\"6-发布设置-签名打包\"><a href=\"#6-发布设置-签名打包\" class=\"headerlink\" title=\"6. 发布设置 签名打包\"></a>6. 发布设置 签名打包</h2><ul>\n<li><strong>Publishing Settings</strong><ul>\n<li><strong>首次没有签名key，选择创建新的keystore</strong><ul>\n<li>选择 Browse Keystore 在资源管理器中选择存储在哪里</li>\n<li>在 Keystore password 中输入要创建key的密码，然后下面确认密码</li>\n<li>在 Key 中 Alias 选择 Create a new key</li>\n<li>在弹出框中填写好 Alias , Password , Confirm </li>\n<li>点击 Create key</li>\n<li>在 Password 中填写密码</li>\n</ul>\n</li>\n<li><strong>在有签名时，选择 Use Existing Keystore</strong><ul>\n<li>选择 Browse Keystore 找到key</li>\n<li>填写 Keystore password , confirm keystore password </li>\n<li>选择 Alias 中key的名字 以及 对应的密码</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"7-unity-直接生成apk\"><a href=\"#7-unity-直接生成apk\" class=\"headerlink\" title=\"7. unity 直接生成apk\"></a>7. unity 直接生成apk</h2><ul>\n<li>Texture Compression ETC(default)</li>\n<li>ETC2 fallback 32-bit</li>\n<li>Build System Gradle <em>(在19之前的版本有这个选项可以选择internal，19的版本没有这个选项，只能使用Gradle)</em></li>\n<li>点击 Build 选择apk要存储的位置，开始生成apk</li>\n</ul>\n<h2 id=\"8-unity-导出工程-AndroidStudio-二次开发\"><a href=\"#8-unity-导出工程-AndroidStudio-二次开发\" class=\"headerlink\" title=\"8. unity 导出工程 AndroidStudio 二次开发\"></a>8. unity 导出工程 AndroidStudio 二次开发</h2><ul>\n<li>选择 Gradle , ExportProject , DevelopmentBuild</li>\n<li>点击 Export ，导出项目</li>\n<li><strong>用AndroidStudio打开项目</strong><ul>\n<li>AS会问，用AS的SDK还是项目的，推荐选择AS中的SDK，方便后续适配开发</li>\n<li>AS会问，Gradle是用的项目的还是下载最新的，推荐点cancel，使用项目的Gradle</li>\n<li>在代理设置好，网络畅通的情况下，项目会由Gradle自动同步生成Android项目</li>\n<li>在AS中创建好目标配置的虚拟机，就可以点击 Run 运行项目到目标硬件机器</li>\n</ul>\n</li>\n</ul>\n"},{"title":"视频编码与封装","date":"2018-10-28T09:09:46.000Z","author":"SmalBox","_content":"# 视频编码与封装\n\n## 前言\n\n  通常所说的**视频格式**，其实是视频文件的**封装格式**，而为什么在 final cut pro 中就能流畅的剪辑影片，同样的或者硬件配置更强大的pc机上往往就没有那么流畅的预览影片呢。\n\n  这除了apple在系统层面做了优化，还有最为重要的就是**视频的编码格式**。\n\n  来了解视频文件的构成从而让视频剪辑更为流畅。\n\n## 概要\n\n  - 视频文件的构成\n  - 不可忽视的音频\n  - 视频编码方式\n  - 视频编码格式\n  - 视频封装格式\n  - 视频播放的码率\n  - 高效的剪辑工作流（最终目标）\n\n## **视频文件的构成**\n\n要了解视频的编码前，需要先了解一下视频文件中到底包含了什么。\n\n  1. 视频中的**图像**\n  2. 对应的**音频**\n  3. 一些媒体信息\n     - **帧率**（例如：H.264）\n     - **码率**（例如：25fps） \n     - **字幕文件**\n     - **拍摄机器等信息**\n  4. **封装格式**（例如；mov、mp4、mkv、ogg）\n\n## **不可忽视的音频**\n\n视频中的音频相对图像来说简单一些，但是他的作用是不可忽视的，好的音质能让视频观感大幅提升（例如：国内的恐怖片如果没了音频基本上就是个闹剧了）。好的音频节奏和图像的配合才是好的视频。\n\n音频主要上还是两种\n\n  1. **有损音频**\n     - 常用格式有 mp3、acc\n  2. **无损音频**\n     - 常用格式欧 wav、aiff\n\n*在网络上常规的音频设置为：48khz/192kbps*\n\n## **视频编码的方式**\n\n**这部分就是重点了！！！**\n\n前言部分讲述的让视频剪辑更为流畅的核心就在于此了。\n\n一个视频文件是通过不同的图像编码方式将其图像编码，再加上他的音频，字幕文件，拍摄机器等其他信息组建完成，最后通过不同的封装格式呈现给大家。\n\n大家看到的不同的视频文件比如mp4，mov都是封装格式，而决定能否流畅的是其中的编码格式。\n\n编码方式分两种：\n\n   1. **帧内编码（运算少，文件大）**\n   2. **帧间编码（运算多，文件小）**\n\n  - **帧内编码**\n     - 帧内编码是将**每一帧的画面进行压缩**，然后组成的视频。所以采用帧内编码格式的视频在剪辑的预览中，肯定是更加流畅。带来的副作用是由于每一帧都在所以视频文件就会比较大，这也就是为什么在视频编辑的时候为什么要大内存大原因了。\n     \n     - 了解了帧内编码的特性，不难看出，帧内编码更适合在**剪辑的时候使用**，能加快剪辑时预览的速度（也就是所谓的不卡）。\n\n  - **帧间编码**\n     - 帧间编码是保留一部分帧，**空缺下来的帧通过在播放时解码器的运算来生成**。这样做的后果就是预览时会增大处理的负荷，在剪辑中最直接的表现就是需要耐心的等待渲染才能预览。好处就是指存储了一部分的帧，能有效的减小视频文件的大小。\n\n     - 帧间编码格式的最大优点就是**文件小**，所以最适合在视频编辑完成后的生成导出。\n\n## **编码格式**\n\n了解了编码方式就能够看出，想要高效的**剪辑**就需要**帧内编码**，想要**视频传播**则需要**帧间编码**。\n\n常用的编码格式：\n\n|编码格式|编码方式|特点|\n|:-:|:-:|:-:|\n|h.264(mpeg4) | 帧间编码 | 网络传播最佳 |\n|mpeg2(dvd) | 帧间编码 | 过时 |\n|h.265(hevc) | 帧间编码 | 未普及 |\n|proes(apple) | 帧内编码 | 高效&优良 |\n|dhxhd/hr(avid) | 帧内编码 | win支持最佳 |\n|cineform(gropro) | 帧内编码 | 最佳 |\n\n## **封装格式**\n\n封装格式是最常说的，他就在文件的**尾缀**上。\n\n常用的封装格式有：\n\n|封装格式|对编码的支持|\n|:-:|:-:|:-:|\n|Mov（apple）| 优良 |\n|mp4（动态图像专家组）|  最佳 |\n|mkv/ogg（开源）| 软件支持不足 |\n|wmv（Microsoft）| 兼容性低下 |\n|AVCHD（松下/索尼）| 结构复杂（通过文件的方式组织）|\n|avi | 旧，不支持新编码 |\n\n## **播放码率**\n\n码率通常以秒为时间单位，一秒内包含的数据就是码率能够提供的信息。\n\n理论上分辨率越高的视频就会越清晰。但是当视频分辨率越高，但是码率比较低的时候，低分辨率的视频则会显示的更加清晰。因为低码率带来的信息量比较低，高分辨率的视频的每一帧相较于低分辨率的视频会更加模糊，所以会显得低分辨率的画质会更好一些。\n\n当然了，这种现象会随着码率的提高，低分辨率低视频在达到它清晰的极限时，高分辨率的视频画质就会超越低分辨率低视频。\n\n视频码率通常的单位为 **mbps**（Million bits per second），**MBs**。\n\n音频码率通常为**kbps**。\n\n换算单位是：\n   - 8bits = 1byte\n   - 1mbps = 0.125bit/s\n\n## **高效的剪辑工作流（最终目标）**\n\n经过以上的对比分析，最佳的**视频剪辑方式**是用**mov**格式的视频素材进行**剪辑调色**等工作，而最后**成片**导出为**mp4**格式放到网络上。\n\n||剪辑/调色|网络传输|\n|:-:|:-:|:-:|\n|编码方式 | 帧内编码 | 帧间编码 |\n|编码格式 | prores/cineform | H.264 |\n|封装格式 | mov | mp4 |\n\n知道了视频的编码与封装就不用纠结是mac还是win的问题了，只要**选对了编码**那编辑起来都是行云流水的。*（另外adobe的encoder真的很厉害）*\n\n*有任何关于本文内容的问题，可以在下方评论，或者邮件联系联系我。*","source":"_posts/视频编码与封装.md","raw":"---\ntitle: 视频编码与封装\ndate: 2018-10-28 17:09:46\nauthor: SmalBox\ncategories: 笔记\ntags:\n  - 视频编码\n  - 视频封装\n---\n# 视频编码与封装\n\n## 前言\n\n  通常所说的**视频格式**，其实是视频文件的**封装格式**，而为什么在 final cut pro 中就能流畅的剪辑影片，同样的或者硬件配置更强大的pc机上往往就没有那么流畅的预览影片呢。\n\n  这除了apple在系统层面做了优化，还有最为重要的就是**视频的编码格式**。\n\n  来了解视频文件的构成从而让视频剪辑更为流畅。\n\n## 概要\n\n  - 视频文件的构成\n  - 不可忽视的音频\n  - 视频编码方式\n  - 视频编码格式\n  - 视频封装格式\n  - 视频播放的码率\n  - 高效的剪辑工作流（最终目标）\n\n## **视频文件的构成**\n\n要了解视频的编码前，需要先了解一下视频文件中到底包含了什么。\n\n  1. 视频中的**图像**\n  2. 对应的**音频**\n  3. 一些媒体信息\n     - **帧率**（例如：H.264）\n     - **码率**（例如：25fps） \n     - **字幕文件**\n     - **拍摄机器等信息**\n  4. **封装格式**（例如；mov、mp4、mkv、ogg）\n\n## **不可忽视的音频**\n\n视频中的音频相对图像来说简单一些，但是他的作用是不可忽视的，好的音质能让视频观感大幅提升（例如：国内的恐怖片如果没了音频基本上就是个闹剧了）。好的音频节奏和图像的配合才是好的视频。\n\n音频主要上还是两种\n\n  1. **有损音频**\n     - 常用格式有 mp3、acc\n  2. **无损音频**\n     - 常用格式欧 wav、aiff\n\n*在网络上常规的音频设置为：48khz/192kbps*\n\n## **视频编码的方式**\n\n**这部分就是重点了！！！**\n\n前言部分讲述的让视频剪辑更为流畅的核心就在于此了。\n\n一个视频文件是通过不同的图像编码方式将其图像编码，再加上他的音频，字幕文件，拍摄机器等其他信息组建完成，最后通过不同的封装格式呈现给大家。\n\n大家看到的不同的视频文件比如mp4，mov都是封装格式，而决定能否流畅的是其中的编码格式。\n\n编码方式分两种：\n\n   1. **帧内编码（运算少，文件大）**\n   2. **帧间编码（运算多，文件小）**\n\n  - **帧内编码**\n     - 帧内编码是将**每一帧的画面进行压缩**，然后组成的视频。所以采用帧内编码格式的视频在剪辑的预览中，肯定是更加流畅。带来的副作用是由于每一帧都在所以视频文件就会比较大，这也就是为什么在视频编辑的时候为什么要大内存大原因了。\n     \n     - 了解了帧内编码的特性，不难看出，帧内编码更适合在**剪辑的时候使用**，能加快剪辑时预览的速度（也就是所谓的不卡）。\n\n  - **帧间编码**\n     - 帧间编码是保留一部分帧，**空缺下来的帧通过在播放时解码器的运算来生成**。这样做的后果就是预览时会增大处理的负荷，在剪辑中最直接的表现就是需要耐心的等待渲染才能预览。好处就是指存储了一部分的帧，能有效的减小视频文件的大小。\n\n     - 帧间编码格式的最大优点就是**文件小**，所以最适合在视频编辑完成后的生成导出。\n\n## **编码格式**\n\n了解了编码方式就能够看出，想要高效的**剪辑**就需要**帧内编码**，想要**视频传播**则需要**帧间编码**。\n\n常用的编码格式：\n\n|编码格式|编码方式|特点|\n|:-:|:-:|:-:|\n|h.264(mpeg4) | 帧间编码 | 网络传播最佳 |\n|mpeg2(dvd) | 帧间编码 | 过时 |\n|h.265(hevc) | 帧间编码 | 未普及 |\n|proes(apple) | 帧内编码 | 高效&优良 |\n|dhxhd/hr(avid) | 帧内编码 | win支持最佳 |\n|cineform(gropro) | 帧内编码 | 最佳 |\n\n## **封装格式**\n\n封装格式是最常说的，他就在文件的**尾缀**上。\n\n常用的封装格式有：\n\n|封装格式|对编码的支持|\n|:-:|:-:|:-:|\n|Mov（apple）| 优良 |\n|mp4（动态图像专家组）|  最佳 |\n|mkv/ogg（开源）| 软件支持不足 |\n|wmv（Microsoft）| 兼容性低下 |\n|AVCHD（松下/索尼）| 结构复杂（通过文件的方式组织）|\n|avi | 旧，不支持新编码 |\n\n## **播放码率**\n\n码率通常以秒为时间单位，一秒内包含的数据就是码率能够提供的信息。\n\n理论上分辨率越高的视频就会越清晰。但是当视频分辨率越高，但是码率比较低的时候，低分辨率的视频则会显示的更加清晰。因为低码率带来的信息量比较低，高分辨率的视频的每一帧相较于低分辨率的视频会更加模糊，所以会显得低分辨率的画质会更好一些。\n\n当然了，这种现象会随着码率的提高，低分辨率低视频在达到它清晰的极限时，高分辨率的视频画质就会超越低分辨率低视频。\n\n视频码率通常的单位为 **mbps**（Million bits per second），**MBs**。\n\n音频码率通常为**kbps**。\n\n换算单位是：\n   - 8bits = 1byte\n   - 1mbps = 0.125bit/s\n\n## **高效的剪辑工作流（最终目标）**\n\n经过以上的对比分析，最佳的**视频剪辑方式**是用**mov**格式的视频素材进行**剪辑调色**等工作，而最后**成片**导出为**mp4**格式放到网络上。\n\n||剪辑/调色|网络传输|\n|:-:|:-:|:-:|\n|编码方式 | 帧内编码 | 帧间编码 |\n|编码格式 | prores/cineform | H.264 |\n|封装格式 | mov | mp4 |\n\n知道了视频的编码与封装就不用纠结是mac还是win的问题了，只要**选对了编码**那编辑起来都是行云流水的。*（另外adobe的encoder真的很厉害）*\n\n*有任何关于本文内容的问题，可以在下方评论，或者邮件联系联系我。*","slug":"视频编码与封装","published":1,"updated":"2019-11-24T16:25:24.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptii00010bsfo7mbebbxq","content":"<h1 id=\"视频编码与封装\"><a href=\"#视频编码与封装\" class=\"headerlink\" title=\"视频编码与封装\"></a>视频编码与封装</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>  通常所说的<strong>视频格式</strong>，其实是视频文件的<strong>封装格式</strong>，而为什么在 final cut pro 中就能流畅的剪辑影片，同样的或者硬件配置更强大的pc机上往往就没有那么流畅的预览影片呢。</p>\n<p>  这除了apple在系统层面做了优化，还有最为重要的就是<strong>视频的编码格式</strong>。</p>\n<p>  来了解视频文件的构成从而让视频剪辑更为流畅。</p>\n<h2 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h2><ul>\n<li>视频文件的构成</li>\n<li>不可忽视的音频</li>\n<li>视频编码方式</li>\n<li>视频编码格式</li>\n<li>视频封装格式</li>\n<li>视频播放的码率</li>\n<li>高效的剪辑工作流（最终目标）</li>\n</ul>\n<h2 id=\"视频文件的构成\"><a href=\"#视频文件的构成\" class=\"headerlink\" title=\"视频文件的构成\"></a><strong>视频文件的构成</strong></h2><p>要了解视频的编码前，需要先了解一下视频文件中到底包含了什么。</p>\n<ol>\n<li>视频中的<strong>图像</strong></li>\n<li>对应的<strong>音频</strong></li>\n<li>一些媒体信息<ul>\n<li><strong>帧率</strong>（例如：H.264）</li>\n<li><strong>码率</strong>（例如：25fps） </li>\n<li><strong>字幕文件</strong></li>\n<li><strong>拍摄机器等信息</strong></li>\n</ul>\n</li>\n<li><strong>封装格式</strong>（例如；mov、mp4、mkv、ogg）</li>\n</ol>\n<h2 id=\"不可忽视的音频\"><a href=\"#不可忽视的音频\" class=\"headerlink\" title=\"不可忽视的音频\"></a><strong>不可忽视的音频</strong></h2><p>视频中的音频相对图像来说简单一些，但是他的作用是不可忽视的，好的音质能让视频观感大幅提升（例如：国内的恐怖片如果没了音频基本上就是个闹剧了）。好的音频节奏和图像的配合才是好的视频。</p>\n<p>音频主要上还是两种</p>\n<ol>\n<li><strong>有损音频</strong><ul>\n<li>常用格式有 mp3、acc</li>\n</ul>\n</li>\n<li><strong>无损音频</strong><ul>\n<li>常用格式欧 wav、aiff</li>\n</ul>\n</li>\n</ol>\n<p><em>在网络上常规的音频设置为：48khz/192kbps</em></p>\n<h2 id=\"视频编码的方式\"><a href=\"#视频编码的方式\" class=\"headerlink\" title=\"视频编码的方式\"></a><strong>视频编码的方式</strong></h2><p><strong>这部分就是重点了！！！</strong></p>\n<p>前言部分讲述的让视频剪辑更为流畅的核心就在于此了。</p>\n<p>一个视频文件是通过不同的图像编码方式将其图像编码，再加上他的音频，字幕文件，拍摄机器等其他信息组建完成，最后通过不同的封装格式呈现给大家。</p>\n<p>大家看到的不同的视频文件比如mp4，mov都是封装格式，而决定能否流畅的是其中的编码格式。</p>\n<p>编码方式分两种：</p>\n<ol>\n<li><strong>帧内编码（运算少，文件大）</strong></li>\n<li><p><strong>帧间编码（运算多，文件小）</strong></p>\n<ul>\n<li><strong>帧内编码</strong></li>\n<li><p>帧内编码是将<strong>每一帧的画面进行压缩</strong>，然后组成的视频。所以采用帧内编码格式的视频在剪辑的预览中，肯定是更加流畅。带来的副作用是由于每一帧都在所以视频文件就会比较大，这也就是为什么在视频编辑的时候为什么要大内存大原因了。</p>\n</li>\n<li><p>了解了帧内编码的特性，不难看出，帧内编码更适合在<strong>剪辑的时候使用</strong>，能加快剪辑时预览的速度（也就是所谓的不卡）。</p>\n</li>\n<li><p><strong>帧间编码</strong></p>\n</li>\n<li><p>帧间编码是保留一部分帧，<strong>空缺下来的帧通过在播放时解码器的运算来生成</strong>。这样做的后果就是预览时会增大处理的负荷，在剪辑中最直接的表现就是需要耐心的等待渲染才能预览。好处就是指存储了一部分的帧，能有效的减小视频文件的大小。</p>\n</li>\n<li><p>帧间编码格式的最大优点就是<strong>文件小</strong>，所以最适合在视频编辑完成后的生成导出。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"编码格式\"><a href=\"#编码格式\" class=\"headerlink\" title=\"编码格式\"></a><strong>编码格式</strong></h2><p>了解了编码方式就能够看出，想要高效的<strong>剪辑</strong>就需要<strong>帧内编码</strong>，想要<strong>视频传播</strong>则需要<strong>帧间编码</strong>。</p>\n<p>常用的编码格式：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">编码格式</th>\n<th style=\"text-align:center\">编码方式</th>\n<th style=\"text-align:center\">特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">h.264(mpeg4)</td>\n<td style=\"text-align:center\">帧间编码</td>\n<td style=\"text-align:center\">网络传播最佳</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mpeg2(dvd)</td>\n<td style=\"text-align:center\">帧间编码</td>\n<td style=\"text-align:center\">过时</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">h.265(hevc)</td>\n<td style=\"text-align:center\">帧间编码</td>\n<td style=\"text-align:center\">未普及</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">proes(apple)</td>\n<td style=\"text-align:center\">帧内编码</td>\n<td style=\"text-align:center\">高效&amp;优良</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">dhxhd/hr(avid)</td>\n<td style=\"text-align:center\">帧内编码</td>\n<td style=\"text-align:center\">win支持最佳</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cineform(gropro)</td>\n<td style=\"text-align:center\">帧内编码</td>\n<td style=\"text-align:center\">最佳</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"封装格式\"><a href=\"#封装格式\" class=\"headerlink\" title=\"封装格式\"></a><strong>封装格式</strong></h2><p>封装格式是最常说的，他就在文件的<strong>尾缀</strong>上。</p>\n<p>常用的封装格式有：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">封装格式</th>\n<th style=\"text-align:center\">对编码的支持</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Mov（apple）</td>\n<td style=\"text-align:center\">优良</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mp4（动态图像专家组）</td>\n<td style=\"text-align:center\">最佳</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mkv/ogg（开源）</td>\n<td style=\"text-align:center\">软件支持不足</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wmv（Microsoft）</td>\n<td style=\"text-align:center\">兼容性低下</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">AVCHD（松下/索尼）</td>\n<td style=\"text-align:center\">结构复杂（通过文件的方式组织）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">avi</td>\n<td style=\"text-align:center\">旧，不支持新编码</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"播放码率\"><a href=\"#播放码率\" class=\"headerlink\" title=\"播放码率\"></a><strong>播放码率</strong></h2><p>码率通常以秒为时间单位，一秒内包含的数据就是码率能够提供的信息。</p>\n<p>理论上分辨率越高的视频就会越清晰。但是当视频分辨率越高，但是码率比较低的时候，低分辨率的视频则会显示的更加清晰。因为低码率带来的信息量比较低，高分辨率的视频的每一帧相较于低分辨率的视频会更加模糊，所以会显得低分辨率的画质会更好一些。</p>\n<p>当然了，这种现象会随着码率的提高，低分辨率低视频在达到它清晰的极限时，高分辨率的视频画质就会超越低分辨率低视频。</p>\n<p>视频码率通常的单位为 <strong>mbps</strong>（Million bits per second），<strong>MBs</strong>。</p>\n<p>音频码率通常为<strong>kbps</strong>。</p>\n<p>换算单位是：</p>\n<ul>\n<li>8bits = 1byte</li>\n<li>1mbps = 0.125bit/s</li>\n</ul>\n<h2 id=\"高效的剪辑工作流（最终目标）\"><a href=\"#高效的剪辑工作流（最终目标）\" class=\"headerlink\" title=\"高效的剪辑工作流（最终目标）\"></a><strong>高效的剪辑工作流（最终目标）</strong></h2><p>经过以上的对比分析，最佳的<strong>视频剪辑方式</strong>是用<strong>mov</strong>格式的视频素材进行<strong>剪辑调色</strong>等工作，而最后<strong>成片</strong>导出为<strong>mp4</strong>格式放到网络上。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">剪辑/调色</th>\n<th style=\"text-align:center\">网络传输</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">编码方式</td>\n<td style=\"text-align:center\">帧内编码</td>\n<td style=\"text-align:center\">帧间编码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">编码格式</td>\n<td style=\"text-align:center\">prores/cineform</td>\n<td style=\"text-align:center\">H.264</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">封装格式</td>\n<td style=\"text-align:center\">mov</td>\n<td style=\"text-align:center\">mp4</td>\n</tr>\n</tbody>\n</table>\n<p>知道了视频的编码与封装就不用纠结是mac还是win的问题了，只要<strong>选对了编码</strong>那编辑起来都是行云流水的。<em>（另外adobe的encoder真的很厉害）</em></p>\n<p><em>有任何关于本文内容的问题，可以在下方评论，或者邮件联系联系我。</em></p>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"视频编码与封装\"><a href=\"#视频编码与封装\" class=\"headerlink\" title=\"视频编码与封装\"></a>视频编码与封装</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>  通常所说的<strong>视频格式</strong>，其实是视频文件的<strong>封装格式</strong>，而为什么在 final cut pro 中就能流畅的剪辑影片，同样的或者硬件配置更强大的pc机上往往就没有那么流畅的预览影片呢。</p>\n<p>  这除了apple在系统层面做了优化，还有最为重要的就是<strong>视频的编码格式</strong>。</p>\n<p>  来了解视频文件的构成从而让视频剪辑更为流畅。</p>\n<h2 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h2><ul>\n<li>视频文件的构成</li>\n<li>不可忽视的音频</li>\n<li>视频编码方式</li>\n<li>视频编码格式</li>\n<li>视频封装格式</li>\n<li>视频播放的码率</li>\n<li>高效的剪辑工作流（最终目标）</li>\n</ul>\n<h2 id=\"视频文件的构成\"><a href=\"#视频文件的构成\" class=\"headerlink\" title=\"视频文件的构成\"></a><strong>视频文件的构成</strong></h2><p>要了解视频的编码前，需要先了解一下视频文件中到底包含了什么。</p>\n<ol>\n<li>视频中的<strong>图像</strong></li>\n<li>对应的<strong>音频</strong></li>\n<li>一些媒体信息<ul>\n<li><strong>帧率</strong>（例如：H.264）</li>\n<li><strong>码率</strong>（例如：25fps） </li>\n<li><strong>字幕文件</strong></li>\n<li><strong>拍摄机器等信息</strong></li>\n</ul>\n</li>\n<li><strong>封装格式</strong>（例如；mov、mp4、mkv、ogg）</li>\n</ol>\n<h2 id=\"不可忽视的音频\"><a href=\"#不可忽视的音频\" class=\"headerlink\" title=\"不可忽视的音频\"></a><strong>不可忽视的音频</strong></h2><p>视频中的音频相对图像来说简单一些，但是他的作用是不可忽视的，好的音质能让视频观感大幅提升（例如：国内的恐怖片如果没了音频基本上就是个闹剧了）。好的音频节奏和图像的配合才是好的视频。</p>\n<p>音频主要上还是两种</p>\n<ol>\n<li><strong>有损音频</strong><ul>\n<li>常用格式有 mp3、acc</li>\n</ul>\n</li>\n<li><strong>无损音频</strong><ul>\n<li>常用格式欧 wav、aiff</li>\n</ul>\n</li>\n</ol>\n<p><em>在网络上常规的音频设置为：48khz/192kbps</em></p>\n<h2 id=\"视频编码的方式\"><a href=\"#视频编码的方式\" class=\"headerlink\" title=\"视频编码的方式\"></a><strong>视频编码的方式</strong></h2><p><strong>这部分就是重点了！！！</strong></p>\n<p>前言部分讲述的让视频剪辑更为流畅的核心就在于此了。</p>\n<p>一个视频文件是通过不同的图像编码方式将其图像编码，再加上他的音频，字幕文件，拍摄机器等其他信息组建完成，最后通过不同的封装格式呈现给大家。</p>\n<p>大家看到的不同的视频文件比如mp4，mov都是封装格式，而决定能否流畅的是其中的编码格式。</p>\n<p>编码方式分两种：</p>\n<ol>\n<li><strong>帧内编码（运算少，文件大）</strong></li>\n<li><p><strong>帧间编码（运算多，文件小）</strong></p>\n<ul>\n<li><strong>帧内编码</strong></li>\n<li><p>帧内编码是将<strong>每一帧的画面进行压缩</strong>，然后组成的视频。所以采用帧内编码格式的视频在剪辑的预览中，肯定是更加流畅。带来的副作用是由于每一帧都在所以视频文件就会比较大，这也就是为什么在视频编辑的时候为什么要大内存大原因了。</p>\n</li>\n<li><p>了解了帧内编码的特性，不难看出，帧内编码更适合在<strong>剪辑的时候使用</strong>，能加快剪辑时预览的速度（也就是所谓的不卡）。</p>\n</li>\n<li><p><strong>帧间编码</strong></p>\n</li>\n<li><p>帧间编码是保留一部分帧，<strong>空缺下来的帧通过在播放时解码器的运算来生成</strong>。这样做的后果就是预览时会增大处理的负荷，在剪辑中最直接的表现就是需要耐心的等待渲染才能预览。好处就是指存储了一部分的帧，能有效的减小视频文件的大小。</p>\n</li>\n<li><p>帧间编码格式的最大优点就是<strong>文件小</strong>，所以最适合在视频编辑完成后的生成导出。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"编码格式\"><a href=\"#编码格式\" class=\"headerlink\" title=\"编码格式\"></a><strong>编码格式</strong></h2><p>了解了编码方式就能够看出，想要高效的<strong>剪辑</strong>就需要<strong>帧内编码</strong>，想要<strong>视频传播</strong>则需要<strong>帧间编码</strong>。</p>\n<p>常用的编码格式：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">编码格式</th>\n<th style=\"text-align:center\">编码方式</th>\n<th style=\"text-align:center\">特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">h.264(mpeg4)</td>\n<td style=\"text-align:center\">帧间编码</td>\n<td style=\"text-align:center\">网络传播最佳</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mpeg2(dvd)</td>\n<td style=\"text-align:center\">帧间编码</td>\n<td style=\"text-align:center\">过时</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">h.265(hevc)</td>\n<td style=\"text-align:center\">帧间编码</td>\n<td style=\"text-align:center\">未普及</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">proes(apple)</td>\n<td style=\"text-align:center\">帧内编码</td>\n<td style=\"text-align:center\">高效&amp;优良</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">dhxhd/hr(avid)</td>\n<td style=\"text-align:center\">帧内编码</td>\n<td style=\"text-align:center\">win支持最佳</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cineform(gropro)</td>\n<td style=\"text-align:center\">帧内编码</td>\n<td style=\"text-align:center\">最佳</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"封装格式\"><a href=\"#封装格式\" class=\"headerlink\" title=\"封装格式\"></a><strong>封装格式</strong></h2><p>封装格式是最常说的，他就在文件的<strong>尾缀</strong>上。</p>\n<p>常用的封装格式有：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">封装格式</th>\n<th style=\"text-align:center\">对编码的支持</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Mov（apple）</td>\n<td style=\"text-align:center\">优良</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mp4（动态图像专家组）</td>\n<td style=\"text-align:center\">最佳</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mkv/ogg（开源）</td>\n<td style=\"text-align:center\">软件支持不足</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wmv（Microsoft）</td>\n<td style=\"text-align:center\">兼容性低下</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">AVCHD（松下/索尼）</td>\n<td style=\"text-align:center\">结构复杂（通过文件的方式组织）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">avi</td>\n<td style=\"text-align:center\">旧，不支持新编码</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"播放码率\"><a href=\"#播放码率\" class=\"headerlink\" title=\"播放码率\"></a><strong>播放码率</strong></h2><p>码率通常以秒为时间单位，一秒内包含的数据就是码率能够提供的信息。</p>\n<p>理论上分辨率越高的视频就会越清晰。但是当视频分辨率越高，但是码率比较低的时候，低分辨率的视频则会显示的更加清晰。因为低码率带来的信息量比较低，高分辨率的视频的每一帧相较于低分辨率的视频会更加模糊，所以会显得低分辨率的画质会更好一些。</p>\n<p>当然了，这种现象会随着码率的提高，低分辨率低视频在达到它清晰的极限时，高分辨率的视频画质就会超越低分辨率低视频。</p>\n<p>视频码率通常的单位为 <strong>mbps</strong>（Million bits per second），<strong>MBs</strong>。</p>\n<p>音频码率通常为<strong>kbps</strong>。</p>\n<p>换算单位是：</p>\n<ul>\n<li>8bits = 1byte</li>\n<li>1mbps = 0.125bit/s</li>\n</ul>\n<h2 id=\"高效的剪辑工作流（最终目标）\"><a href=\"#高效的剪辑工作流（最终目标）\" class=\"headerlink\" title=\"高效的剪辑工作流（最终目标）\"></a><strong>高效的剪辑工作流（最终目标）</strong></h2><p>经过以上的对比分析，最佳的<strong>视频剪辑方式</strong>是用<strong>mov</strong>格式的视频素材进行<strong>剪辑调色</strong>等工作，而最后<strong>成片</strong>导出为<strong>mp4</strong>格式放到网络上。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">剪辑/调色</th>\n<th style=\"text-align:center\">网络传输</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">编码方式</td>\n<td style=\"text-align:center\">帧内编码</td>\n<td style=\"text-align:center\">帧间编码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">编码格式</td>\n<td style=\"text-align:center\">prores/cineform</td>\n<td style=\"text-align:center\">H.264</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">封装格式</td>\n<td style=\"text-align:center\">mov</td>\n<td style=\"text-align:center\">mp4</td>\n</tr>\n</tbody>\n</table>\n<p>知道了视频的编码与封装就不用纠结是mac还是win的问题了，只要<strong>选对了编码</strong>那编辑起来都是行云流水的。<em>（另外adobe的encoder真的很厉害）</em></p>\n<p><em>有任何关于本文内容的问题，可以在下方评论，或者邮件联系联系我。</em></p>\n"},{"title":"事件驱动编程-翻译","author":"SmalBox","cover":true,"top":true,"date":"2020-04-04T13:46:44.000Z","_content":"# 事件驱动编程\n\n   - 原文：Event-Driven-Programming: Introduction, Tutorial, History\n   - 作者：Stephen Ferg\n   - 进度：完成所有章节的初步翻译\n   - 翻译：[SmalBox](https://smalbox.top)\n   - 原文版权：[Creative Commons Attribution License](http://creativecommons.org/licenses/by/2.5/)\n   - 翻译版权：[Apache-2.0](https://raw.githubusercontent.com/SmalBox/Book/master/LICENSE)\n   - 翻译项目地址：[点击查看项目](https://github.com/SmalBox/Book)\n   - *注：译文无配图，图片请参考原文([点击获取原文](https://github.com/SmalBox/Book/blob/EventDrivenProgramming/event_driven_programming.pdf))*\n\n<hr/>\n\n# EventDrivenProgramming: Introduction, Tutorial, History\n\n   - 《事件驱动编程:介绍，教程，历史》\n\n\n## In The Beginning - Transaction Analysis (开始-事务分析)\n\n   - 我的故事开始于1970年后期。在那些日子里，经典的计算机系统是批处理系统。输入数据还是经典的在带子上的顺序文件。这些文件带子旋转，被其他程序处理,然后写入到到其他文件，文件又被其他程序处理，如此反复。计算机系统的标准模式是一个流水线。原始数据从一个门进入，然后他们被反复的处理，最后结果会从另一个门出来。\n   - 这种思维模式奠定了1970年代“结构化”系统开发方式。结构化方法之父是 拉里·康斯坦丁（Larry L. Constantine）。他的父公司是IBM的系统研究所。最成功的结构化倡导者是 爱德华·尤登（Edward Yourdon） 。到这种程度以致 尤登（Yourdon）和结构化分析和设计方法 几乎成为了同义词。\n   - 在1974年，起初结构化这个术语出现在IBM系统之旅的文章中,它们被G,W,L，叫做结构化设计。在1975年，Larry Constantine 的一名学生 G M，在IBM SRI 发表了一篇“通过复合设计获得可靠软件”的文章。然后在1977和1978年，几乎同时地，几个关于结构化方法的重要的书出现了。它们是“机构化设计”-Ed Yourdon，Larry Constantine，“结构化分析和系统详述”-Tom De Marco,“结构化系统分析”-Chris Gane, Trish Sarson,“结构化系统开发”-Ken Orr。也许最有影响力的是Tom De Marco 的 “结构化分析和系统详述” ，这本书在伦敦出版社发布。\n\n### Dataflow Diagrams (数据流图)\n\n   - 结构化分析使用“数据流图”（DFDs）去展示计算机系统的逻辑结构。在DFD中,顺序文件中的记录被概念化为，通过管道 或 沿着传送带移动的数据包，成为数据流。数据包在各个一系列工作区中传递被叫做“处理”，他们被筛选、使用、增强或者改变，最后通往下一个工作区。这有一个数据流图，来自 “数据分析和系统详述” 的316页。\n   - 图【transform analysis】\n   - 用这种方式描述的系统被叫做 “transform analysis”\n   - D M又简短的介绍了第二种分析方式，叫做 “transaction analysis” 并且提供了这张图。\n   - 图【transaction analysis】\n   - 他阐述了“transform”和“transaction”分析的不同如下：\n      - “transform analysis” 应用于那些能明确区分出 输入流、处理中心、输出流的应用。在数据流图术语中,“transform” 由线性网格表示。\n      - \"transaction analysis\" 应用于有着突发并行数据流特性应用的“事务中心”。\n   - D M 实际上只花了很少的时间来条论“事务分析”。但是在“结构化设计”这本书里的这个主题却受到了跟多的关注。在第11章，Y和C将第一次描述事务分析归功于P。Y和C描述事务分析是“一个更灵活，SAPTAD技术的更复杂更新”。\n   - “事务分析”建议通过数据流图表示，类似于图11.1，一个“transform”分裂出一个输入流，和若干个输出子流。这就是一个事件驱动的原型图。\n   - 图【11.1】\n   - 他说：一个“事务”是从一些“元素的数据、控制、信号、事件、或者状态的改变”开始，然后发送到事务中心做处理。\n   - 一个“事务中心”必须具备如下条件：\n      - 以原始的形式（获取和相应）获得事务\n      - 分析每一个事务，确定他的类型\n      - 根据事务类型分发\n      - 完成每一个事务的处理\n\n### Structure Charts (结构图)\n\n   - 一个数据流图展示了一个系统必须执行的逻辑功能，但没有说明执行这些功能的程序设计。在结构化分析和设计中，一个不同的图叫做“结构图”，它用来展示程序设计。在“结构图”中，矩形代表模块（函数或子程序）。矩形按等级排列，呼叫模块在上方，被呼叫模块在下方。\n   - 从事务处理数据流图 转换到的结构图如下：\n   - 图【11.2】\n   - 在这个图中，虚线箭头代表控制流从顶部流入事务中心。事务被“GETTRAN”函数获得。一旦事务被捕获，将被分析判断他的类型（它的事务代码）并向上传递给“事务中心”。之后，将发送给“分发”模块，它将根据事务类型分发给不同的事务处理模块。\n\n## The Handlers Design Pattern (处理程序设计模式)\n\n   - 如果Y和C的文章写在今天，他们很有可能将他们的“事务分析”的概念叫做设计模式。我将叫它们“处理程序模式”。\n   - 这有一个“处理程序模式”的图.这个图是接着图11.1的事务分析原始数据流图。\n   - 图【Handlers pattern】\n   - 在图中可以看到：\n      - 有一个数据流叫做“事件”（Y和C叫它“事务”）\n      - 有一个“分发模块”（Y和C叫它“事务中心”）\n      - 还以一系列的处理程序\n   - “分发模块”的工作是获取每个进来的事件，分析事件决定事件的类型，然后发送事件到可以处理对应类型事件的处理程序中。\n   - “分发模块”必须处理一连串的输入事件流，所以它的逻辑必须包括一个“事件循环”，所以它可以获取事件、分发它，然后循环回来在输入流中处理下一个事件。\n   - 一些应用（例如，控制硬件的应用）可能把事件流看作是无线有效的。但是对于大多数事件处理应用，事件流是有限的，通过在流的最后用一些特殊的事件(一个文件结尾的标志，或者按ESCAPE键，或在GUI上左键点击关闭按钮)标识。在这些应用中，“分发模块”逻辑必须包含“退出”能力来在事件流末尾被发现去结束事件循环。\n   - 在一些情况下，“分发模块”做出的决定可能不能恰当的处理这个事件，它们会丢弃这个事件或者引发（抛出）一个异常。GUI应用一般对类似鼠标按钮点击之类的事件感兴趣，但是对鼠标运动事件不感兴趣。所以在GUI应用中，事件没有处理程序时，通常会被抛弃。对于大多数其他类型的应用，一个不能被识别的事件在输入流中组成一个错误，一个适当的操作是是引出异常。\n   - 这是经典的分发模块的伪代码，来展示一下所有特性：\n      - 事件循环\n      - “退出”操作\n      - 判断事件类型，在类型的基础上选择一个恰当的处理程序。\n      - 对没有相应处理程序的处置。\n      - 图【分发模块 伪代码】\n\n### The Headless Handlers Pattern (无头处理程序模式)\n\n   - 这里有几个处理程序模式的变形体。其中一个是“无头处理程序”模式。在这个模式中，“分发模块”要么确实，要么不是随时可见。去掉“分发模块”，剩下的全部都是事件处理程序的集合。\n   - 图【Headless Handlers Pattern】\n\n### The Extended Handlers Pattern (扩展处理程序模式)\n\n   - 另一种变体是“扩展处理程序”模式。在这种变体中，模式包括一个“事件生成器”组件，这个生成器可以生成“分发程序”可以处理的事件流。\n   - 图【Extended Handlers Pattern】\n\n### The Event Queue (事件队列)\n\n   - 在一些案例中，“分发模块”和处理程序可能不能够在事件来的时候尽快的处理他们。在这些案例中，解决方案是将事件输入流存入缓冲区，在事件生成和事件分发当中将“事件队列”引入事件流。事件可以快速的添加到队列的末尾，“分发模块”也可以以最快的速度从队列的前端取出它们。\n   - GUI应用通常都有事件队列。重要的事件例如鼠标点击可能需要一些事件来处理。在处理当中，其他的事件如鼠标移动事件就要累加在缓冲区中。当缓冲区再次空闲时，它就可以立即抛弃可忽略的事件-鼠标移动事件，然后快速清空序列。\n\n### Some Examples of the Handlers Pattern (处理程序-举例)\n\n   - 现在我们已经介绍了处理程序模式，我应该给你看一些关于这个模式的例子。这些方法和技术可能很相似，但是可能你从来没有在“事件驱动编程”的角度去思考它们。\n\n### Objects (对象)\n\n   - 在90年代，面向对象的技术方法逐渐的使七八十年代的结构化的方法失去了光芒。软件方法论者开始用新的图表标记法做实验，去阐述面向对象的概念。与此同时，“对象图”是这些流行的图之一（由GradyBooch发明）。这有一个对象图表的例子。\n   - 图【object diagram of a STACK object】\n   - 在这个“对象图”中，“Stack”是一个对象类型（或者叫做“类”）。“Push”、“pop”、“peek”是他的方法。想要使用“Stack”类，你需要创建stack对象，然后使用对象的方法去做一些事情。\n   - 图【create and usage stack object】\n   - 我喜欢“对象图”，因为它们清楚的展示了一个对象在“无头程序处理模式”中的示例。一个“对象图”，同样的也是一个基本的“无头处理程序”，除了事件是从左面来的而不是从顶部来的。举个例子，Stack类是可以处理“push”、“push”、“pop”事件的一系列事件处理程序（面向对象中叫做“方法”）的集合\n   - 写到这里，如果你是一个面向对象的程序员，你应该已经知道什么是事件驱动编程了。毫不夸张地说，当你在写对象的方法的时候，你就是在写事件的处理程序。\n\n### System (系统)\n\n   - 正如我们所看到的，在“结构化系统分析“中，计算机系统被概念化为工厂。原始的原料流入工厂，在传送机的带子（数据流）上前向流动，穿过工作站（处理）最终结束旅程的产品被从门推出。\n   - 原始原料的提供者是“源（sources）”，最终产品的消费者是“盥洗盆（sinks）”。“sources”和“sinks”是数据流的“终端（terminator）”-（它们是数据流开始和结束的地方）。\n   - “上下文关系图”用来展示系统在终端上下文中关系的状况。这有一个上下文关系图，来自De Marco 的“结构化分析和系统详述”中第59页。\n   - 图【context diagram】\n   - 在1984年，Stephe McMenamin 和 John Palmer 发表了 “基本系统分析（Essential Systems Analysis）”（ESA）。ESA 建立并扩展了结构分析的早期工作，但是它也介绍了计算机系统的概念模式中基本的变化。\n   - ESA 认为计算机系统不是一个工厂，是一个激励/反馈的机器。激励是在外部世界中，通过终端发送到系统的事件。系统自己概念化为一系列事件处理程序（基本活动）。当一个事件到达，系统就活动了起来，基本活动开始处理事件，然后系统再次进入睡眠状态（静默），直到下一个事件到来。\n   - 基本活动反馈事件是通过在系统核心的数据存储中读写，和产生输出数据流的方式。系统的数据存储构成了“基本内存（essential memory）”。\n   - 这张图展示了计算机系统的基本部分，他们是概念化的ESA。\n   - 图【Characteristic shape of an event-partitioned DFD】\n   - 基本上，ESA展示了一个简单的计算机系统，是一个巨大的面型对象风格对象。系统的基本活动是对象的方法，基本内存是他的内部数据。这个对象是“无头处理程序模式”的例子，它的方法扮演了处理程序的角色，所以在这里完整的计算机系统是一个“无头处理程序模式”的例子，基本活动扮演了处理程序的角色。\n   - “处理程序模式”中，最完善的系统概念化是JSD（Jackson System Development），都写在了 Michael Jackson 的“系统开发”（1983）这本书中。JSD 是好方法，以论证的方式第一次真的面向对象分析和设计方法。\n   - JSD系统的设计用SID（system implementation diagram 系统执行图）展示。这是一个典型的SID，来自“系统开发”的293页。\n   - 图【SID】\n   - 在图的顶部，我们看到的“分发模块”在JSD中叫做“调度程序（scheduler）”。事件流从外部系统到达；它叫做SCIN（“调度输入程序 scheduler input”）。事件被发送到CUST-1或ENQ（事件处理程序）。系统内部数据存储到数据库表中，这个表叫做“状态向量（state vector）”文件（成为SVFILE）。EREPLIES是响应中生产出的答复流，去处理询问事件。\n   - CUST-1 和 ENQ 不是函数；他们是完整对象。这意味着JSD在两个层面使用了“程序处理模式”。在上层，整个系统以完整的“处理程序模式”为出发点，调度程序作为分发模块，对象做事件处理者。第二层面向对象方式的对象，这些方法函数作为事件的处理程序，处理从调度者或者其他对象来的事件。\n   - ESA 和 JSD 标志着我们的思想从早期的结构化方法中发生巨大的转变。发生巨大转变的原因是，快速发展的数据库技术的出现。在早期的结构化分析的日子里，“数据库管理系统（DBMSs）”基本上不存在。但是，到ESA和JSD出现的时候，计算机化数据处理快速发展，从批处理系统处理顺序文件到在线系统处理数据库。首先它是链接起来的表 DBMSs （IBM 的 IMS， Cullinane的 Cullinet，和 Cincom 的 Total）。紧接着是反向列表DBMSs（adabas，模式204），接下来是关系数据库（DB2，Ingres，Oracle）。DBMS技术的进步便随着数据库设计方法学的开发。\n   - 随着数据库技术的进步和其大规模的使用，大量的开发者都来使用数据库（不是访问他的软件）最为计算机系统的核心。因此，计算机系统的新模式 -作为一系列事件处理程序周边并提供接口给作为系统核心的数据库- 在那时候是非常棒的产品。\n\n### Client-Server Architecture (客户端-服务器架构)\n\n   - 在CS（Client-Server）架构中架构中有一个“处理程序模式”的熟悉示例。“server”是硬件或者软件的管线，它给“客户端”提供了服务。服务端的工作是等待来自客户端的“服务请求”，根据提供的请求服务反馈“服务请求”，然后等待更多的请求。服务端的例子包括：打印服务，文件服务，窗口服务，数据库服务，应用服务和web服务。如果你经常在网上冲浪，你是在和服务器互动，每当你访问一个新的地址，你的web游览器发送一个请求到web服务器，你请求的web页会反馈你的请求。\n   - Wesey Chun 在“Python 编程核心”的16章中提供了一个简短、清晰的解释来描述“客户端-服务器“架构的基础。（我想稍微的修改了一下文本来提高技术的连贯性）。想象一下，Chun 说：\n      - 一个既不吃也不睡，也不休息的空闲柜员，在一个从来看不到尾的流水线中服务一个又一个顾客。流水线可能会很长或者有时会空闲，但在任何时候，顾客都有可能会出现。当然，这些柜员是多年前幻想出来的，但是现在的自动柜员机（ATMs）是很接近这个模型的。\n      - 当然，这些柜员是在无限运行的服务器。每个客户端都要发送一个请求服务器的“服务请求”。客户端的请求到达服务器，并以先来先服务的方式处理请求。一次交互完成，客户就走了，服务端要么服务下一个客户，要么等待直到下一个随之而来的客户。\n   - 这有一个案例，描述了“处理程序模式”这个术语。\n   - 图【client-serer Handlers pattern】\n   - 每个银行顾客代表了一个从客户端发送来的服务请求（事件，事务）。\n   - 客户排队或者等候服务。服务端和不知疲劳的柜员很相似，因为它们都是事件处理程序的集合，都能处理不同的事件请求。并且银行柜员的“无限循环”也就是“分发模块”的事件循环。\n\n### Messaging Systems (消息系统)\n\n   - “消息系统”代表了“程序处理模式”的极端版本。“消息系统”的目的是，在发送者和接收者在不同的物理位置或者运行在不同平台上的情况下，从事件的生成者（发送者）获取事件（消息）并处理（接收者）消息。\n   - 在“消息系统”中，消息通常发送给特定的接收者，所以分发函数（决定接收者应该接收什么消息）是很普通的函数。一个熟悉的“消息系统”的例子是邮局。一个发送者发送一个消息（信件或者包裹）到邮局（“消息系统”）。邮局在消息中读取收信者的地址，并且传送信息给收信者。\n   - 图【Messaging System】\n   - E-mail “消息系统”本质上和邮局的功能差不多。唯一的不同是E-mail的消息是电子编码而不是物理编码。\n   - 可能大多数精密的消息系统是企业的消息系统，使用“面向消息的中间件”或者MOM。在MOM系统中，发送者和接收者是计算机应用，而不是人。MOM系统允许计算机应用在物理分离或者运行在不同的软硬件平台下互相通信。例如，一个大公司的办公区和服务器在地理位置上分散。MON软件允许在公司的LA处的管理入口系统以电子的形式发送给在Chicago服务器上的应用一个指令结束，也可以在纽约服务器上的程序管理报道，全都不需要人干预。\n   - 再加上，对于这种点对点的通讯模式，MOM产品也支持发布/订阅模式。在发布/订阅模式中，接收者成为了通过主题订阅的订阅者，发送者要发送消息到主题中，而不是个人订阅者）。当主题收到消息，这个主题会将消息发送给所有订阅它的接收者。\n   - 图【publish/subscribe model】\n   - 在MOM系统中，电子通信问题（队列问题，发布/订阅模式的执行问题）使系统的处理程序方面变得简单。然而，这么做的目的使帮助理解MOM系统，作为一个极端简单且专用的处理程序模式的例子。\n\n## Frameworks (框架)\n\n### Object-Oriented Event-Driven Programming (面向对象事件驱动编程)\n\n   - 现在让我们来看一个全景 - “程序处理”模式在现代计算机的不同方面是怎么体现的。然我们在代码层面看“程序处理”模式是怎样工作的。\n   - 考虑到与客户打交道的业务。业主自然想有一个信息系统来存储、恢复、更新他顾客信息的账户。他想要的系统可以处理各种事件：需要添加一个新的客户账户，可以修改账户名、关闭账户，诸如此类。所以系统必须有处理各种类型事件的事件处理程序。\n   - 图【business information system】\n   - 在面向对象编程出现之前，这些事件处理程序作为子程序来执行。这些代码在分发模块的事件循环中，像下面这样：\n   - 图【dispatcher pseudo-code】\n   - 子程序的类似这样：\n   - 图【subroutines pseudo-code】\n   - 现在，使用面向对象技术，事件处理程序作为对象的方法执行。这些代码在分发模块的事件循环中，像下面这样：\n   - 图【dispatcher OO pseudo-code】\n   - “账户”类和他的方法（事件处理函数），像下面这样：\n   - 图【account class methods】\n   - 使用面向对象技术这种方式没有很激动。基本上来说，我们只是用对象取代了数据库记录；换句话说，数据处理的过程没什么变化。\n   - 但是它变得更有趣……\n\n### Frameworks (框架)\n\n   - 使用面向对象技术可以相对容易的开发普遍的、可复用的类。这是面向对象技术的一个优势。\n   - 举个例子，假设有一个商业的，多用途的业务类产品-“通用业务”。通用业务是一个软件框架，可以直到怎样展示多样的一般化商业功能（打开顾客账号，关闭顾客账号，诸如此类）。显然，因为所有的业务不同，通用业务允许可以根据业务特定的需求定制框架。\n   - 假设接下来，Bob是一个小的业务员，他买了一个通用业务软件。在他使用软件之前，Bob需要根据他的需求定制软件。我们能想到Bob有很多定制化的事情要做：他的名字、他卖的东西的名字、它允许使用哪种信用卡，诸如此类。但是经过讨论，让我们看看Bob最急迫的需求，他想定制通用业务来使用MySQL存储账号信息。\n   - 通用业务是已经写好的。他不能预测到企业将使用哪个DBMS。这意味着通用业务（就算知道怎样打开和关闭用户账号）不知道怎样持久化数据库的账户数据。当然，他也不可能知道企业用什么DBMS（Oracle， Sybase， DB2， MySQL，Postgres），通用业务不知道在账户类的“persist()”方法中该写什么代码。\n   - 这意味着Bob必须自己在他的“persist()”方法中写代码。\n   - 也就是说，通用业务有个问题，它怎么确保像Bob这样的用户会给“persist()”方法写代码呢？\n   - 通用业务给出的解决方法不是提供一个全功能的账户类，而是提供半成品类（仅实现全功能账户类的某些方法）。实现的这部分，我们叫它通用账号类。通用账号类提供一些方法的完整实现，并且给像Bob这样的业务员预留了“插入点”，Bob必须添加他的业务代码。\n   - “插入点”是代码中的位置，在软件框架中期望事件处理程序插入的地方。事件处理程序本身叫做“插件（plug-ins）”\n   - 包含“插入点”的半成品类的技术学名叫做“抽象类”。不同语言提供不同的方式定义插入点。例如，java提供了关键字“abstract”和叫做“abstract methods”的插入点。\n   - 抽象方法不是真的方法。而是方法的占位符；一个可以插入具体方法的地方。包含抽象方法的Java类叫做抽象类。抽象类不能实例化。使用抽象类的唯一方法是创建一个子类开扩展它，然后在子类中定义具体方法（实现抽象类中每一个抽象方法）。Java强制执行此要求。Java不能编译通过企图实例化抽象类的程序。\n   - 这意味着，Bob使用通用业务的通用账号类的方法是他自己创建一个具体的类来扩展它，并且实现抽象方法。如果通用账号类如下：\n   - 图【an abstract lass GenericAccount】\n   - Bob的账号类如下：\n   - 图【extends GenericAccount】\n   - Python,一个动态语言，以不同的方式支持“插入点”和抽象类。在Python中，实现一个“插入点”最简单（其他实现抽象方法的方式在附录A中）的方法是定义一个什么都不做的方法，但是提出异常（raise exception）。如果方法没有完全实现，并且有程序调用它，那么就会触发运行时异常。这有一个python写的抽象方法的例子：\n   - 图【python abstract method】\n   - 一条软件的通用术语是这样的工作方式（定义“插入点”，然后需要插件补充）是“框架”。如果你Google搜索术语“框架”以你会获得这样的一些定义。每个定义都包含框架的一部分。一个框架是：\n      - 用于支撑或者封闭其他的一些东西的骨架结构。\n      - 一个广泛的概述、大纲或者框架，可想向其中添加细节。\n      - 一个可扩展的软件环境，可以根据特定需求定制。\n      - 一系列类，为一些应用的问题提供通用的解决方案。一个框架通常精炼以通过专业化或其他类或类型解决特定问题。\n      - 一个组件，它允许通过写插件模块（框架扩展）的方式扩展其功能性。扩展的开发者通过从框架中定义的类接口写自己的类。\n      - 软件主体设计成高复用模式，加上特定功能的插件以适应特定的系统的功能性需求。当安装了插件，系统将围绕插件表现出相应的行为。\n   - 这个框架模式的基本概念是“处理程序模式”。“框架扩展”或者“插件”是“事件处理”模块。\n   - 图【framework and entensions(handlers)】\n\n### SAX - an example of a framework (框架举例-SAX)\n\n   - 框架有各种形状尺寸，从大到小都有。开看一下真实的框架是怎么使用的，然我们来看一个小框架：SAX（实际上，SAX不是一个框架。他可以在框架中实现的API。但是为了保持事情简单，我们就当它是个框架）。\n   - XML越来越流行。只有一个结果，就是很多开发者第一时间在SAX（一个简单的XML API）框架中遇到了事件驱动编程。SAX是事件驱动的XML语法分析器。它的工作是打开（解析）XML成可理解的片段。例如，SAX分析器可以分析以下字符串：\n   - 图【XML string】\n   - 解析成如下三个片段：\n   - 图【three pieces】\n   - 使用SAX解析器，你给他一大块XML字符串。它解析XML文本成不同的片段，然后调用适当的预先确定的插件（事件处理程序）去处理片段。\n   - SAX为解析各种XML的特征，诸如打开和关闭标签（startElement，endElement），标签中间的文本，注释，处理指令等等，制定了预定义的插入点。\n   - SAX框架提供了“解析器（Parser）”类和一个抽象类“内容处理器（ContentHandler）”。使用它，首先要创建ContentHandler的子类，并且写一个具体的方法（事件处理模块）去覆写抽象方法。这有个用python写的简单例子。它在控制台打印XML的标签名和标签中的数据。（完整的python SAX例子可以在附件B）。\n   - 图【over-ride abstract methods】\n   - 你扩展“内容处理程序”类和指定事件处理程序：\n      - 使用SAX的 make_parser 工厂函数解析器对象。\n      - 实例化“CustomHandler”类创建一个“myContentHandler”对象\n      - 告诉解析器对象使用“myContentHandler”对象处理XML内容\n      - 将XML文本传给解析器，让事件处理模块去工作\n   - 这有用Pyhton怎样完成的过程：\n   - 图【python parse XML in file】\n\n### Why programming with a framwork is hard (为什么用框架编程很难)\n\n   - 到处理只由输入XML文本给解析器（没有更多了）构成的程序的最后一步了。对于一个面向过程背景的程序员，对事件驱动编程会很困惑。在面向过程编程中，控制的主要流程在主程序之内。附属程序或者模块仅仅是公用程序或者帮助调用展示低等级的任务。主程序的控制流通常很长并且复杂，它的复杂让应用有特定的逻辑结构。程序具有形状，并程序员可以看到该形状。\n   - 但是当面向过程的程序员开始使用框架编程，他失去了所有的控制权。没有了清晰的控制流（主程序除了开始了框架的事件循环什么也没做）。并且一旦事件循环开始了，隐藏在框架中的代码就驱动开始动作。该程序剩余的部分仅仅是帮助程序模块（事件处理程序）的集合。总之，程序结构看起来被彻底搞砸了。（框架和公共库是不同的。当使用公共库时，程序员可以完全控制程序流程，当他们需要公共库时调用它们，主动权在程序员。但是在框架中，是在框架需要时，框架负责调用程序员写的事件处理程序模块。主动权在框架。这是谁负责的问题。）\n   - 所以面向过程的程序员经常发现，在它们第一次遇到事件驱动和框架驱动编程时觉得完全不能理解！经验和熟悉会逐步减少这种感觉，这是毫无疑问的（从面向过程编程转移到事件驱动编程时一个很大的心里范式的转变）。这就是Robin Dunn 和 Dafydd Rees 在文章开始时描述的范式转变。\n\n## GUI programming (GUI编程)\n\n### Why GUI programming is hard (为什么GUI编程很难)\n\n   - 现在我们看到了框架时如何工作的，来让我们看一下最常用的框架和事件驱动编程：GUIs（图形用户界面 graphical user interfaces）\n   - GUI编程时困难的，们个人都这么认为。\n   - 首先，只需的指定GUI的外观就需要大量工作。每个窗口小部件（每个按钮、标签、菜单、输入框、列表框等等）都必须告诉它应该长什么样（形状、大小、前景色、背景色、边框样式、字体等等），他应该能确定他自己的位置，比如怎样在GUI大小改变时做出适配，怎样适应整个GUI的层次结构。仅仅是指出GUI怎么展现就有大量的工作。（这就是为什么框架中会有IDEs和屏幕画家。它们的工作就是减轻GUI编程的负担）\n   - 第二（与本文主题最相关），GUI编程很难是因为在GUI中有各种事件要处理。几乎每个GUI中的窗口小部件（每个按钮、多选框、单选框、数据输入区域、列表框（包括列表中每个项目）、文本框（包括水平和垂直滑块）、菜单栏、菜单栏图表、下拉菜单、下拉菜单中的每一项 等等很多）。几乎每个都是事件生成器，都能生成各种类型的事件。这还没完，硬件输入设备也是事件生成器。鼠标可以生成左键点击、右键点击、左键双击、右键双击、按钮按下事件（为了初始化拖拽操作）、鼠标移动事件、按钮抬起事件（为了结束拖拽操作）等一些其他事件。键盘上每个字母、数字、可敲击的按键和功能按键（包括单独和与SHIFT、ALT、CONTROL组合的按键）都可以生成事件。有大量的事件被送入“分发”模块的事件循环，GUI程序员必须为每个GUI用户可能生成的事件写好事件处理程序。\n   - 第三，事实上每个GUI工具包都以框架的形式提供给程序员。GUI框架（像SAX框架）的目的是减轻GUI程序员的负担。举个例子，GUI框架提供事件循环和事件队列来缓解程序员的工作。但是，正如我们看到的SAX，使用框架就意味着大块的程序控制流被隐藏在框架的封装机器当中，并且对与GUI程序员不可见。这意味着GUI程序员必须掌握范式的转变，转移到事件驱动编程。\n   - 这有很多事要处理。这还不是全部，这又“观察者”模式需要掌握……\n\n### The Observer Pattern (观察者模式)\n\n   - 观察者模式在GUI框架的事件驱动编程中使用的很广泛。所以我们用迂回的方式来解释观察者模式。等到这个话题结束，我们将返回到GUI编程上面来，并给出观察者模式是怎样在GUI编程中使用的。\n   - 第一次命名和描述观察者模式是在有名的“Gang of Four”的书“设计模式”中（出自 Gamma，Helm， Johonson， Vlissides （Addison-Wesley， 1995））。 观察者模式的基本想法Dafydd Rees引用了导言中的原理。这个原理是“好莱坞原理”：“不要来找我，我会叫你”。当然这个名字来自于演戏或者电影的演员试镜中。导演（电影中掉选角色的人），不想受到想演他的戏还没得到角色的演员找他的困扰，所以他告诉大家，“不要来找我们，我会回来找你”。\n   - 好莱坞原理更长的版本是：\n      - “不要来找我们，给我们你的电话，当我们想给你一份工作的时候我们会找你”。\n   - 这就是观察者模式的本质。\n   - 在观察者模式中，有一个主体和多个观察者实体。在试演场景中，导言就是主体，演员就是观察者。当事件发生（导演对他们感兴趣）的时候观察者想要主体通知它们，所以它们在主体那里注册（留下能找到他们的方式说明）。当感兴趣的事情（比如选好了演员）发生时，主体就会通知它们。为了完成这项工作，主体要保存一个列表，列表中记录了所有注册观察者的名字和地址。当有趣的事情发生时，他会通过他的观察者列表去通知在这类事件中注册此类事件的哪个观察者。\n   - 观察者模式也叫做“发布/订阅”模式。回想一下订阅报纸的例子。在“发布/订阅”模式中，主体就是信息或出版物的发布者。观察者就是出版物的订阅者。注册的过程叫做订阅，通知的过程叫做发刊。“发布/订阅”是个合适的名字，适用于长时间内重复发生通知/发布的情况，相同的通知发送给多个订阅者，并且订阅者可以取消订阅。\n   - 观察者模式是事件处理模式中的特殊例子，原因是我觉得更应该叫做订阅程序处理模式。\n   - 下一页使用python实现的观察者模式。在这个例子中，还继续使用好莱坞的主题，观察者是演员。主体是一个天才代理人叫做HotShots。演员在天才代理人那里注册，当有一个演员角色的试镜，代理人会通知演员。自从代理人不断地给演员发通知，这个例子就有了发布/订阅模式的味道。\n   - （如果你是Java程序员，请不要担心，事实上我们是想减少定义CastingCall和Observer类。这在像python这种动态语言中是可能的，现在这里是为了保持代码简短。在Java中，你需要声明类和它们的实例变量的细节）。\n   - 图【Python showing Observer pattern】\n   - 正如你在代码中看到的那样，天才代理人（主体）是它自己的事件处理程序。具体的说，他的“notify”方法是“CastingCall”事件的事件处理程序。\n   - 天才代理人通过发送“CastingCall”到它自己的“notifyActors”方法来处理“CastingCall”。“notifyActors”方法通过通过代理人的订阅人/观察者/演员列表找到相应人选并且发送通知给合适的订阅者。\n   - 在真实的应用中，通知的过程将包括与每个演员（事件处理程序）联系，演员会通过选角的方式来回应。然而，在这个简单的例子中，通知的过程只包含了打印一个信息来说明这个演员被通知了。\n   - 如果你运行这个程序，会得到如下输出：\n   - 图【Python showing Observer pattern Output】\n\n### Event Objects (事件对象)\n\n   - 这个程序有个功能，你应该特别注意。它使用了CastingCall对象的时候带着参数（实例化变量）“source”和“role”。在这里，CastingCall对象是事件对象（控制事件的对象）。\n   - 事件对象是事件驱动编程中非常好的工具。在面向对象的编程语言中，事件或者事务都是极端受限的。在一些案例中，如果你想发送一个事件到以事件处理器中，你发送的所有都是一个包含事务代码的字符串。但是面向对象技术通过允许我们创建和忽略事件对象完全的改变了它。事件对象的本质是将我们需要的时间信息打包起来。\n   - 一个事件对象当然也可以携带触发它事件种类的名字。但是，依赖与应用，它可以携带更多信息。在这个HotShots天才代理的案例中，事件对象包含选角色的“source”和role信息。\n   - 在其他应用中，我们可能想放入大量完整的信息到我们的事件对象中。考虑一下著名的Model-View-Controller（MVC）模式。观察者模式就是MVC的核心。在MVC中，Model是一个管理数据和一些应用域的对象（它是观察者模式中的主体）。Views在Model中作为观察者注册。当Controller改变了Model，Model就会通知订阅它的观察者（Views）这个（Model）改变了。\n   - 最简单的MVC版本被叫做“pull”（拉取）版本。在这个版本中，事件对象（当Model变化时，Model向Views发送的通知）几乎不包含什么信息。Model的描述没有改变，他只是通知Views发生了某种变化。当Views收到了这样的通知，它们必须从Model拉取信息。这样，它们必须询问Model当前状态的信息，并且从这些信息中刷新它们自己的状态。\n   - 大多数复杂的MVC版本叫做“push”（推送）版本。在这个版本中，Model 推送变化信息给Views。事件对象发送给Views，对象包含了大量复杂的信息（Model产生的一个完整详尽的变化描述）。当Views收到了这些信息，它就拥有了所有信息，他会根据这些信息更改他自己。\n   - MVC的“push”和“pull”版本的根本区别简单来说就是放入事件对象包中的信息总数不同。\n\n### The Registered Handlers pattern in GUI applications (GUI应用程序中的“注册处理程序”模式)\n\n   - 现在你已经熟悉了基本的 观察者/注册 处理程序模式，来让我们看看这个模式在GUI编程中是如何使用的。\n   - 这有另一个程序的代码。在结构上，这段代码和Hotshots天才代理的代码很像，但是名字用了处理程序模式的专用术语，事件是GUI事件。\n   - 在这个例子中，“主体”是分发模块（工作在GUI中的事件循环）。\n   - 为了保持代码简短，程序只包含观察者（“demoHandler”函数是双击鼠标左键的事件处理函数）。\n   - 展示这个处理程序的动作，程序生成一个模仿鼠标左键双击的事件（LeftMouseDoubleClick 事件）。\n   - 图【Python showing Registered Handlers pattern】\n   - 如果你运行这个代码，会得到如下输出：\n      - 图【Handling LeftMouseDoubleClick from mouse】\n   - 在如下语句中：\n      - 图【demoDispatcher.registerObserver( demoHandler, MOUSE_LEFT_DOUBLE)】\n   - 和这句：\n      - 图【observer.eventHandler = argEventHandler】\n   - 程序在传递“demoHandler”函数对象的引用。它这是将函数作为“全功能对象”（支持所有操作，基本的包括：作为参数传递、从函数返回、赋值给其他变量）。这不是所有的编程语言都支持的，也就是意味着，在不同的编程语言中，实现观察者/注册处理程序模式的方式会很不一样。\n\n### Registering Event-Handlers in Python - \"Binding\" (Pyhton中的注册事件处理程序-“绑定”)\n\n   - 这些是“注册处理程序”模式后的基本思想。现在让我们看一下在Python和Java的GUI应用中“注册处理程序”模式是什么样的。\n   - 开源动态语言如：Python、Perl 和 Ryby 通常提供多样的开源GUI框架接口开支持GUI编程。在Python中，也提供了一些这样的接口。最流行的是tkinter（向Tcl/Tk提供的接口）和wxPython（向wxWidgets提供的接口）。\n   - 使用这些接口的基本概念是非常相似的。在接下来的讨论中，我会用Python和tkinter的例子，来阐述在GUI编程中“注册处理程序”模式的样子。\n   - 在Python和tkinter中，所有的GUI事件都术语一个单独的类：“event”。事件处理程序带着GUI窗口小部件（按钮之类的）注册到程序中，为了处理特定类型的事件，比如鼠标点击，按键按下。在PYthon中，注册一个事件处理程序的过程叫做“binding”（）绑定。\n   - 这有个简单的例子。假设我们的程序已经有了一个事件处理程序（一个函数或者方法）叫做“OKButtonEventHandler”。它的工作是处理发生在GUI中的“OK”按钮上的事件。\n   - 注意，在Python中没有特别或者神奇的事情发生，Python中没有叫做“OkButtonEventHandler”的程序（只要我们想，我们可以将这个程序的名字叫做“Floyd”或者“Foobar”都可以）。我们将要看到是Python和Java中唯一不同的地方。\n   - 接下来的代码片段创建了在观察者模式中的“subject 主体”窗口小部件。这个主体是一个GUI窗口小部件（一个按钮），它可以展示文本“OK”。这个OK按钮对象是一个Tkiner.Button类的实例对象。\n   - 图【OkButton = Tkinter.Button(parent, text=\"Ok\")】\n   - 在调用Button类的构造函数中，“parent”参数链接了按钮对象到其所有者的GUI对象上（可能是框架或者窗口）。\n   - Tkinter小部件提供了一个叫做“bind 绑定”的方法来将事件绑定到窗口小部件上。更精确的说，“bind”方法提供了一种绑定或者说结合三个不同的事情：\n      - 一个事件类型（例如，鼠标左键点击，或者在键盘按下回车键）。\n      - 一个窗口小部件（例如，在GUI上一个特定的按钮窗口小部件）。\n   - 例如，我们想在窗口的“关闭”按钮上绑定一个鼠标左键单击的函数或者方法：“closeProgram”。想要的效果是，当用户鼠标点击“关闭”按钮时，调用“closeProgram”关闭窗口。\n   - 这有一个代码片段，绑定了一个OKButtonEventHandler程序和键盘事件（“\\<Return>”）的组合到OKButton窗口小部件：\n   - 图【OkButton.bind(\"\\<Return>\", OkButtonEventHandler)】\n   - 该语句将作为观察者的OkButton窗口小部件和OkButtonEventHander函数注册到键盘事件“\\<Return>”中（当Ok按钮对象获得键盘焦点时发生的事件）。\n   - 这有另一段代码片段（可能就在同一个程序中发生，就在上一个代码之后）。它绑定了OkButtonEventHandler程序和鼠标左键点击事件到Ok按钮窗口小部件：\n   - 图【OkButton.bind(\"\\<Button-1>\", OkButtonEventHandler)】\n   - 当这两个事件中的任何一个发生了，事件将事件对象作为参数发送给OkButtonEventHandler函数。OkButtonEventHandler函数可以（如果他想）询问事件对象，并且决定是否触发一个按键按下或者鼠标点击事件。\n\n### Registering Event-Handlers in Java - \"listeners\" (Java中的注册事件处理程序-“监听”)\n\n   - Java也支持GUI事件处理程序注册技术，但是它的方式和Python的有些不一样。\n   - Java提供了多种GUI编程的选择（AWT和Swing）。这允许程序员可以用两种方式创建GUI的视觉层，并且监听GUI事件。\n   - 对于GUI的事件处理方面，java.awt.event包提供了许多不同的事件对象类型：\n      - ActionEvent        InvocationEvent\n      - AdjustmentEvent    ItemEvent\n      - ComponentEvent     KeyEvent\n      - ContainerEvent     MouseEvent\n      - FocusEvent         MouseWheelEvent\n      - InputEvent         PaintEvent\n      - InputMethodEvent   TextEvent\n   - 这些事件的类型每个都包含适合它类型的变量和方法。例如，“MouseEvent”对象包含鼠标事件的变量个方法，“KeyEvent”对象包含键盘事件的变量个方法。举个例子：\n      - “MouseEvent.getButton()”传递了鼠标按钮引发的事件。\n      - “MouseEvent.getClickCount()”传递了触发鼠标点击的数量的事件\n      - “MouseEvent.getPoint()”告诉在GUI组件中鼠标光标位置的x，y坐标。\n      - “KeyEvent.getKeyChar()”告诉了键盘按下了哪个按键。\n   - java.awt.event包也提供了通用了事件监听接口和专门监听接口集合来扩展它。专门监听接口如：\n      - ActionListener       MouseListener\n      - ContainerListener    MouseMotionListener\n      - FocusListener        MouseWheelListener\n      - InputMethodListener  TextListener\n      - ItemListener         WindowFocusListener\n      - KeyListener          WindowListener\n   - 这些专门的监听接口围绕着不同的事件类型建立。这些处理相同类型的事件对象（一个监听接口是方法（事件处理程序）的集合）。例如，在鼠标监听接口中的方法处理鼠标事件，“KeyListener”接口的方法处理“KeyEvent”事件，诸如此类。\n   - 在接口中，事件处理程序具有描述性的硬编码名称。例如，“MouseListener”接口提供五个事件处理程序方法：\n      - mouseClicked(MouseEvent e)\n      - mouseEntered(MouseEvent e)\n      - mouseExited(MouseEvent e)\n      - mousePressed(MouseEvent e)\n      - mouseReleased(MouseEvent e)\n   - GUI由多个GUI组件（窗口小部件）组成，例如面板、列表、按钮等。当GUI程序运行起来，窗口小部件是GUI事件（鼠标点击、按键等）的来源。\n   - 就观察者而言，窗口小部件是模式的“主体”。因此，每个窗口小部件必须提供一些让观察者注册的方法。在Java中，这通过每个Java的GUI类（JPanel、Button、JList等）提供注册观察者对象的方法的方式完成。JPanel提供了一个“addMouseListener()”方法来注册鼠标事件的观察者；JButton提供“addActionListener()；诸如此类。\n   - 建立GUI程序，一个Java程序必须做如下任务：\n      - 创建和定位GUI和窗口小部件的视觉化组件。\n      - 创建一个或多个监听对象（在适合的监听接口中，对象实现了所有的事件处理程序的方法）。\n      - 使用窗口小部件的“add\\[xxx]Listener()”来注册监听对象和适合的主体窗口小部件。\n   - 当GUI事件（例如鼠标点击事件）在主体窗口小部件发生时，在注册监听对象中，窗口小部件调用“mouseClicked()”事件处理程序方法，并将鼠标点击事件传递给它。\n   - 这有个基于Sun公司教程的代码示例“怎样写一个鼠标监听”：\n   - 图【How to Write a Mouse Listener】\n   - 在代码中，“inputArea”对象是事件生成器。“mouseClicked()”方法是事件处理程序。它也是注册处理程序/观察者模式的例子。在观察者模式中“inputArea”是主体，如下这行：\n   - 图【inputArea.addMouseListener(this)】\n   - 在“inputArea”中注册的“this”（DemoGUI）是观察者。\n   - 有趣的是，则个例子展示了Java中是怎么样完成多继承的。在这个例子中，DemoGUI类是GUI窗口小部件也是监听者。它是一个从JPanel继承的JPanel，所以对于inputArea窗口小部件来说它是GUI容器对象。并且他还是监听者（它实现了“MouseListener”接口中的方法（如“MouseClicked”））。\n   - 注意在Java中，事件处理程序方法通过listener接口实现方法的定义，所以名字（如“mouseClick”）是由接口来决定的，所以在起名字的问题上程序员没有选择。Python中的容器，我们可以看到，程序员可以以他们认为合适的任何方式给事件处理方法起名字。\n\n\n### Callback programming (回调编程)\n\n   - 当你读GUI框架的文档的时候，你会注意到观察者/事件处理程序叫做“callback”，因为主体窗口小部件会“回调”它们去处理事件。所以你经常看到这种编程类型叫做“回调编程”。\n\n### GUI programming - summary (GUI编程-概要)\n\n   - 这里我们全身心的投入到GUI应用中事件驱动编程的论题中。或者应该说，我们讨论的是GUI编程的上下文环境中的处理程序模式。\n   - 从根本上来说，GUI编程和其他那些我们见过的处理程序模式的例子没有太多不同。GUI编程和其他处理程序模式的形式不同在于，它大多总是牵扯到“观察者模式”。这就是为什么：GUI城边大多总是包含注册或绑定的过程（事件处理程序（观察者）捆绑到（注册到）事件生成器（主体））。\n   - 注册的过程开起来就是基础的事件处模式上的一个小变化（这只是一个结合事件处理程序和事件生成者的特殊方式）。\n\n## Maintaining State (维持状态)\n\n   - 许多事件驱动应用程序时无状态的。者意味着当应用程序处理完成了一个事件，应用程序没有被事件改变。\n   - 与无状态应用对立的时有状态应用。有状态的应用程序可以通过事件来改变应用的进程。具体来说，有状态程序可以记住或保持事件之间的信息，它们所记住的信息（它们的状态信息）可以通过事件来改变。\n   - 锤子是个无状态的工具，如果你要钉钉子，锤子就和你钉钉子之前没区别，锤子还是之前那样。订书机时有状态的工具，如果你用它钉一些纸，钉的这个动作就会改变它的状态（在钉这个动作之后，订书机就会比之前少一个订书钉）。\n   - 在大多数基本Web游览的类型中，一个Web服务器收到一个展示的特定页的请求，返回请求页，在结束之后什么都没记住。这就是无状态的应z。大多数有经验的网页会展示访问次数（“自从2000年1月1日，这个页面已经被访问了876532次”）。要做到这个，这个应用的背后网页必须记住被访问的次数，并且在每次网页被访问时增长次数。这个应用就是有状态的。\n\n### Rejection invalid transactions (拒绝无效事务)\n\n   - 在之前的讨论中，我们注意到面向对象编程是一种事件驱动编程。在大多数案例中，面向对象编程包括的对象都是有状态的。比如一个“栈”在它的实例化变量中维持着它的状态，在下图中这个区域标记成“internal data 内部数据”。\n   - 图【Stack object diagram】\n   - 当我们实例化Stack类去创建stack对象时，stack开始为空。\n   - 现在假设下列事件序列发生：\n      - 一个“push(X)”事件到达。X是添加到栈中，改变栈的状态。\n      - 一个“pop()”事件到达。X从栈中移除（再次改变栈状态）并且返回。栈现在空了。\n      - 另一个“pop()”事件到达。\n   - 现在我们遇到了一个问题。栈不能满足此需求。它不能移除并返回栈顶元素，因为栈顶没有元素了；栈是空的。\n   - 这个例子阐述了重要的有状态应用的特性。一般来说，有状态应用定义了（至少隐式的）可接受“状态+事务”类型对的列表。在列表中的每一对，当应用处于指定状态时，应用可以处理指定类型的事务。但是如果到达的事务在当前的状态中不可接受，事务必须被拒绝。\n   - 这有很多相似的这种例子：\n      - 一般来说，一个成年人如果他想结婚，他就可以结婚，但是如果他已经结婚了，那么就不能再结婚了（X的配偶由文化决定）。\n      - 一般来说，你可以从你的银行账户存取钱，但是你不能从你的账户中取出更多的钱。\n      - 一般来说，你可以兑换你的飞行常客里程以免费飞行，但是航空公司不允许你再繁忙旅行的“断电时段”兑换，比如感恩节前一天。\n      - 一般来说，数据库应用可以再数据中中更新一条记录，但是它不能更新被作者应用锁定的记录。\n   - 应用程序由多种方法来相应无效的事务。当然最简单的就是忽略它。但是，一般来说,最好的相应方式是提出一个异常，并让被提交事务的模块处理异常。\n   - 依赖于使用语言的能力，应用提出一个通用异常并伴随一条描述错误的信息，或者可以对指定的问题类型，定义指定的异常。一个栈的实例可以定义为：\n      - “StackEmptyException” 栈空异常，当栈是空的并且受到“Pop()”请求时提出此异常。\n      - “StackOverflowException” 栈溢出异常，当栈满了，并且收到了“Push()”请求时提出此异常。\n\n### State Machines (状态机)\n\n   - 在一些案例中，状态机是有效的思考具有生命周期对象（有状态的计算机应用）的方法。在它的生命周期中，有状态对象通过相应事务（事件）来在不同状态之间切换。\n   - 对象的这种行为叫做“有限状态机 Finite State Machine”（FSM）或者“定向有限状态机 Directed Finite Automaton”（DFA）。描述有限状态机的典型方式是用“状态事务图 State Transition Diagram”（STD）。在STD中，圆圈代表状态，用事务走向的事件名标记的箭头代表了事务。\n   - 这有个STD的例子，它代表了一个人的生活和婚姻历史（由文化规定，同一时间只能由一个配偶）。\n   - 图【STD for life and marriage history of a person】\n   - 在STD中，状态是：“SINGLE 单身”、“MARRIED 已婚”、“DEAD 死亡”。当一个人开始他的生活，它是单身的（开始的状态是SINGLE）。他可能还没有结婚就死亡了，或者他结婚了。他可能在结婚之后死亡，或者通过离婚或丧偶重新回到单身。DEAD是“终点状态”（没有事件事务从这里出去）。\n   - 这个Person类的伪代码如下：\n   - 图【Person class】\n   - 在上述我们讨论的状态中，我们使用“state 状态”和“state information”状态信息指人的所有有状态信息，是对象实例化变量的完整集合。但是当讨论到STD和FSM时，我们在有限状态机中使用“state”这个词去指特定的没有关联的状态。\n   - 遗憾的是，还没有标准术语来区分“state”这个单词的两种意思。Michael Jackson 使用术语“state vector 状态向量”来指第一种情况（“vector”变量列表包含一个对象的状态信息）。程序员经常使用“status”（如“status_flag”,“status_indicator”）来指第二种情况。\n   - 在本文余下部分，一般上下文会指出我用的是哪种“state”。当有可能产生混淆时，我会使用“state vector”（或者“state_information”）和“status”去让事情保持清晰。\n\n### Coding a Finite State Machine 1 (编写一个有限状态机1)\n\n   - 有很多不同的技术来编码实现一个有限状态机。在给出的例子中，你选择那种技术取决于你的应用类型和你所用语言的特性。正是因为这些，我会给你介绍你个典型的FSM程序实现的例子。\n   - 这有个有限状态机的状态转换图，它的目的是分解文字的输入流到文字组和空白组。\n   - 图【Break Input Stream STD】\n   - 在接下来的几页有实现此FSM的源码。在看源码之前，我要指出几点关于它的事。\n   - 首先，这是一个解析程序。它会读取文字的输入流，分解它到文字组（tokens 标志令牌），通过类型来标记“tokens 标志令牌”。解析（这是在标记化编译阶段和处理标记语言如HTML和XML完成的）是一个经典的阐述实现有限状态机的程序。\n   - 第二，它使用了经典的设计模式来编码有限状态机。对于许多应用，当处理一个事务时，FSM程序必须要做如下三件事：\n      - 与离开当前状态相关的活动\n      - 改变当前状态到新状态\n      - 与进入新状态相关的活动\n   - 我在活动应该发生的地方写了注释。\n   - 最后，这个程序膳食了我们在处理程序模式中期望看到的特性。输入流时事件队列。从输入流中读取一个字符是从事件队列中取出一个事件。一个时间循环检查每个字符、事件、事务去决定它是否是文字还是空白，然后分发它们到合适的处理程序。当然也会编码一个“EndOfEvents”（输入流最后）事件，在此事件到来时，将结束事件循环。\n   - 如下就是使用Python编写的源码实现。\n   - 图【Implements FSM】\n   - 在这个非常简单的例子中，程序解析如下字符串：\n   - 图【\"Suzy Smith Loves    John Jones\"】\n   - 生成如下输出：\n   - 图【Implements Output】\n\n### Coding a Finite State Machine 2 (编写一个有限状态机2)\n\n   - 作为一个实际问题，一会发现你使用了如下概念：\n      - 输入一个状态state（status）\n      - 保持状态信息state information（the state vector）\n      - 离开一个状态state（status）\n      - 拒绝当前状态下无效的事务\n   - 在你选择去写的多种事件驱动程序里。\n      - 在GUI程序中，窗口小工具经常需要记住它们的状态。如果一个用户点击了复选框，GUI应用需要知道复选框当前的状态（选中，未选中）为了在两种状态中切换。\n      - 在线应用需要记住所有种类的状态信息。如果一个用户登录一个安全的应用，用错误的密码连续提交三次，用户有可能被锁定。\n      - 在Web应用中，程序经常需要记住它们的状态。如果一个购物车应用用户提交没有登录他账单信息的订单，要将错误反馈给他，并且拒绝提交事件。\n      - 在分析一个编程语言时，是否接受特殊字符（如波浪字符、问号）在原文中出现。它可能在注释或者当出现在引号中没出现在其他地方时可以接受。\n   - 在SAX处理XML中，事件驱动应用类型的状态问题非常明显。实际上，SAX分析器提供的了startElement”和“endElement”方法实际上是“startState 开始状态”和“endState 结束状态”。当你遇到某些类型的开始标签（如\"\\<h1>\"），你实际上在进入一个状态。在文档中发生在这个状态上下文中所有之后的元素直到你遇到相应的末尾标签（如“\\<h1>”）。\n   - 这有一个用Python写的SAX程序代码片段，用来检查确保在输入中不包含“\\<br>”标签或者头标签嵌套在其他头标签里的情况。\n   - 图【CustomizedHandler class】\n   - 对比这个代码结构和解析文字和空格的代码。\n   - 解析程序非常简单，所以一旦我们进入“handlerSpace”或“handLetter”函数中，解析程序知道他要处理事务所需的一切。这对于这个程序还不够。一旦我么进入了“startElement”或“endElement”方法，我们要进一步检查我们处理的标签种类。\n   - 但是一旦我们知道我们处理事件的种类，处理就变得非常简单。从根本上来说，它包含设置和检查“status information 状态信息”（inHeadingStatus）和“state-vector 状态向量信息”（currentHeadingTag），并且基于当前状态允许或拒绝事务。\n\n### Way to remember state (记住状态的方法)\n\n   - 许多有状态的应用只需在程序运行时记住它们的状态即可。一些应用没有记住它们状态信息的问题，它们只需要在内存中存储即可。例如，在我们的解析程序中，我们使用了state和outstring global变量。在我们的SAX内容处理程序中，我们使用的“inHeadingStatus”和“currentHeadingTag”内容处理程序对象的实例变量。\n   - 但是其他有状态的应用需要推迟执行，也就是说，它们需要在内存以外存储信息。如这个应用：\n      - 存储状态信息的责任交到一些可以续存储的媒介中，例如存储在硬盘上的一个文件或数据库。当它启动的时候，它从数据库中恢复它的状态信息，在结束之前再将状态信息存回（持久化）数据库。\n   - 或者这样：\n      - 委托它的调用者负担起存储状态信息的责任。开始时，它从它的调用者收到状态信息，在它结束时再返回状态信息给它的调用者。\n   - Web应用程序是这种有状态应用程序的好例子，因为它们经常使用这两种例子来存储状态信息。考虑“nozama.com”这个网站，一个虚构的经典的用户和Web游览器模式的Web购物应用：\n      - 打开“nozama.com”Web页\n      - 他通过反复游览“Nozama”产品分类选择产品，一个一个的将产品放到购物车中。\n      - 输入他的账单和购物信息\n      - 提交他的订单\n   - 在任何给定时间，可能同时有成百上千的用户使用购物程序。Nozama必须交替从不同购物程序阶段的不同客户的请求中取出并处理。遗憾的是，简单的Web技术为Nozama提供购物者的直接链接。\n   - Nozama和类似的应用需要一种识别与特定客户端对话的方法。如一个叫做session的对话。Nozama需要管理创建、保持和存储session信息过程的方法。\n   - 这有怎么做的方法。\n   - 当一个用户打开Nozama网站，Nozama创建一个临时的session对象。用户通过购物程序，Nozama添加用户给出的信息（选择的产品、账单、购物信息）到他的session对象的状态信息。最后当用户提交他的订单时session的生命周期结束。\n   - Nozama通过给每个session一个sessionID，存储session的state vector（他的状态信息）到数据库来跟踪sessions，其中sessionID时state vector的关键。\n   - 一旦启动一个session，在所有网页中Nozama包括session ID将它发送给用户，通过用户以某种方式编码，并且Nozame作为每个页面请求的一部分返回。当Nozama收到一个包含session ID的请求，它使用session ID作为密钥从数据库中去恢复session的vector information。在Nozama处理完用户的请求后，它会在数据库中更新和替换state vector，并且返回一个响应给用户。\n   - 图【Nozama schematic】\n   - 要记住我们说的，有状态应用要记住它的状态信息，可以用存储到可持久化的媒介上，或者用调用它的调用者代理存储。Nozama使用了这两种策略。他在硬盘的数据库中存储了用户的实际状态信息。但是在这个案例中，它同样的也给了它的调用者（客户端游览器）状态信息。客户端游览器负责记录一次的状态信息：session ID。\n   - 还有一种策略是Nozama通过把整个session状态发送到游览器，让游览器记住他。如果Nozama这样做了，它就不用在数据库中存储信息，它就会变得更简单。但是前后端传输的state vector信息包会变大，导致降低相应时间。\n   - 代替策略确实有一个明显的优势，如果用户在完成购物前放弃购物，则在数据库中则没有孤立的session信息。对比数据库的策略，Nozama必须实现一个检测session超时放弃的通知。当一段时间（比如30分钟）之后，session的状态信息将无法访问，Nozama将考虑到将session终止，并且从数据库中删除状态信息。\n\n## Conlusion (结尾)\n\n   - 接下来我们总结一下这篇简短的介绍事件驱动编程（处理程序模式和它的变体）和相关的编程问题的文章。\n   - 正如你所看到的，理解事件驱动编程是能够完成许多软件开发任务（面向对象编程、面向对象系统分析和设计、用SAX解析器解析XML、GUI编程、Web编程、甚至是词法分析）的关键。\n   - 祝你的事件驱动编程顺利。","source":"_posts/事件驱动编程-翻译.md","raw":"---\ntitle: 事件驱动编程-翻译\nauthor: SmalBox\ncover: true\ntop: true\ndate: 2020-04-04 21:46:44\ncategories: 翻译\ntags:\n   - 面向对象\n   - 事件驱动\n   - GUI编程\n---\n# 事件驱动编程\n\n   - 原文：Event-Driven-Programming: Introduction, Tutorial, History\n   - 作者：Stephen Ferg\n   - 进度：完成所有章节的初步翻译\n   - 翻译：[SmalBox](https://smalbox.top)\n   - 原文版权：[Creative Commons Attribution License](http://creativecommons.org/licenses/by/2.5/)\n   - 翻译版权：[Apache-2.0](https://raw.githubusercontent.com/SmalBox/Book/master/LICENSE)\n   - 翻译项目地址：[点击查看项目](https://github.com/SmalBox/Book)\n   - *注：译文无配图，图片请参考原文([点击获取原文](https://github.com/SmalBox/Book/blob/EventDrivenProgramming/event_driven_programming.pdf))*\n\n<hr/>\n\n# EventDrivenProgramming: Introduction, Tutorial, History\n\n   - 《事件驱动编程:介绍，教程，历史》\n\n\n## In The Beginning - Transaction Analysis (开始-事务分析)\n\n   - 我的故事开始于1970年后期。在那些日子里，经典的计算机系统是批处理系统。输入数据还是经典的在带子上的顺序文件。这些文件带子旋转，被其他程序处理,然后写入到到其他文件，文件又被其他程序处理，如此反复。计算机系统的标准模式是一个流水线。原始数据从一个门进入，然后他们被反复的处理，最后结果会从另一个门出来。\n   - 这种思维模式奠定了1970年代“结构化”系统开发方式。结构化方法之父是 拉里·康斯坦丁（Larry L. Constantine）。他的父公司是IBM的系统研究所。最成功的结构化倡导者是 爱德华·尤登（Edward Yourdon） 。到这种程度以致 尤登（Yourdon）和结构化分析和设计方法 几乎成为了同义词。\n   - 在1974年，起初结构化这个术语出现在IBM系统之旅的文章中,它们被G,W,L，叫做结构化设计。在1975年，Larry Constantine 的一名学生 G M，在IBM SRI 发表了一篇“通过复合设计获得可靠软件”的文章。然后在1977和1978年，几乎同时地，几个关于结构化方法的重要的书出现了。它们是“机构化设计”-Ed Yourdon，Larry Constantine，“结构化分析和系统详述”-Tom De Marco,“结构化系统分析”-Chris Gane, Trish Sarson,“结构化系统开发”-Ken Orr。也许最有影响力的是Tom De Marco 的 “结构化分析和系统详述” ，这本书在伦敦出版社发布。\n\n### Dataflow Diagrams (数据流图)\n\n   - 结构化分析使用“数据流图”（DFDs）去展示计算机系统的逻辑结构。在DFD中,顺序文件中的记录被概念化为，通过管道 或 沿着传送带移动的数据包，成为数据流。数据包在各个一系列工作区中传递被叫做“处理”，他们被筛选、使用、增强或者改变，最后通往下一个工作区。这有一个数据流图，来自 “数据分析和系统详述” 的316页。\n   - 图【transform analysis】\n   - 用这种方式描述的系统被叫做 “transform analysis”\n   - D M又简短的介绍了第二种分析方式，叫做 “transaction analysis” 并且提供了这张图。\n   - 图【transaction analysis】\n   - 他阐述了“transform”和“transaction”分析的不同如下：\n      - “transform analysis” 应用于那些能明确区分出 输入流、处理中心、输出流的应用。在数据流图术语中,“transform” 由线性网格表示。\n      - \"transaction analysis\" 应用于有着突发并行数据流特性应用的“事务中心”。\n   - D M 实际上只花了很少的时间来条论“事务分析”。但是在“结构化设计”这本书里的这个主题却受到了跟多的关注。在第11章，Y和C将第一次描述事务分析归功于P。Y和C描述事务分析是“一个更灵活，SAPTAD技术的更复杂更新”。\n   - “事务分析”建议通过数据流图表示，类似于图11.1，一个“transform”分裂出一个输入流，和若干个输出子流。这就是一个事件驱动的原型图。\n   - 图【11.1】\n   - 他说：一个“事务”是从一些“元素的数据、控制、信号、事件、或者状态的改变”开始，然后发送到事务中心做处理。\n   - 一个“事务中心”必须具备如下条件：\n      - 以原始的形式（获取和相应）获得事务\n      - 分析每一个事务，确定他的类型\n      - 根据事务类型分发\n      - 完成每一个事务的处理\n\n### Structure Charts (结构图)\n\n   - 一个数据流图展示了一个系统必须执行的逻辑功能，但没有说明执行这些功能的程序设计。在结构化分析和设计中，一个不同的图叫做“结构图”，它用来展示程序设计。在“结构图”中，矩形代表模块（函数或子程序）。矩形按等级排列，呼叫模块在上方，被呼叫模块在下方。\n   - 从事务处理数据流图 转换到的结构图如下：\n   - 图【11.2】\n   - 在这个图中，虚线箭头代表控制流从顶部流入事务中心。事务被“GETTRAN”函数获得。一旦事务被捕获，将被分析判断他的类型（它的事务代码）并向上传递给“事务中心”。之后，将发送给“分发”模块，它将根据事务类型分发给不同的事务处理模块。\n\n## The Handlers Design Pattern (处理程序设计模式)\n\n   - 如果Y和C的文章写在今天，他们很有可能将他们的“事务分析”的概念叫做设计模式。我将叫它们“处理程序模式”。\n   - 这有一个“处理程序模式”的图.这个图是接着图11.1的事务分析原始数据流图。\n   - 图【Handlers pattern】\n   - 在图中可以看到：\n      - 有一个数据流叫做“事件”（Y和C叫它“事务”）\n      - 有一个“分发模块”（Y和C叫它“事务中心”）\n      - 还以一系列的处理程序\n   - “分发模块”的工作是获取每个进来的事件，分析事件决定事件的类型，然后发送事件到可以处理对应类型事件的处理程序中。\n   - “分发模块”必须处理一连串的输入事件流，所以它的逻辑必须包括一个“事件循环”，所以它可以获取事件、分发它，然后循环回来在输入流中处理下一个事件。\n   - 一些应用（例如，控制硬件的应用）可能把事件流看作是无线有效的。但是对于大多数事件处理应用，事件流是有限的，通过在流的最后用一些特殊的事件(一个文件结尾的标志，或者按ESCAPE键，或在GUI上左键点击关闭按钮)标识。在这些应用中，“分发模块”逻辑必须包含“退出”能力来在事件流末尾被发现去结束事件循环。\n   - 在一些情况下，“分发模块”做出的决定可能不能恰当的处理这个事件，它们会丢弃这个事件或者引发（抛出）一个异常。GUI应用一般对类似鼠标按钮点击之类的事件感兴趣，但是对鼠标运动事件不感兴趣。所以在GUI应用中，事件没有处理程序时，通常会被抛弃。对于大多数其他类型的应用，一个不能被识别的事件在输入流中组成一个错误，一个适当的操作是是引出异常。\n   - 这是经典的分发模块的伪代码，来展示一下所有特性：\n      - 事件循环\n      - “退出”操作\n      - 判断事件类型，在类型的基础上选择一个恰当的处理程序。\n      - 对没有相应处理程序的处置。\n      - 图【分发模块 伪代码】\n\n### The Headless Handlers Pattern (无头处理程序模式)\n\n   - 这里有几个处理程序模式的变形体。其中一个是“无头处理程序”模式。在这个模式中，“分发模块”要么确实，要么不是随时可见。去掉“分发模块”，剩下的全部都是事件处理程序的集合。\n   - 图【Headless Handlers Pattern】\n\n### The Extended Handlers Pattern (扩展处理程序模式)\n\n   - 另一种变体是“扩展处理程序”模式。在这种变体中，模式包括一个“事件生成器”组件，这个生成器可以生成“分发程序”可以处理的事件流。\n   - 图【Extended Handlers Pattern】\n\n### The Event Queue (事件队列)\n\n   - 在一些案例中，“分发模块”和处理程序可能不能够在事件来的时候尽快的处理他们。在这些案例中，解决方案是将事件输入流存入缓冲区，在事件生成和事件分发当中将“事件队列”引入事件流。事件可以快速的添加到队列的末尾，“分发模块”也可以以最快的速度从队列的前端取出它们。\n   - GUI应用通常都有事件队列。重要的事件例如鼠标点击可能需要一些事件来处理。在处理当中，其他的事件如鼠标移动事件就要累加在缓冲区中。当缓冲区再次空闲时，它就可以立即抛弃可忽略的事件-鼠标移动事件，然后快速清空序列。\n\n### Some Examples of the Handlers Pattern (处理程序-举例)\n\n   - 现在我们已经介绍了处理程序模式，我应该给你看一些关于这个模式的例子。这些方法和技术可能很相似，但是可能你从来没有在“事件驱动编程”的角度去思考它们。\n\n### Objects (对象)\n\n   - 在90年代，面向对象的技术方法逐渐的使七八十年代的结构化的方法失去了光芒。软件方法论者开始用新的图表标记法做实验，去阐述面向对象的概念。与此同时，“对象图”是这些流行的图之一（由GradyBooch发明）。这有一个对象图表的例子。\n   - 图【object diagram of a STACK object】\n   - 在这个“对象图”中，“Stack”是一个对象类型（或者叫做“类”）。“Push”、“pop”、“peek”是他的方法。想要使用“Stack”类，你需要创建stack对象，然后使用对象的方法去做一些事情。\n   - 图【create and usage stack object】\n   - 我喜欢“对象图”，因为它们清楚的展示了一个对象在“无头程序处理模式”中的示例。一个“对象图”，同样的也是一个基本的“无头处理程序”，除了事件是从左面来的而不是从顶部来的。举个例子，Stack类是可以处理“push”、“push”、“pop”事件的一系列事件处理程序（面向对象中叫做“方法”）的集合\n   - 写到这里，如果你是一个面向对象的程序员，你应该已经知道什么是事件驱动编程了。毫不夸张地说，当你在写对象的方法的时候，你就是在写事件的处理程序。\n\n### System (系统)\n\n   - 正如我们所看到的，在“结构化系统分析“中，计算机系统被概念化为工厂。原始的原料流入工厂，在传送机的带子（数据流）上前向流动，穿过工作站（处理）最终结束旅程的产品被从门推出。\n   - 原始原料的提供者是“源（sources）”，最终产品的消费者是“盥洗盆（sinks）”。“sources”和“sinks”是数据流的“终端（terminator）”-（它们是数据流开始和结束的地方）。\n   - “上下文关系图”用来展示系统在终端上下文中关系的状况。这有一个上下文关系图，来自De Marco 的“结构化分析和系统详述”中第59页。\n   - 图【context diagram】\n   - 在1984年，Stephe McMenamin 和 John Palmer 发表了 “基本系统分析（Essential Systems Analysis）”（ESA）。ESA 建立并扩展了结构分析的早期工作，但是它也介绍了计算机系统的概念模式中基本的变化。\n   - ESA 认为计算机系统不是一个工厂，是一个激励/反馈的机器。激励是在外部世界中，通过终端发送到系统的事件。系统自己概念化为一系列事件处理程序（基本活动）。当一个事件到达，系统就活动了起来，基本活动开始处理事件，然后系统再次进入睡眠状态（静默），直到下一个事件到来。\n   - 基本活动反馈事件是通过在系统核心的数据存储中读写，和产生输出数据流的方式。系统的数据存储构成了“基本内存（essential memory）”。\n   - 这张图展示了计算机系统的基本部分，他们是概念化的ESA。\n   - 图【Characteristic shape of an event-partitioned DFD】\n   - 基本上，ESA展示了一个简单的计算机系统，是一个巨大的面型对象风格对象。系统的基本活动是对象的方法，基本内存是他的内部数据。这个对象是“无头处理程序模式”的例子，它的方法扮演了处理程序的角色，所以在这里完整的计算机系统是一个“无头处理程序模式”的例子，基本活动扮演了处理程序的角色。\n   - “处理程序模式”中，最完善的系统概念化是JSD（Jackson System Development），都写在了 Michael Jackson 的“系统开发”（1983）这本书中。JSD 是好方法，以论证的方式第一次真的面向对象分析和设计方法。\n   - JSD系统的设计用SID（system implementation diagram 系统执行图）展示。这是一个典型的SID，来自“系统开发”的293页。\n   - 图【SID】\n   - 在图的顶部，我们看到的“分发模块”在JSD中叫做“调度程序（scheduler）”。事件流从外部系统到达；它叫做SCIN（“调度输入程序 scheduler input”）。事件被发送到CUST-1或ENQ（事件处理程序）。系统内部数据存储到数据库表中，这个表叫做“状态向量（state vector）”文件（成为SVFILE）。EREPLIES是响应中生产出的答复流，去处理询问事件。\n   - CUST-1 和 ENQ 不是函数；他们是完整对象。这意味着JSD在两个层面使用了“程序处理模式”。在上层，整个系统以完整的“处理程序模式”为出发点，调度程序作为分发模块，对象做事件处理者。第二层面向对象方式的对象，这些方法函数作为事件的处理程序，处理从调度者或者其他对象来的事件。\n   - ESA 和 JSD 标志着我们的思想从早期的结构化方法中发生巨大的转变。发生巨大转变的原因是，快速发展的数据库技术的出现。在早期的结构化分析的日子里，“数据库管理系统（DBMSs）”基本上不存在。但是，到ESA和JSD出现的时候，计算机化数据处理快速发展，从批处理系统处理顺序文件到在线系统处理数据库。首先它是链接起来的表 DBMSs （IBM 的 IMS， Cullinane的 Cullinet，和 Cincom 的 Total）。紧接着是反向列表DBMSs（adabas，模式204），接下来是关系数据库（DB2，Ingres，Oracle）。DBMS技术的进步便随着数据库设计方法学的开发。\n   - 随着数据库技术的进步和其大规模的使用，大量的开发者都来使用数据库（不是访问他的软件）最为计算机系统的核心。因此，计算机系统的新模式 -作为一系列事件处理程序周边并提供接口给作为系统核心的数据库- 在那时候是非常棒的产品。\n\n### Client-Server Architecture (客户端-服务器架构)\n\n   - 在CS（Client-Server）架构中架构中有一个“处理程序模式”的熟悉示例。“server”是硬件或者软件的管线，它给“客户端”提供了服务。服务端的工作是等待来自客户端的“服务请求”，根据提供的请求服务反馈“服务请求”，然后等待更多的请求。服务端的例子包括：打印服务，文件服务，窗口服务，数据库服务，应用服务和web服务。如果你经常在网上冲浪，你是在和服务器互动，每当你访问一个新的地址，你的web游览器发送一个请求到web服务器，你请求的web页会反馈你的请求。\n   - Wesey Chun 在“Python 编程核心”的16章中提供了一个简短、清晰的解释来描述“客户端-服务器“架构的基础。（我想稍微的修改了一下文本来提高技术的连贯性）。想象一下，Chun 说：\n      - 一个既不吃也不睡，也不休息的空闲柜员，在一个从来看不到尾的流水线中服务一个又一个顾客。流水线可能会很长或者有时会空闲，但在任何时候，顾客都有可能会出现。当然，这些柜员是多年前幻想出来的，但是现在的自动柜员机（ATMs）是很接近这个模型的。\n      - 当然，这些柜员是在无限运行的服务器。每个客户端都要发送一个请求服务器的“服务请求”。客户端的请求到达服务器，并以先来先服务的方式处理请求。一次交互完成，客户就走了，服务端要么服务下一个客户，要么等待直到下一个随之而来的客户。\n   - 这有一个案例，描述了“处理程序模式”这个术语。\n   - 图【client-serer Handlers pattern】\n   - 每个银行顾客代表了一个从客户端发送来的服务请求（事件，事务）。\n   - 客户排队或者等候服务。服务端和不知疲劳的柜员很相似，因为它们都是事件处理程序的集合，都能处理不同的事件请求。并且银行柜员的“无限循环”也就是“分发模块”的事件循环。\n\n### Messaging Systems (消息系统)\n\n   - “消息系统”代表了“程序处理模式”的极端版本。“消息系统”的目的是，在发送者和接收者在不同的物理位置或者运行在不同平台上的情况下，从事件的生成者（发送者）获取事件（消息）并处理（接收者）消息。\n   - 在“消息系统”中，消息通常发送给特定的接收者，所以分发函数（决定接收者应该接收什么消息）是很普通的函数。一个熟悉的“消息系统”的例子是邮局。一个发送者发送一个消息（信件或者包裹）到邮局（“消息系统”）。邮局在消息中读取收信者的地址，并且传送信息给收信者。\n   - 图【Messaging System】\n   - E-mail “消息系统”本质上和邮局的功能差不多。唯一的不同是E-mail的消息是电子编码而不是物理编码。\n   - 可能大多数精密的消息系统是企业的消息系统，使用“面向消息的中间件”或者MOM。在MOM系统中，发送者和接收者是计算机应用，而不是人。MOM系统允许计算机应用在物理分离或者运行在不同的软硬件平台下互相通信。例如，一个大公司的办公区和服务器在地理位置上分散。MON软件允许在公司的LA处的管理入口系统以电子的形式发送给在Chicago服务器上的应用一个指令结束，也可以在纽约服务器上的程序管理报道，全都不需要人干预。\n   - 再加上，对于这种点对点的通讯模式，MOM产品也支持发布/订阅模式。在发布/订阅模式中，接收者成为了通过主题订阅的订阅者，发送者要发送消息到主题中，而不是个人订阅者）。当主题收到消息，这个主题会将消息发送给所有订阅它的接收者。\n   - 图【publish/subscribe model】\n   - 在MOM系统中，电子通信问题（队列问题，发布/订阅模式的执行问题）使系统的处理程序方面变得简单。然而，这么做的目的使帮助理解MOM系统，作为一个极端简单且专用的处理程序模式的例子。\n\n## Frameworks (框架)\n\n### Object-Oriented Event-Driven Programming (面向对象事件驱动编程)\n\n   - 现在让我们来看一个全景 - “程序处理”模式在现代计算机的不同方面是怎么体现的。然我们在代码层面看“程序处理”模式是怎样工作的。\n   - 考虑到与客户打交道的业务。业主自然想有一个信息系统来存储、恢复、更新他顾客信息的账户。他想要的系统可以处理各种事件：需要添加一个新的客户账户，可以修改账户名、关闭账户，诸如此类。所以系统必须有处理各种类型事件的事件处理程序。\n   - 图【business information system】\n   - 在面向对象编程出现之前，这些事件处理程序作为子程序来执行。这些代码在分发模块的事件循环中，像下面这样：\n   - 图【dispatcher pseudo-code】\n   - 子程序的类似这样：\n   - 图【subroutines pseudo-code】\n   - 现在，使用面向对象技术，事件处理程序作为对象的方法执行。这些代码在分发模块的事件循环中，像下面这样：\n   - 图【dispatcher OO pseudo-code】\n   - “账户”类和他的方法（事件处理函数），像下面这样：\n   - 图【account class methods】\n   - 使用面向对象技术这种方式没有很激动。基本上来说，我们只是用对象取代了数据库记录；换句话说，数据处理的过程没什么变化。\n   - 但是它变得更有趣……\n\n### Frameworks (框架)\n\n   - 使用面向对象技术可以相对容易的开发普遍的、可复用的类。这是面向对象技术的一个优势。\n   - 举个例子，假设有一个商业的，多用途的业务类产品-“通用业务”。通用业务是一个软件框架，可以直到怎样展示多样的一般化商业功能（打开顾客账号，关闭顾客账号，诸如此类）。显然，因为所有的业务不同，通用业务允许可以根据业务特定的需求定制框架。\n   - 假设接下来，Bob是一个小的业务员，他买了一个通用业务软件。在他使用软件之前，Bob需要根据他的需求定制软件。我们能想到Bob有很多定制化的事情要做：他的名字、他卖的东西的名字、它允许使用哪种信用卡，诸如此类。但是经过讨论，让我们看看Bob最急迫的需求，他想定制通用业务来使用MySQL存储账号信息。\n   - 通用业务是已经写好的。他不能预测到企业将使用哪个DBMS。这意味着通用业务（就算知道怎样打开和关闭用户账号）不知道怎样持久化数据库的账户数据。当然，他也不可能知道企业用什么DBMS（Oracle， Sybase， DB2， MySQL，Postgres），通用业务不知道在账户类的“persist()”方法中该写什么代码。\n   - 这意味着Bob必须自己在他的“persist()”方法中写代码。\n   - 也就是说，通用业务有个问题，它怎么确保像Bob这样的用户会给“persist()”方法写代码呢？\n   - 通用业务给出的解决方法不是提供一个全功能的账户类，而是提供半成品类（仅实现全功能账户类的某些方法）。实现的这部分，我们叫它通用账号类。通用账号类提供一些方法的完整实现，并且给像Bob这样的业务员预留了“插入点”，Bob必须添加他的业务代码。\n   - “插入点”是代码中的位置，在软件框架中期望事件处理程序插入的地方。事件处理程序本身叫做“插件（plug-ins）”\n   - 包含“插入点”的半成品类的技术学名叫做“抽象类”。不同语言提供不同的方式定义插入点。例如，java提供了关键字“abstract”和叫做“abstract methods”的插入点。\n   - 抽象方法不是真的方法。而是方法的占位符；一个可以插入具体方法的地方。包含抽象方法的Java类叫做抽象类。抽象类不能实例化。使用抽象类的唯一方法是创建一个子类开扩展它，然后在子类中定义具体方法（实现抽象类中每一个抽象方法）。Java强制执行此要求。Java不能编译通过企图实例化抽象类的程序。\n   - 这意味着，Bob使用通用业务的通用账号类的方法是他自己创建一个具体的类来扩展它，并且实现抽象方法。如果通用账号类如下：\n   - 图【an abstract lass GenericAccount】\n   - Bob的账号类如下：\n   - 图【extends GenericAccount】\n   - Python,一个动态语言，以不同的方式支持“插入点”和抽象类。在Python中，实现一个“插入点”最简单（其他实现抽象方法的方式在附录A中）的方法是定义一个什么都不做的方法，但是提出异常（raise exception）。如果方法没有完全实现，并且有程序调用它，那么就会触发运行时异常。这有一个python写的抽象方法的例子：\n   - 图【python abstract method】\n   - 一条软件的通用术语是这样的工作方式（定义“插入点”，然后需要插件补充）是“框架”。如果你Google搜索术语“框架”以你会获得这样的一些定义。每个定义都包含框架的一部分。一个框架是：\n      - 用于支撑或者封闭其他的一些东西的骨架结构。\n      - 一个广泛的概述、大纲或者框架，可想向其中添加细节。\n      - 一个可扩展的软件环境，可以根据特定需求定制。\n      - 一系列类，为一些应用的问题提供通用的解决方案。一个框架通常精炼以通过专业化或其他类或类型解决特定问题。\n      - 一个组件，它允许通过写插件模块（框架扩展）的方式扩展其功能性。扩展的开发者通过从框架中定义的类接口写自己的类。\n      - 软件主体设计成高复用模式，加上特定功能的插件以适应特定的系统的功能性需求。当安装了插件，系统将围绕插件表现出相应的行为。\n   - 这个框架模式的基本概念是“处理程序模式”。“框架扩展”或者“插件”是“事件处理”模块。\n   - 图【framework and entensions(handlers)】\n\n### SAX - an example of a framework (框架举例-SAX)\n\n   - 框架有各种形状尺寸，从大到小都有。开看一下真实的框架是怎么使用的，然我们来看一个小框架：SAX（实际上，SAX不是一个框架。他可以在框架中实现的API。但是为了保持事情简单，我们就当它是个框架）。\n   - XML越来越流行。只有一个结果，就是很多开发者第一时间在SAX（一个简单的XML API）框架中遇到了事件驱动编程。SAX是事件驱动的XML语法分析器。它的工作是打开（解析）XML成可理解的片段。例如，SAX分析器可以分析以下字符串：\n   - 图【XML string】\n   - 解析成如下三个片段：\n   - 图【three pieces】\n   - 使用SAX解析器，你给他一大块XML字符串。它解析XML文本成不同的片段，然后调用适当的预先确定的插件（事件处理程序）去处理片段。\n   - SAX为解析各种XML的特征，诸如打开和关闭标签（startElement，endElement），标签中间的文本，注释，处理指令等等，制定了预定义的插入点。\n   - SAX框架提供了“解析器（Parser）”类和一个抽象类“内容处理器（ContentHandler）”。使用它，首先要创建ContentHandler的子类，并且写一个具体的方法（事件处理模块）去覆写抽象方法。这有个用python写的简单例子。它在控制台打印XML的标签名和标签中的数据。（完整的python SAX例子可以在附件B）。\n   - 图【over-ride abstract methods】\n   - 你扩展“内容处理程序”类和指定事件处理程序：\n      - 使用SAX的 make_parser 工厂函数解析器对象。\n      - 实例化“CustomHandler”类创建一个“myContentHandler”对象\n      - 告诉解析器对象使用“myContentHandler”对象处理XML内容\n      - 将XML文本传给解析器，让事件处理模块去工作\n   - 这有用Pyhton怎样完成的过程：\n   - 图【python parse XML in file】\n\n### Why programming with a framwork is hard (为什么用框架编程很难)\n\n   - 到处理只由输入XML文本给解析器（没有更多了）构成的程序的最后一步了。对于一个面向过程背景的程序员，对事件驱动编程会很困惑。在面向过程编程中，控制的主要流程在主程序之内。附属程序或者模块仅仅是公用程序或者帮助调用展示低等级的任务。主程序的控制流通常很长并且复杂，它的复杂让应用有特定的逻辑结构。程序具有形状，并程序员可以看到该形状。\n   - 但是当面向过程的程序员开始使用框架编程，他失去了所有的控制权。没有了清晰的控制流（主程序除了开始了框架的事件循环什么也没做）。并且一旦事件循环开始了，隐藏在框架中的代码就驱动开始动作。该程序剩余的部分仅仅是帮助程序模块（事件处理程序）的集合。总之，程序结构看起来被彻底搞砸了。（框架和公共库是不同的。当使用公共库时，程序员可以完全控制程序流程，当他们需要公共库时调用它们，主动权在程序员。但是在框架中，是在框架需要时，框架负责调用程序员写的事件处理程序模块。主动权在框架。这是谁负责的问题。）\n   - 所以面向过程的程序员经常发现，在它们第一次遇到事件驱动和框架驱动编程时觉得完全不能理解！经验和熟悉会逐步减少这种感觉，这是毫无疑问的（从面向过程编程转移到事件驱动编程时一个很大的心里范式的转变）。这就是Robin Dunn 和 Dafydd Rees 在文章开始时描述的范式转变。\n\n## GUI programming (GUI编程)\n\n### Why GUI programming is hard (为什么GUI编程很难)\n\n   - 现在我们看到了框架时如何工作的，来让我们看一下最常用的框架和事件驱动编程：GUIs（图形用户界面 graphical user interfaces）\n   - GUI编程时困难的，们个人都这么认为。\n   - 首先，只需的指定GUI的外观就需要大量工作。每个窗口小部件（每个按钮、标签、菜单、输入框、列表框等等）都必须告诉它应该长什么样（形状、大小、前景色、背景色、边框样式、字体等等），他应该能确定他自己的位置，比如怎样在GUI大小改变时做出适配，怎样适应整个GUI的层次结构。仅仅是指出GUI怎么展现就有大量的工作。（这就是为什么框架中会有IDEs和屏幕画家。它们的工作就是减轻GUI编程的负担）\n   - 第二（与本文主题最相关），GUI编程很难是因为在GUI中有各种事件要处理。几乎每个GUI中的窗口小部件（每个按钮、多选框、单选框、数据输入区域、列表框（包括列表中每个项目）、文本框（包括水平和垂直滑块）、菜单栏、菜单栏图表、下拉菜单、下拉菜单中的每一项 等等很多）。几乎每个都是事件生成器，都能生成各种类型的事件。这还没完，硬件输入设备也是事件生成器。鼠标可以生成左键点击、右键点击、左键双击、右键双击、按钮按下事件（为了初始化拖拽操作）、鼠标移动事件、按钮抬起事件（为了结束拖拽操作）等一些其他事件。键盘上每个字母、数字、可敲击的按键和功能按键（包括单独和与SHIFT、ALT、CONTROL组合的按键）都可以生成事件。有大量的事件被送入“分发”模块的事件循环，GUI程序员必须为每个GUI用户可能生成的事件写好事件处理程序。\n   - 第三，事实上每个GUI工具包都以框架的形式提供给程序员。GUI框架（像SAX框架）的目的是减轻GUI程序员的负担。举个例子，GUI框架提供事件循环和事件队列来缓解程序员的工作。但是，正如我们看到的SAX，使用框架就意味着大块的程序控制流被隐藏在框架的封装机器当中，并且对与GUI程序员不可见。这意味着GUI程序员必须掌握范式的转变，转移到事件驱动编程。\n   - 这有很多事要处理。这还不是全部，这又“观察者”模式需要掌握……\n\n### The Observer Pattern (观察者模式)\n\n   - 观察者模式在GUI框架的事件驱动编程中使用的很广泛。所以我们用迂回的方式来解释观察者模式。等到这个话题结束，我们将返回到GUI编程上面来，并给出观察者模式是怎样在GUI编程中使用的。\n   - 第一次命名和描述观察者模式是在有名的“Gang of Four”的书“设计模式”中（出自 Gamma，Helm， Johonson， Vlissides （Addison-Wesley， 1995））。 观察者模式的基本想法Dafydd Rees引用了导言中的原理。这个原理是“好莱坞原理”：“不要来找我，我会叫你”。当然这个名字来自于演戏或者电影的演员试镜中。导演（电影中掉选角色的人），不想受到想演他的戏还没得到角色的演员找他的困扰，所以他告诉大家，“不要来找我们，我会回来找你”。\n   - 好莱坞原理更长的版本是：\n      - “不要来找我们，给我们你的电话，当我们想给你一份工作的时候我们会找你”。\n   - 这就是观察者模式的本质。\n   - 在观察者模式中，有一个主体和多个观察者实体。在试演场景中，导言就是主体，演员就是观察者。当事件发生（导演对他们感兴趣）的时候观察者想要主体通知它们，所以它们在主体那里注册（留下能找到他们的方式说明）。当感兴趣的事情（比如选好了演员）发生时，主体就会通知它们。为了完成这项工作，主体要保存一个列表，列表中记录了所有注册观察者的名字和地址。当有趣的事情发生时，他会通过他的观察者列表去通知在这类事件中注册此类事件的哪个观察者。\n   - 观察者模式也叫做“发布/订阅”模式。回想一下订阅报纸的例子。在“发布/订阅”模式中，主体就是信息或出版物的发布者。观察者就是出版物的订阅者。注册的过程叫做订阅，通知的过程叫做发刊。“发布/订阅”是个合适的名字，适用于长时间内重复发生通知/发布的情况，相同的通知发送给多个订阅者，并且订阅者可以取消订阅。\n   - 观察者模式是事件处理模式中的特殊例子，原因是我觉得更应该叫做订阅程序处理模式。\n   - 下一页使用python实现的观察者模式。在这个例子中，还继续使用好莱坞的主题，观察者是演员。主体是一个天才代理人叫做HotShots。演员在天才代理人那里注册，当有一个演员角色的试镜，代理人会通知演员。自从代理人不断地给演员发通知，这个例子就有了发布/订阅模式的味道。\n   - （如果你是Java程序员，请不要担心，事实上我们是想减少定义CastingCall和Observer类。这在像python这种动态语言中是可能的，现在这里是为了保持代码简短。在Java中，你需要声明类和它们的实例变量的细节）。\n   - 图【Python showing Observer pattern】\n   - 正如你在代码中看到的那样，天才代理人（主体）是它自己的事件处理程序。具体的说，他的“notify”方法是“CastingCall”事件的事件处理程序。\n   - 天才代理人通过发送“CastingCall”到它自己的“notifyActors”方法来处理“CastingCall”。“notifyActors”方法通过通过代理人的订阅人/观察者/演员列表找到相应人选并且发送通知给合适的订阅者。\n   - 在真实的应用中，通知的过程将包括与每个演员（事件处理程序）联系，演员会通过选角的方式来回应。然而，在这个简单的例子中，通知的过程只包含了打印一个信息来说明这个演员被通知了。\n   - 如果你运行这个程序，会得到如下输出：\n   - 图【Python showing Observer pattern Output】\n\n### Event Objects (事件对象)\n\n   - 这个程序有个功能，你应该特别注意。它使用了CastingCall对象的时候带着参数（实例化变量）“source”和“role”。在这里，CastingCall对象是事件对象（控制事件的对象）。\n   - 事件对象是事件驱动编程中非常好的工具。在面向对象的编程语言中，事件或者事务都是极端受限的。在一些案例中，如果你想发送一个事件到以事件处理器中，你发送的所有都是一个包含事务代码的字符串。但是面向对象技术通过允许我们创建和忽略事件对象完全的改变了它。事件对象的本质是将我们需要的时间信息打包起来。\n   - 一个事件对象当然也可以携带触发它事件种类的名字。但是，依赖与应用，它可以携带更多信息。在这个HotShots天才代理的案例中，事件对象包含选角色的“source”和role信息。\n   - 在其他应用中，我们可能想放入大量完整的信息到我们的事件对象中。考虑一下著名的Model-View-Controller（MVC）模式。观察者模式就是MVC的核心。在MVC中，Model是一个管理数据和一些应用域的对象（它是观察者模式中的主体）。Views在Model中作为观察者注册。当Controller改变了Model，Model就会通知订阅它的观察者（Views）这个（Model）改变了。\n   - 最简单的MVC版本被叫做“pull”（拉取）版本。在这个版本中，事件对象（当Model变化时，Model向Views发送的通知）几乎不包含什么信息。Model的描述没有改变，他只是通知Views发生了某种变化。当Views收到了这样的通知，它们必须从Model拉取信息。这样，它们必须询问Model当前状态的信息，并且从这些信息中刷新它们自己的状态。\n   - 大多数复杂的MVC版本叫做“push”（推送）版本。在这个版本中，Model 推送变化信息给Views。事件对象发送给Views，对象包含了大量复杂的信息（Model产生的一个完整详尽的变化描述）。当Views收到了这些信息，它就拥有了所有信息，他会根据这些信息更改他自己。\n   - MVC的“push”和“pull”版本的根本区别简单来说就是放入事件对象包中的信息总数不同。\n\n### The Registered Handlers pattern in GUI applications (GUI应用程序中的“注册处理程序”模式)\n\n   - 现在你已经熟悉了基本的 观察者/注册 处理程序模式，来让我们看看这个模式在GUI编程中是如何使用的。\n   - 这有另一个程序的代码。在结构上，这段代码和Hotshots天才代理的代码很像，但是名字用了处理程序模式的专用术语，事件是GUI事件。\n   - 在这个例子中，“主体”是分发模块（工作在GUI中的事件循环）。\n   - 为了保持代码简短，程序只包含观察者（“demoHandler”函数是双击鼠标左键的事件处理函数）。\n   - 展示这个处理程序的动作，程序生成一个模仿鼠标左键双击的事件（LeftMouseDoubleClick 事件）。\n   - 图【Python showing Registered Handlers pattern】\n   - 如果你运行这个代码，会得到如下输出：\n      - 图【Handling LeftMouseDoubleClick from mouse】\n   - 在如下语句中：\n      - 图【demoDispatcher.registerObserver( demoHandler, MOUSE_LEFT_DOUBLE)】\n   - 和这句：\n      - 图【observer.eventHandler = argEventHandler】\n   - 程序在传递“demoHandler”函数对象的引用。它这是将函数作为“全功能对象”（支持所有操作，基本的包括：作为参数传递、从函数返回、赋值给其他变量）。这不是所有的编程语言都支持的，也就是意味着，在不同的编程语言中，实现观察者/注册处理程序模式的方式会很不一样。\n\n### Registering Event-Handlers in Python - \"Binding\" (Pyhton中的注册事件处理程序-“绑定”)\n\n   - 这些是“注册处理程序”模式后的基本思想。现在让我们看一下在Python和Java的GUI应用中“注册处理程序”模式是什么样的。\n   - 开源动态语言如：Python、Perl 和 Ryby 通常提供多样的开源GUI框架接口开支持GUI编程。在Python中，也提供了一些这样的接口。最流行的是tkinter（向Tcl/Tk提供的接口）和wxPython（向wxWidgets提供的接口）。\n   - 使用这些接口的基本概念是非常相似的。在接下来的讨论中，我会用Python和tkinter的例子，来阐述在GUI编程中“注册处理程序”模式的样子。\n   - 在Python和tkinter中，所有的GUI事件都术语一个单独的类：“event”。事件处理程序带着GUI窗口小部件（按钮之类的）注册到程序中，为了处理特定类型的事件，比如鼠标点击，按键按下。在PYthon中，注册一个事件处理程序的过程叫做“binding”（）绑定。\n   - 这有个简单的例子。假设我们的程序已经有了一个事件处理程序（一个函数或者方法）叫做“OKButtonEventHandler”。它的工作是处理发生在GUI中的“OK”按钮上的事件。\n   - 注意，在Python中没有特别或者神奇的事情发生，Python中没有叫做“OkButtonEventHandler”的程序（只要我们想，我们可以将这个程序的名字叫做“Floyd”或者“Foobar”都可以）。我们将要看到是Python和Java中唯一不同的地方。\n   - 接下来的代码片段创建了在观察者模式中的“subject 主体”窗口小部件。这个主体是一个GUI窗口小部件（一个按钮），它可以展示文本“OK”。这个OK按钮对象是一个Tkiner.Button类的实例对象。\n   - 图【OkButton = Tkinter.Button(parent, text=\"Ok\")】\n   - 在调用Button类的构造函数中，“parent”参数链接了按钮对象到其所有者的GUI对象上（可能是框架或者窗口）。\n   - Tkinter小部件提供了一个叫做“bind 绑定”的方法来将事件绑定到窗口小部件上。更精确的说，“bind”方法提供了一种绑定或者说结合三个不同的事情：\n      - 一个事件类型（例如，鼠标左键点击，或者在键盘按下回车键）。\n      - 一个窗口小部件（例如，在GUI上一个特定的按钮窗口小部件）。\n   - 例如，我们想在窗口的“关闭”按钮上绑定一个鼠标左键单击的函数或者方法：“closeProgram”。想要的效果是，当用户鼠标点击“关闭”按钮时，调用“closeProgram”关闭窗口。\n   - 这有一个代码片段，绑定了一个OKButtonEventHandler程序和键盘事件（“\\<Return>”）的组合到OKButton窗口小部件：\n   - 图【OkButton.bind(\"\\<Return>\", OkButtonEventHandler)】\n   - 该语句将作为观察者的OkButton窗口小部件和OkButtonEventHander函数注册到键盘事件“\\<Return>”中（当Ok按钮对象获得键盘焦点时发生的事件）。\n   - 这有另一段代码片段（可能就在同一个程序中发生，就在上一个代码之后）。它绑定了OkButtonEventHandler程序和鼠标左键点击事件到Ok按钮窗口小部件：\n   - 图【OkButton.bind(\"\\<Button-1>\", OkButtonEventHandler)】\n   - 当这两个事件中的任何一个发生了，事件将事件对象作为参数发送给OkButtonEventHandler函数。OkButtonEventHandler函数可以（如果他想）询问事件对象，并且决定是否触发一个按键按下或者鼠标点击事件。\n\n### Registering Event-Handlers in Java - \"listeners\" (Java中的注册事件处理程序-“监听”)\n\n   - Java也支持GUI事件处理程序注册技术，但是它的方式和Python的有些不一样。\n   - Java提供了多种GUI编程的选择（AWT和Swing）。这允许程序员可以用两种方式创建GUI的视觉层，并且监听GUI事件。\n   - 对于GUI的事件处理方面，java.awt.event包提供了许多不同的事件对象类型：\n      - ActionEvent        InvocationEvent\n      - AdjustmentEvent    ItemEvent\n      - ComponentEvent     KeyEvent\n      - ContainerEvent     MouseEvent\n      - FocusEvent         MouseWheelEvent\n      - InputEvent         PaintEvent\n      - InputMethodEvent   TextEvent\n   - 这些事件的类型每个都包含适合它类型的变量和方法。例如，“MouseEvent”对象包含鼠标事件的变量个方法，“KeyEvent”对象包含键盘事件的变量个方法。举个例子：\n      - “MouseEvent.getButton()”传递了鼠标按钮引发的事件。\n      - “MouseEvent.getClickCount()”传递了触发鼠标点击的数量的事件\n      - “MouseEvent.getPoint()”告诉在GUI组件中鼠标光标位置的x，y坐标。\n      - “KeyEvent.getKeyChar()”告诉了键盘按下了哪个按键。\n   - java.awt.event包也提供了通用了事件监听接口和专门监听接口集合来扩展它。专门监听接口如：\n      - ActionListener       MouseListener\n      - ContainerListener    MouseMotionListener\n      - FocusListener        MouseWheelListener\n      - InputMethodListener  TextListener\n      - ItemListener         WindowFocusListener\n      - KeyListener          WindowListener\n   - 这些专门的监听接口围绕着不同的事件类型建立。这些处理相同类型的事件对象（一个监听接口是方法（事件处理程序）的集合）。例如，在鼠标监听接口中的方法处理鼠标事件，“KeyListener”接口的方法处理“KeyEvent”事件，诸如此类。\n   - 在接口中，事件处理程序具有描述性的硬编码名称。例如，“MouseListener”接口提供五个事件处理程序方法：\n      - mouseClicked(MouseEvent e)\n      - mouseEntered(MouseEvent e)\n      - mouseExited(MouseEvent e)\n      - mousePressed(MouseEvent e)\n      - mouseReleased(MouseEvent e)\n   - GUI由多个GUI组件（窗口小部件）组成，例如面板、列表、按钮等。当GUI程序运行起来，窗口小部件是GUI事件（鼠标点击、按键等）的来源。\n   - 就观察者而言，窗口小部件是模式的“主体”。因此，每个窗口小部件必须提供一些让观察者注册的方法。在Java中，这通过每个Java的GUI类（JPanel、Button、JList等）提供注册观察者对象的方法的方式完成。JPanel提供了一个“addMouseListener()”方法来注册鼠标事件的观察者；JButton提供“addActionListener()；诸如此类。\n   - 建立GUI程序，一个Java程序必须做如下任务：\n      - 创建和定位GUI和窗口小部件的视觉化组件。\n      - 创建一个或多个监听对象（在适合的监听接口中，对象实现了所有的事件处理程序的方法）。\n      - 使用窗口小部件的“add\\[xxx]Listener()”来注册监听对象和适合的主体窗口小部件。\n   - 当GUI事件（例如鼠标点击事件）在主体窗口小部件发生时，在注册监听对象中，窗口小部件调用“mouseClicked()”事件处理程序方法，并将鼠标点击事件传递给它。\n   - 这有个基于Sun公司教程的代码示例“怎样写一个鼠标监听”：\n   - 图【How to Write a Mouse Listener】\n   - 在代码中，“inputArea”对象是事件生成器。“mouseClicked()”方法是事件处理程序。它也是注册处理程序/观察者模式的例子。在观察者模式中“inputArea”是主体，如下这行：\n   - 图【inputArea.addMouseListener(this)】\n   - 在“inputArea”中注册的“this”（DemoGUI）是观察者。\n   - 有趣的是，则个例子展示了Java中是怎么样完成多继承的。在这个例子中，DemoGUI类是GUI窗口小部件也是监听者。它是一个从JPanel继承的JPanel，所以对于inputArea窗口小部件来说它是GUI容器对象。并且他还是监听者（它实现了“MouseListener”接口中的方法（如“MouseClicked”））。\n   - 注意在Java中，事件处理程序方法通过listener接口实现方法的定义，所以名字（如“mouseClick”）是由接口来决定的，所以在起名字的问题上程序员没有选择。Python中的容器，我们可以看到，程序员可以以他们认为合适的任何方式给事件处理方法起名字。\n\n\n### Callback programming (回调编程)\n\n   - 当你读GUI框架的文档的时候，你会注意到观察者/事件处理程序叫做“callback”，因为主体窗口小部件会“回调”它们去处理事件。所以你经常看到这种编程类型叫做“回调编程”。\n\n### GUI programming - summary (GUI编程-概要)\n\n   - 这里我们全身心的投入到GUI应用中事件驱动编程的论题中。或者应该说，我们讨论的是GUI编程的上下文环境中的处理程序模式。\n   - 从根本上来说，GUI编程和其他那些我们见过的处理程序模式的例子没有太多不同。GUI编程和其他处理程序模式的形式不同在于，它大多总是牵扯到“观察者模式”。这就是为什么：GUI城边大多总是包含注册或绑定的过程（事件处理程序（观察者）捆绑到（注册到）事件生成器（主体））。\n   - 注册的过程开起来就是基础的事件处模式上的一个小变化（这只是一个结合事件处理程序和事件生成者的特殊方式）。\n\n## Maintaining State (维持状态)\n\n   - 许多事件驱动应用程序时无状态的。者意味着当应用程序处理完成了一个事件，应用程序没有被事件改变。\n   - 与无状态应用对立的时有状态应用。有状态的应用程序可以通过事件来改变应用的进程。具体来说，有状态程序可以记住或保持事件之间的信息，它们所记住的信息（它们的状态信息）可以通过事件来改变。\n   - 锤子是个无状态的工具，如果你要钉钉子，锤子就和你钉钉子之前没区别，锤子还是之前那样。订书机时有状态的工具，如果你用它钉一些纸，钉的这个动作就会改变它的状态（在钉这个动作之后，订书机就会比之前少一个订书钉）。\n   - 在大多数基本Web游览的类型中，一个Web服务器收到一个展示的特定页的请求，返回请求页，在结束之后什么都没记住。这就是无状态的应z。大多数有经验的网页会展示访问次数（“自从2000年1月1日，这个页面已经被访问了876532次”）。要做到这个，这个应用的背后网页必须记住被访问的次数，并且在每次网页被访问时增长次数。这个应用就是有状态的。\n\n### Rejection invalid transactions (拒绝无效事务)\n\n   - 在之前的讨论中，我们注意到面向对象编程是一种事件驱动编程。在大多数案例中，面向对象编程包括的对象都是有状态的。比如一个“栈”在它的实例化变量中维持着它的状态，在下图中这个区域标记成“internal data 内部数据”。\n   - 图【Stack object diagram】\n   - 当我们实例化Stack类去创建stack对象时，stack开始为空。\n   - 现在假设下列事件序列发生：\n      - 一个“push(X)”事件到达。X是添加到栈中，改变栈的状态。\n      - 一个“pop()”事件到达。X从栈中移除（再次改变栈状态）并且返回。栈现在空了。\n      - 另一个“pop()”事件到达。\n   - 现在我们遇到了一个问题。栈不能满足此需求。它不能移除并返回栈顶元素，因为栈顶没有元素了；栈是空的。\n   - 这个例子阐述了重要的有状态应用的特性。一般来说，有状态应用定义了（至少隐式的）可接受“状态+事务”类型对的列表。在列表中的每一对，当应用处于指定状态时，应用可以处理指定类型的事务。但是如果到达的事务在当前的状态中不可接受，事务必须被拒绝。\n   - 这有很多相似的这种例子：\n      - 一般来说，一个成年人如果他想结婚，他就可以结婚，但是如果他已经结婚了，那么就不能再结婚了（X的配偶由文化决定）。\n      - 一般来说，你可以从你的银行账户存取钱，但是你不能从你的账户中取出更多的钱。\n      - 一般来说，你可以兑换你的飞行常客里程以免费飞行，但是航空公司不允许你再繁忙旅行的“断电时段”兑换，比如感恩节前一天。\n      - 一般来说，数据库应用可以再数据中中更新一条记录，但是它不能更新被作者应用锁定的记录。\n   - 应用程序由多种方法来相应无效的事务。当然最简单的就是忽略它。但是，一般来说,最好的相应方式是提出一个异常，并让被提交事务的模块处理异常。\n   - 依赖于使用语言的能力，应用提出一个通用异常并伴随一条描述错误的信息，或者可以对指定的问题类型，定义指定的异常。一个栈的实例可以定义为：\n      - “StackEmptyException” 栈空异常，当栈是空的并且受到“Pop()”请求时提出此异常。\n      - “StackOverflowException” 栈溢出异常，当栈满了，并且收到了“Push()”请求时提出此异常。\n\n### State Machines (状态机)\n\n   - 在一些案例中，状态机是有效的思考具有生命周期对象（有状态的计算机应用）的方法。在它的生命周期中，有状态对象通过相应事务（事件）来在不同状态之间切换。\n   - 对象的这种行为叫做“有限状态机 Finite State Machine”（FSM）或者“定向有限状态机 Directed Finite Automaton”（DFA）。描述有限状态机的典型方式是用“状态事务图 State Transition Diagram”（STD）。在STD中，圆圈代表状态，用事务走向的事件名标记的箭头代表了事务。\n   - 这有个STD的例子，它代表了一个人的生活和婚姻历史（由文化规定，同一时间只能由一个配偶）。\n   - 图【STD for life and marriage history of a person】\n   - 在STD中，状态是：“SINGLE 单身”、“MARRIED 已婚”、“DEAD 死亡”。当一个人开始他的生活，它是单身的（开始的状态是SINGLE）。他可能还没有结婚就死亡了，或者他结婚了。他可能在结婚之后死亡，或者通过离婚或丧偶重新回到单身。DEAD是“终点状态”（没有事件事务从这里出去）。\n   - 这个Person类的伪代码如下：\n   - 图【Person class】\n   - 在上述我们讨论的状态中，我们使用“state 状态”和“state information”状态信息指人的所有有状态信息，是对象实例化变量的完整集合。但是当讨论到STD和FSM时，我们在有限状态机中使用“state”这个词去指特定的没有关联的状态。\n   - 遗憾的是，还没有标准术语来区分“state”这个单词的两种意思。Michael Jackson 使用术语“state vector 状态向量”来指第一种情况（“vector”变量列表包含一个对象的状态信息）。程序员经常使用“status”（如“status_flag”,“status_indicator”）来指第二种情况。\n   - 在本文余下部分，一般上下文会指出我用的是哪种“state”。当有可能产生混淆时，我会使用“state vector”（或者“state_information”）和“status”去让事情保持清晰。\n\n### Coding a Finite State Machine 1 (编写一个有限状态机1)\n\n   - 有很多不同的技术来编码实现一个有限状态机。在给出的例子中，你选择那种技术取决于你的应用类型和你所用语言的特性。正是因为这些，我会给你介绍你个典型的FSM程序实现的例子。\n   - 这有个有限状态机的状态转换图，它的目的是分解文字的输入流到文字组和空白组。\n   - 图【Break Input Stream STD】\n   - 在接下来的几页有实现此FSM的源码。在看源码之前，我要指出几点关于它的事。\n   - 首先，这是一个解析程序。它会读取文字的输入流，分解它到文字组（tokens 标志令牌），通过类型来标记“tokens 标志令牌”。解析（这是在标记化编译阶段和处理标记语言如HTML和XML完成的）是一个经典的阐述实现有限状态机的程序。\n   - 第二，它使用了经典的设计模式来编码有限状态机。对于许多应用，当处理一个事务时，FSM程序必须要做如下三件事：\n      - 与离开当前状态相关的活动\n      - 改变当前状态到新状态\n      - 与进入新状态相关的活动\n   - 我在活动应该发生的地方写了注释。\n   - 最后，这个程序膳食了我们在处理程序模式中期望看到的特性。输入流时事件队列。从输入流中读取一个字符是从事件队列中取出一个事件。一个时间循环检查每个字符、事件、事务去决定它是否是文字还是空白，然后分发它们到合适的处理程序。当然也会编码一个“EndOfEvents”（输入流最后）事件，在此事件到来时，将结束事件循环。\n   - 如下就是使用Python编写的源码实现。\n   - 图【Implements FSM】\n   - 在这个非常简单的例子中，程序解析如下字符串：\n   - 图【\"Suzy Smith Loves    John Jones\"】\n   - 生成如下输出：\n   - 图【Implements Output】\n\n### Coding a Finite State Machine 2 (编写一个有限状态机2)\n\n   - 作为一个实际问题，一会发现你使用了如下概念：\n      - 输入一个状态state（status）\n      - 保持状态信息state information（the state vector）\n      - 离开一个状态state（status）\n      - 拒绝当前状态下无效的事务\n   - 在你选择去写的多种事件驱动程序里。\n      - 在GUI程序中，窗口小工具经常需要记住它们的状态。如果一个用户点击了复选框，GUI应用需要知道复选框当前的状态（选中，未选中）为了在两种状态中切换。\n      - 在线应用需要记住所有种类的状态信息。如果一个用户登录一个安全的应用，用错误的密码连续提交三次，用户有可能被锁定。\n      - 在Web应用中，程序经常需要记住它们的状态。如果一个购物车应用用户提交没有登录他账单信息的订单，要将错误反馈给他，并且拒绝提交事件。\n      - 在分析一个编程语言时，是否接受特殊字符（如波浪字符、问号）在原文中出现。它可能在注释或者当出现在引号中没出现在其他地方时可以接受。\n   - 在SAX处理XML中，事件驱动应用类型的状态问题非常明显。实际上，SAX分析器提供的了startElement”和“endElement”方法实际上是“startState 开始状态”和“endState 结束状态”。当你遇到某些类型的开始标签（如\"\\<h1>\"），你实际上在进入一个状态。在文档中发生在这个状态上下文中所有之后的元素直到你遇到相应的末尾标签（如“\\<h1>”）。\n   - 这有一个用Python写的SAX程序代码片段，用来检查确保在输入中不包含“\\<br>”标签或者头标签嵌套在其他头标签里的情况。\n   - 图【CustomizedHandler class】\n   - 对比这个代码结构和解析文字和空格的代码。\n   - 解析程序非常简单，所以一旦我们进入“handlerSpace”或“handLetter”函数中，解析程序知道他要处理事务所需的一切。这对于这个程序还不够。一旦我么进入了“startElement”或“endElement”方法，我们要进一步检查我们处理的标签种类。\n   - 但是一旦我们知道我们处理事件的种类，处理就变得非常简单。从根本上来说，它包含设置和检查“status information 状态信息”（inHeadingStatus）和“state-vector 状态向量信息”（currentHeadingTag），并且基于当前状态允许或拒绝事务。\n\n### Way to remember state (记住状态的方法)\n\n   - 许多有状态的应用只需在程序运行时记住它们的状态即可。一些应用没有记住它们状态信息的问题，它们只需要在内存中存储即可。例如，在我们的解析程序中，我们使用了state和outstring global变量。在我们的SAX内容处理程序中，我们使用的“inHeadingStatus”和“currentHeadingTag”内容处理程序对象的实例变量。\n   - 但是其他有状态的应用需要推迟执行，也就是说，它们需要在内存以外存储信息。如这个应用：\n      - 存储状态信息的责任交到一些可以续存储的媒介中，例如存储在硬盘上的一个文件或数据库。当它启动的时候，它从数据库中恢复它的状态信息，在结束之前再将状态信息存回（持久化）数据库。\n   - 或者这样：\n      - 委托它的调用者负担起存储状态信息的责任。开始时，它从它的调用者收到状态信息，在它结束时再返回状态信息给它的调用者。\n   - Web应用程序是这种有状态应用程序的好例子，因为它们经常使用这两种例子来存储状态信息。考虑“nozama.com”这个网站，一个虚构的经典的用户和Web游览器模式的Web购物应用：\n      - 打开“nozama.com”Web页\n      - 他通过反复游览“Nozama”产品分类选择产品，一个一个的将产品放到购物车中。\n      - 输入他的账单和购物信息\n      - 提交他的订单\n   - 在任何给定时间，可能同时有成百上千的用户使用购物程序。Nozama必须交替从不同购物程序阶段的不同客户的请求中取出并处理。遗憾的是，简单的Web技术为Nozama提供购物者的直接链接。\n   - Nozama和类似的应用需要一种识别与特定客户端对话的方法。如一个叫做session的对话。Nozama需要管理创建、保持和存储session信息过程的方法。\n   - 这有怎么做的方法。\n   - 当一个用户打开Nozama网站，Nozama创建一个临时的session对象。用户通过购物程序，Nozama添加用户给出的信息（选择的产品、账单、购物信息）到他的session对象的状态信息。最后当用户提交他的订单时session的生命周期结束。\n   - Nozama通过给每个session一个sessionID，存储session的state vector（他的状态信息）到数据库来跟踪sessions，其中sessionID时state vector的关键。\n   - 一旦启动一个session，在所有网页中Nozama包括session ID将它发送给用户，通过用户以某种方式编码，并且Nozame作为每个页面请求的一部分返回。当Nozama收到一个包含session ID的请求，它使用session ID作为密钥从数据库中去恢复session的vector information。在Nozama处理完用户的请求后，它会在数据库中更新和替换state vector，并且返回一个响应给用户。\n   - 图【Nozama schematic】\n   - 要记住我们说的，有状态应用要记住它的状态信息，可以用存储到可持久化的媒介上，或者用调用它的调用者代理存储。Nozama使用了这两种策略。他在硬盘的数据库中存储了用户的实际状态信息。但是在这个案例中，它同样的也给了它的调用者（客户端游览器）状态信息。客户端游览器负责记录一次的状态信息：session ID。\n   - 还有一种策略是Nozama通过把整个session状态发送到游览器，让游览器记住他。如果Nozama这样做了，它就不用在数据库中存储信息，它就会变得更简单。但是前后端传输的state vector信息包会变大，导致降低相应时间。\n   - 代替策略确实有一个明显的优势，如果用户在完成购物前放弃购物，则在数据库中则没有孤立的session信息。对比数据库的策略，Nozama必须实现一个检测session超时放弃的通知。当一段时间（比如30分钟）之后，session的状态信息将无法访问，Nozama将考虑到将session终止，并且从数据库中删除状态信息。\n\n## Conlusion (结尾)\n\n   - 接下来我们总结一下这篇简短的介绍事件驱动编程（处理程序模式和它的变体）和相关的编程问题的文章。\n   - 正如你所看到的，理解事件驱动编程是能够完成许多软件开发任务（面向对象编程、面向对象系统分析和设计、用SAX解析器解析XML、GUI编程、Web编程、甚至是词法分析）的关键。\n   - 祝你的事件驱动编程顺利。","slug":"事件驱动编程-翻译","published":1,"updated":"2020-04-04T14:21:50.631Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptii30014bsfo13drp35j","content":"<h1 id=\"事件驱动编程\"><a href=\"#事件驱动编程\" class=\"headerlink\" title=\"事件驱动编程\"></a>事件驱动编程</h1><ul>\n<li>原文：Event-Driven-Programming: Introduction, Tutorial, History</li>\n<li>作者：Stephen Ferg</li>\n<li>进度：完成所有章节的初步翻译</li>\n<li>翻译：<a href=\"https://smalbox.top\" target=\"_blank\" rel=\"noopener\">SmalBox</a></li>\n<li>原文版权：<a href=\"http://creativecommons.org/licenses/by/2.5/\" target=\"_blank\" rel=\"noopener\">Creative Commons Attribution License</a></li>\n<li>翻译版权：<a href=\"https://raw.githubusercontent.com/SmalBox/Book/master/LICENSE\" target=\"_blank\" rel=\"noopener\">Apache-2.0</a></li>\n<li>翻译项目地址：<a href=\"https://github.com/SmalBox/Book\" target=\"_blank\" rel=\"noopener\">点击查看项目</a></li>\n<li><em>注：译文无配图，图片请参考原文(<a href=\"https://github.com/SmalBox/Book/blob/EventDrivenProgramming/event_driven_programming.pdf\" target=\"_blank\" rel=\"noopener\">点击获取原文</a>)</em></li>\n</ul>\n<hr>\n\n<h1 id=\"EventDrivenProgramming-Introduction-Tutorial-History\"><a href=\"#EventDrivenProgramming-Introduction-Tutorial-History\" class=\"headerlink\" title=\"EventDrivenProgramming: Introduction, Tutorial, History\"></a>EventDrivenProgramming: Introduction, Tutorial, History</h1><ul>\n<li>《事件驱动编程:介绍，教程，历史》</li>\n</ul>\n<h2 id=\"In-The-Beginning-Transaction-Analysis-开始-事务分析\"><a href=\"#In-The-Beginning-Transaction-Analysis-开始-事务分析\" class=\"headerlink\" title=\"In The Beginning - Transaction Analysis (开始-事务分析)\"></a>In The Beginning - Transaction Analysis (开始-事务分析)</h2><ul>\n<li>我的故事开始于1970年后期。在那些日子里，经典的计算机系统是批处理系统。输入数据还是经典的在带子上的顺序文件。这些文件带子旋转，被其他程序处理,然后写入到到其他文件，文件又被其他程序处理，如此反复。计算机系统的标准模式是一个流水线。原始数据从一个门进入，然后他们被反复的处理，最后结果会从另一个门出来。</li>\n<li>这种思维模式奠定了1970年代“结构化”系统开发方式。结构化方法之父是 拉里·康斯坦丁（Larry L. Constantine）。他的父公司是IBM的系统研究所。最成功的结构化倡导者是 爱德华·尤登（Edward Yourdon） 。到这种程度以致 尤登（Yourdon）和结构化分析和设计方法 几乎成为了同义词。</li>\n<li>在1974年，起初结构化这个术语出现在IBM系统之旅的文章中,它们被G,W,L，叫做结构化设计。在1975年，Larry Constantine 的一名学生 G M，在IBM SRI 发表了一篇“通过复合设计获得可靠软件”的文章。然后在1977和1978年，几乎同时地，几个关于结构化方法的重要的书出现了。它们是“机构化设计”-Ed Yourdon，Larry Constantine，“结构化分析和系统详述”-Tom De Marco,“结构化系统分析”-Chris Gane, Trish Sarson,“结构化系统开发”-Ken Orr。也许最有影响力的是Tom De Marco 的 “结构化分析和系统详述” ，这本书在伦敦出版社发布。</li>\n</ul>\n<h3 id=\"Dataflow-Diagrams-数据流图\"><a href=\"#Dataflow-Diagrams-数据流图\" class=\"headerlink\" title=\"Dataflow Diagrams (数据流图)\"></a>Dataflow Diagrams (数据流图)</h3><ul>\n<li>结构化分析使用“数据流图”（DFDs）去展示计算机系统的逻辑结构。在DFD中,顺序文件中的记录被概念化为，通过管道 或 沿着传送带移动的数据包，成为数据流。数据包在各个一系列工作区中传递被叫做“处理”，他们被筛选、使用、增强或者改变，最后通往下一个工作区。这有一个数据流图，来自 “数据分析和系统详述” 的316页。</li>\n<li>图【transform analysis】</li>\n<li>用这种方式描述的系统被叫做 “transform analysis”</li>\n<li>D M又简短的介绍了第二种分析方式，叫做 “transaction analysis” 并且提供了这张图。</li>\n<li>图【transaction analysis】</li>\n<li>他阐述了“transform”和“transaction”分析的不同如下：<ul>\n<li>“transform analysis” 应用于那些能明确区分出 输入流、处理中心、输出流的应用。在数据流图术语中,“transform” 由线性网格表示。</li>\n<li>“transaction analysis” 应用于有着突发并行数据流特性应用的“事务中心”。</li>\n</ul>\n</li>\n<li>D M 实际上只花了很少的时间来条论“事务分析”。但是在“结构化设计”这本书里的这个主题却受到了跟多的关注。在第11章，Y和C将第一次描述事务分析归功于P。Y和C描述事务分析是“一个更灵活，SAPTAD技术的更复杂更新”。</li>\n<li>“事务分析”建议通过数据流图表示，类似于图11.1，一个“transform”分裂出一个输入流，和若干个输出子流。这就是一个事件驱动的原型图。</li>\n<li>图【11.1】</li>\n<li>他说：一个“事务”是从一些“元素的数据、控制、信号、事件、或者状态的改变”开始，然后发送到事务中心做处理。</li>\n<li>一个“事务中心”必须具备如下条件：<ul>\n<li>以原始的形式（获取和相应）获得事务</li>\n<li>分析每一个事务，确定他的类型</li>\n<li>根据事务类型分发</li>\n<li>完成每一个事务的处理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Structure-Charts-结构图\"><a href=\"#Structure-Charts-结构图\" class=\"headerlink\" title=\"Structure Charts (结构图)\"></a>Structure Charts (结构图)</h3><ul>\n<li>一个数据流图展示了一个系统必须执行的逻辑功能，但没有说明执行这些功能的程序设计。在结构化分析和设计中，一个不同的图叫做“结构图”，它用来展示程序设计。在“结构图”中，矩形代表模块（函数或子程序）。矩形按等级排列，呼叫模块在上方，被呼叫模块在下方。</li>\n<li>从事务处理数据流图 转换到的结构图如下：</li>\n<li>图【11.2】</li>\n<li>在这个图中，虚线箭头代表控制流从顶部流入事务中心。事务被“GETTRAN”函数获得。一旦事务被捕获，将被分析判断他的类型（它的事务代码）并向上传递给“事务中心”。之后，将发送给“分发”模块，它将根据事务类型分发给不同的事务处理模块。</li>\n</ul>\n<h2 id=\"The-Handlers-Design-Pattern-处理程序设计模式\"><a href=\"#The-Handlers-Design-Pattern-处理程序设计模式\" class=\"headerlink\" title=\"The Handlers Design Pattern (处理程序设计模式)\"></a>The Handlers Design Pattern (处理程序设计模式)</h2><ul>\n<li>如果Y和C的文章写在今天，他们很有可能将他们的“事务分析”的概念叫做设计模式。我将叫它们“处理程序模式”。</li>\n<li>这有一个“处理程序模式”的图.这个图是接着图11.1的事务分析原始数据流图。</li>\n<li>图【Handlers pattern】</li>\n<li>在图中可以看到：<ul>\n<li>有一个数据流叫做“事件”（Y和C叫它“事务”）</li>\n<li>有一个“分发模块”（Y和C叫它“事务中心”）</li>\n<li>还以一系列的处理程序</li>\n</ul>\n</li>\n<li>“分发模块”的工作是获取每个进来的事件，分析事件决定事件的类型，然后发送事件到可以处理对应类型事件的处理程序中。</li>\n<li>“分发模块”必须处理一连串的输入事件流，所以它的逻辑必须包括一个“事件循环”，所以它可以获取事件、分发它，然后循环回来在输入流中处理下一个事件。</li>\n<li>一些应用（例如，控制硬件的应用）可能把事件流看作是无线有效的。但是对于大多数事件处理应用，事件流是有限的，通过在流的最后用一些特殊的事件(一个文件结尾的标志，或者按ESCAPE键，或在GUI上左键点击关闭按钮)标识。在这些应用中，“分发模块”逻辑必须包含“退出”能力来在事件流末尾被发现去结束事件循环。</li>\n<li>在一些情况下，“分发模块”做出的决定可能不能恰当的处理这个事件，它们会丢弃这个事件或者引发（抛出）一个异常。GUI应用一般对类似鼠标按钮点击之类的事件感兴趣，但是对鼠标运动事件不感兴趣。所以在GUI应用中，事件没有处理程序时，通常会被抛弃。对于大多数其他类型的应用，一个不能被识别的事件在输入流中组成一个错误，一个适当的操作是是引出异常。</li>\n<li>这是经典的分发模块的伪代码，来展示一下所有特性：<ul>\n<li>事件循环</li>\n<li>“退出”操作</li>\n<li>判断事件类型，在类型的基础上选择一个恰当的处理程序。</li>\n<li>对没有相应处理程序的处置。</li>\n<li>图【分发模块 伪代码】</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"The-Headless-Handlers-Pattern-无头处理程序模式\"><a href=\"#The-Headless-Handlers-Pattern-无头处理程序模式\" class=\"headerlink\" title=\"The Headless Handlers Pattern (无头处理程序模式)\"></a>The Headless Handlers Pattern (无头处理程序模式)</h3><ul>\n<li>这里有几个处理程序模式的变形体。其中一个是“无头处理程序”模式。在这个模式中，“分发模块”要么确实，要么不是随时可见。去掉“分发模块”，剩下的全部都是事件处理程序的集合。</li>\n<li>图【Headless Handlers Pattern】</li>\n</ul>\n<h3 id=\"The-Extended-Handlers-Pattern-扩展处理程序模式\"><a href=\"#The-Extended-Handlers-Pattern-扩展处理程序模式\" class=\"headerlink\" title=\"The Extended Handlers Pattern (扩展处理程序模式)\"></a>The Extended Handlers Pattern (扩展处理程序模式)</h3><ul>\n<li>另一种变体是“扩展处理程序”模式。在这种变体中，模式包括一个“事件生成器”组件，这个生成器可以生成“分发程序”可以处理的事件流。</li>\n<li>图【Extended Handlers Pattern】</li>\n</ul>\n<h3 id=\"The-Event-Queue-事件队列\"><a href=\"#The-Event-Queue-事件队列\" class=\"headerlink\" title=\"The Event Queue (事件队列)\"></a>The Event Queue (事件队列)</h3><ul>\n<li>在一些案例中，“分发模块”和处理程序可能不能够在事件来的时候尽快的处理他们。在这些案例中，解决方案是将事件输入流存入缓冲区，在事件生成和事件分发当中将“事件队列”引入事件流。事件可以快速的添加到队列的末尾，“分发模块”也可以以最快的速度从队列的前端取出它们。</li>\n<li>GUI应用通常都有事件队列。重要的事件例如鼠标点击可能需要一些事件来处理。在处理当中，其他的事件如鼠标移动事件就要累加在缓冲区中。当缓冲区再次空闲时，它就可以立即抛弃可忽略的事件-鼠标移动事件，然后快速清空序列。</li>\n</ul>\n<h3 id=\"Some-Examples-of-the-Handlers-Pattern-处理程序-举例\"><a href=\"#Some-Examples-of-the-Handlers-Pattern-处理程序-举例\" class=\"headerlink\" title=\"Some Examples of the Handlers Pattern (处理程序-举例)\"></a>Some Examples of the Handlers Pattern (处理程序-举例)</h3><ul>\n<li>现在我们已经介绍了处理程序模式，我应该给你看一些关于这个模式的例子。这些方法和技术可能很相似，但是可能你从来没有在“事件驱动编程”的角度去思考它们。</li>\n</ul>\n<h3 id=\"Objects-对象\"><a href=\"#Objects-对象\" class=\"headerlink\" title=\"Objects (对象)\"></a>Objects (对象)</h3><ul>\n<li>在90年代，面向对象的技术方法逐渐的使七八十年代的结构化的方法失去了光芒。软件方法论者开始用新的图表标记法做实验，去阐述面向对象的概念。与此同时，“对象图”是这些流行的图之一（由GradyBooch发明）。这有一个对象图表的例子。</li>\n<li>图【object diagram of a STACK object】</li>\n<li>在这个“对象图”中，“Stack”是一个对象类型（或者叫做“类”）。“Push”、“pop”、“peek”是他的方法。想要使用“Stack”类，你需要创建stack对象，然后使用对象的方法去做一些事情。</li>\n<li>图【create and usage stack object】</li>\n<li>我喜欢“对象图”，因为它们清楚的展示了一个对象在“无头程序处理模式”中的示例。一个“对象图”，同样的也是一个基本的“无头处理程序”，除了事件是从左面来的而不是从顶部来的。举个例子，Stack类是可以处理“push”、“push”、“pop”事件的一系列事件处理程序（面向对象中叫做“方法”）的集合</li>\n<li>写到这里，如果你是一个面向对象的程序员，你应该已经知道什么是事件驱动编程了。毫不夸张地说，当你在写对象的方法的时候，你就是在写事件的处理程序。</li>\n</ul>\n<h3 id=\"System-系统\"><a href=\"#System-系统\" class=\"headerlink\" title=\"System (系统)\"></a>System (系统)</h3><ul>\n<li>正如我们所看到的，在“结构化系统分析“中，计算机系统被概念化为工厂。原始的原料流入工厂，在传送机的带子（数据流）上前向流动，穿过工作站（处理）最终结束旅程的产品被从门推出。</li>\n<li>原始原料的提供者是“源（sources）”，最终产品的消费者是“盥洗盆（sinks）”。“sources”和“sinks”是数据流的“终端（terminator）”-（它们是数据流开始和结束的地方）。</li>\n<li>“上下文关系图”用来展示系统在终端上下文中关系的状况。这有一个上下文关系图，来自De Marco 的“结构化分析和系统详述”中第59页。</li>\n<li>图【context diagram】</li>\n<li>在1984年，Stephe McMenamin 和 John Palmer 发表了 “基本系统分析（Essential Systems Analysis）”（ESA）。ESA 建立并扩展了结构分析的早期工作，但是它也介绍了计算机系统的概念模式中基本的变化。</li>\n<li>ESA 认为计算机系统不是一个工厂，是一个激励/反馈的机器。激励是在外部世界中，通过终端发送到系统的事件。系统自己概念化为一系列事件处理程序（基本活动）。当一个事件到达，系统就活动了起来，基本活动开始处理事件，然后系统再次进入睡眠状态（静默），直到下一个事件到来。</li>\n<li>基本活动反馈事件是通过在系统核心的数据存储中读写，和产生输出数据流的方式。系统的数据存储构成了“基本内存（essential memory）”。</li>\n<li>这张图展示了计算机系统的基本部分，他们是概念化的ESA。</li>\n<li>图【Characteristic shape of an event-partitioned DFD】</li>\n<li>基本上，ESA展示了一个简单的计算机系统，是一个巨大的面型对象风格对象。系统的基本活动是对象的方法，基本内存是他的内部数据。这个对象是“无头处理程序模式”的例子，它的方法扮演了处理程序的角色，所以在这里完整的计算机系统是一个“无头处理程序模式”的例子，基本活动扮演了处理程序的角色。</li>\n<li>“处理程序模式”中，最完善的系统概念化是JSD（Jackson System Development），都写在了 Michael Jackson 的“系统开发”（1983）这本书中。JSD 是好方法，以论证的方式第一次真的面向对象分析和设计方法。</li>\n<li>JSD系统的设计用SID（system implementation diagram 系统执行图）展示。这是一个典型的SID，来自“系统开发”的293页。</li>\n<li>图【SID】</li>\n<li>在图的顶部，我们看到的“分发模块”在JSD中叫做“调度程序（scheduler）”。事件流从外部系统到达；它叫做SCIN（“调度输入程序 scheduler input”）。事件被发送到CUST-1或ENQ（事件处理程序）。系统内部数据存储到数据库表中，这个表叫做“状态向量（state vector）”文件（成为SVFILE）。EREPLIES是响应中生产出的答复流，去处理询问事件。</li>\n<li>CUST-1 和 ENQ 不是函数；他们是完整对象。这意味着JSD在两个层面使用了“程序处理模式”。在上层，整个系统以完整的“处理程序模式”为出发点，调度程序作为分发模块，对象做事件处理者。第二层面向对象方式的对象，这些方法函数作为事件的处理程序，处理从调度者或者其他对象来的事件。</li>\n<li>ESA 和 JSD 标志着我们的思想从早期的结构化方法中发生巨大的转变。发生巨大转变的原因是，快速发展的数据库技术的出现。在早期的结构化分析的日子里，“数据库管理系统（DBMSs）”基本上不存在。但是，到ESA和JSD出现的时候，计算机化数据处理快速发展，从批处理系统处理顺序文件到在线系统处理数据库。首先它是链接起来的表 DBMSs （IBM 的 IMS， Cullinane的 Cullinet，和 Cincom 的 Total）。紧接着是反向列表DBMSs（adabas，模式204），接下来是关系数据库（DB2，Ingres，Oracle）。DBMS技术的进步便随着数据库设计方法学的开发。</li>\n<li>随着数据库技术的进步和其大规模的使用，大量的开发者都来使用数据库（不是访问他的软件）最为计算机系统的核心。因此，计算机系统的新模式 -作为一系列事件处理程序周边并提供接口给作为系统核心的数据库- 在那时候是非常棒的产品。</li>\n</ul>\n<h3 id=\"Client-Server-Architecture-客户端-服务器架构\"><a href=\"#Client-Server-Architecture-客户端-服务器架构\" class=\"headerlink\" title=\"Client-Server Architecture (客户端-服务器架构)\"></a>Client-Server Architecture (客户端-服务器架构)</h3><ul>\n<li>在CS（Client-Server）架构中架构中有一个“处理程序模式”的熟悉示例。“server”是硬件或者软件的管线，它给“客户端”提供了服务。服务端的工作是等待来自客户端的“服务请求”，根据提供的请求服务反馈“服务请求”，然后等待更多的请求。服务端的例子包括：打印服务，文件服务，窗口服务，数据库服务，应用服务和web服务。如果你经常在网上冲浪，你是在和服务器互动，每当你访问一个新的地址，你的web游览器发送一个请求到web服务器，你请求的web页会反馈你的请求。</li>\n<li>Wesey Chun 在“Python 编程核心”的16章中提供了一个简短、清晰的解释来描述“客户端-服务器“架构的基础。（我想稍微的修改了一下文本来提高技术的连贯性）。想象一下，Chun 说：<ul>\n<li>一个既不吃也不睡，也不休息的空闲柜员，在一个从来看不到尾的流水线中服务一个又一个顾客。流水线可能会很长或者有时会空闲，但在任何时候，顾客都有可能会出现。当然，这些柜员是多年前幻想出来的，但是现在的自动柜员机（ATMs）是很接近这个模型的。</li>\n<li>当然，这些柜员是在无限运行的服务器。每个客户端都要发送一个请求服务器的“服务请求”。客户端的请求到达服务器，并以先来先服务的方式处理请求。一次交互完成，客户就走了，服务端要么服务下一个客户，要么等待直到下一个随之而来的客户。</li>\n</ul>\n</li>\n<li>这有一个案例，描述了“处理程序模式”这个术语。</li>\n<li>图【client-serer Handlers pattern】</li>\n<li>每个银行顾客代表了一个从客户端发送来的服务请求（事件，事务）。</li>\n<li>客户排队或者等候服务。服务端和不知疲劳的柜员很相似，因为它们都是事件处理程序的集合，都能处理不同的事件请求。并且银行柜员的“无限循环”也就是“分发模块”的事件循环。</li>\n</ul>\n<h3 id=\"Messaging-Systems-消息系统\"><a href=\"#Messaging-Systems-消息系统\" class=\"headerlink\" title=\"Messaging Systems (消息系统)\"></a>Messaging Systems (消息系统)</h3><ul>\n<li>“消息系统”代表了“程序处理模式”的极端版本。“消息系统”的目的是，在发送者和接收者在不同的物理位置或者运行在不同平台上的情况下，从事件的生成者（发送者）获取事件（消息）并处理（接收者）消息。</li>\n<li>在“消息系统”中，消息通常发送给特定的接收者，所以分发函数（决定接收者应该接收什么消息）是很普通的函数。一个熟悉的“消息系统”的例子是邮局。一个发送者发送一个消息（信件或者包裹）到邮局（“消息系统”）。邮局在消息中读取收信者的地址，并且传送信息给收信者。</li>\n<li>图【Messaging System】</li>\n<li>E-mail “消息系统”本质上和邮局的功能差不多。唯一的不同是E-mail的消息是电子编码而不是物理编码。</li>\n<li>可能大多数精密的消息系统是企业的消息系统，使用“面向消息的中间件”或者MOM。在MOM系统中，发送者和接收者是计算机应用，而不是人。MOM系统允许计算机应用在物理分离或者运行在不同的软硬件平台下互相通信。例如，一个大公司的办公区和服务器在地理位置上分散。MON软件允许在公司的LA处的管理入口系统以电子的形式发送给在Chicago服务器上的应用一个指令结束，也可以在纽约服务器上的程序管理报道，全都不需要人干预。</li>\n<li>再加上，对于这种点对点的通讯模式，MOM产品也支持发布/订阅模式。在发布/订阅模式中，接收者成为了通过主题订阅的订阅者，发送者要发送消息到主题中，而不是个人订阅者）。当主题收到消息，这个主题会将消息发送给所有订阅它的接收者。</li>\n<li>图【publish/subscribe model】</li>\n<li>在MOM系统中，电子通信问题（队列问题，发布/订阅模式的执行问题）使系统的处理程序方面变得简单。然而，这么做的目的使帮助理解MOM系统，作为一个极端简单且专用的处理程序模式的例子。</li>\n</ul>\n<h2 id=\"Frameworks-框架\"><a href=\"#Frameworks-框架\" class=\"headerlink\" title=\"Frameworks (框架)\"></a>Frameworks (框架)</h2><h3 id=\"Object-Oriented-Event-Driven-Programming-面向对象事件驱动编程\"><a href=\"#Object-Oriented-Event-Driven-Programming-面向对象事件驱动编程\" class=\"headerlink\" title=\"Object-Oriented Event-Driven Programming (面向对象事件驱动编程)\"></a>Object-Oriented Event-Driven Programming (面向对象事件驱动编程)</h3><ul>\n<li>现在让我们来看一个全景 - “程序处理”模式在现代计算机的不同方面是怎么体现的。然我们在代码层面看“程序处理”模式是怎样工作的。</li>\n<li>考虑到与客户打交道的业务。业主自然想有一个信息系统来存储、恢复、更新他顾客信息的账户。他想要的系统可以处理各种事件：需要添加一个新的客户账户，可以修改账户名、关闭账户，诸如此类。所以系统必须有处理各种类型事件的事件处理程序。</li>\n<li>图【business information system】</li>\n<li>在面向对象编程出现之前，这些事件处理程序作为子程序来执行。这些代码在分发模块的事件循环中，像下面这样：</li>\n<li>图【dispatcher pseudo-code】</li>\n<li>子程序的类似这样：</li>\n<li>图【subroutines pseudo-code】</li>\n<li>现在，使用面向对象技术，事件处理程序作为对象的方法执行。这些代码在分发模块的事件循环中，像下面这样：</li>\n<li>图【dispatcher OO pseudo-code】</li>\n<li>“账户”类和他的方法（事件处理函数），像下面这样：</li>\n<li>图【account class methods】</li>\n<li>使用面向对象技术这种方式没有很激动。基本上来说，我们只是用对象取代了数据库记录；换句话说，数据处理的过程没什么变化。</li>\n<li>但是它变得更有趣……</li>\n</ul>\n<h3 id=\"Frameworks-框架-1\"><a href=\"#Frameworks-框架-1\" class=\"headerlink\" title=\"Frameworks (框架)\"></a>Frameworks (框架)</h3><ul>\n<li>使用面向对象技术可以相对容易的开发普遍的、可复用的类。这是面向对象技术的一个优势。</li>\n<li>举个例子，假设有一个商业的，多用途的业务类产品-“通用业务”。通用业务是一个软件框架，可以直到怎样展示多样的一般化商业功能（打开顾客账号，关闭顾客账号，诸如此类）。显然，因为所有的业务不同，通用业务允许可以根据业务特定的需求定制框架。</li>\n<li>假设接下来，Bob是一个小的业务员，他买了一个通用业务软件。在他使用软件之前，Bob需要根据他的需求定制软件。我们能想到Bob有很多定制化的事情要做：他的名字、他卖的东西的名字、它允许使用哪种信用卡，诸如此类。但是经过讨论，让我们看看Bob最急迫的需求，他想定制通用业务来使用MySQL存储账号信息。</li>\n<li>通用业务是已经写好的。他不能预测到企业将使用哪个DBMS。这意味着通用业务（就算知道怎样打开和关闭用户账号）不知道怎样持久化数据库的账户数据。当然，他也不可能知道企业用什么DBMS（Oracle， Sybase， DB2， MySQL，Postgres），通用业务不知道在账户类的“persist()”方法中该写什么代码。</li>\n<li>这意味着Bob必须自己在他的“persist()”方法中写代码。</li>\n<li>也就是说，通用业务有个问题，它怎么确保像Bob这样的用户会给“persist()”方法写代码呢？</li>\n<li>通用业务给出的解决方法不是提供一个全功能的账户类，而是提供半成品类（仅实现全功能账户类的某些方法）。实现的这部分，我们叫它通用账号类。通用账号类提供一些方法的完整实现，并且给像Bob这样的业务员预留了“插入点”，Bob必须添加他的业务代码。</li>\n<li>“插入点”是代码中的位置，在软件框架中期望事件处理程序插入的地方。事件处理程序本身叫做“插件（plug-ins）”</li>\n<li>包含“插入点”的半成品类的技术学名叫做“抽象类”。不同语言提供不同的方式定义插入点。例如，java提供了关键字“abstract”和叫做“abstract methods”的插入点。</li>\n<li>抽象方法不是真的方法。而是方法的占位符；一个可以插入具体方法的地方。包含抽象方法的Java类叫做抽象类。抽象类不能实例化。使用抽象类的唯一方法是创建一个子类开扩展它，然后在子类中定义具体方法（实现抽象类中每一个抽象方法）。Java强制执行此要求。Java不能编译通过企图实例化抽象类的程序。</li>\n<li>这意味着，Bob使用通用业务的通用账号类的方法是他自己创建一个具体的类来扩展它，并且实现抽象方法。如果通用账号类如下：</li>\n<li>图【an abstract lass GenericAccount】</li>\n<li>Bob的账号类如下：</li>\n<li>图【extends GenericAccount】</li>\n<li>Python,一个动态语言，以不同的方式支持“插入点”和抽象类。在Python中，实现一个“插入点”最简单（其他实现抽象方法的方式在附录A中）的方法是定义一个什么都不做的方法，但是提出异常（raise exception）。如果方法没有完全实现，并且有程序调用它，那么就会触发运行时异常。这有一个python写的抽象方法的例子：</li>\n<li>图【python abstract method】</li>\n<li>一条软件的通用术语是这样的工作方式（定义“插入点”，然后需要插件补充）是“框架”。如果你Google搜索术语“框架”以你会获得这样的一些定义。每个定义都包含框架的一部分。一个框架是：<ul>\n<li>用于支撑或者封闭其他的一些东西的骨架结构。</li>\n<li>一个广泛的概述、大纲或者框架，可想向其中添加细节。</li>\n<li>一个可扩展的软件环境，可以根据特定需求定制。</li>\n<li>一系列类，为一些应用的问题提供通用的解决方案。一个框架通常精炼以通过专业化或其他类或类型解决特定问题。</li>\n<li>一个组件，它允许通过写插件模块（框架扩展）的方式扩展其功能性。扩展的开发者通过从框架中定义的类接口写自己的类。</li>\n<li>软件主体设计成高复用模式，加上特定功能的插件以适应特定的系统的功能性需求。当安装了插件，系统将围绕插件表现出相应的行为。</li>\n</ul>\n</li>\n<li>这个框架模式的基本概念是“处理程序模式”。“框架扩展”或者“插件”是“事件处理”模块。</li>\n<li>图【framework and entensions(handlers)】</li>\n</ul>\n<h3 id=\"SAX-an-example-of-a-framework-框架举例-SAX\"><a href=\"#SAX-an-example-of-a-framework-框架举例-SAX\" class=\"headerlink\" title=\"SAX - an example of a framework (框架举例-SAX)\"></a>SAX - an example of a framework (框架举例-SAX)</h3><ul>\n<li>框架有各种形状尺寸，从大到小都有。开看一下真实的框架是怎么使用的，然我们来看一个小框架：SAX（实际上，SAX不是一个框架。他可以在框架中实现的API。但是为了保持事情简单，我们就当它是个框架）。</li>\n<li>XML越来越流行。只有一个结果，就是很多开发者第一时间在SAX（一个简单的XML API）框架中遇到了事件驱动编程。SAX是事件驱动的XML语法分析器。它的工作是打开（解析）XML成可理解的片段。例如，SAX分析器可以分析以下字符串：</li>\n<li>图【XML string】</li>\n<li>解析成如下三个片段：</li>\n<li>图【three pieces】</li>\n<li>使用SAX解析器，你给他一大块XML字符串。它解析XML文本成不同的片段，然后调用适当的预先确定的插件（事件处理程序）去处理片段。</li>\n<li>SAX为解析各种XML的特征，诸如打开和关闭标签（startElement，endElement），标签中间的文本，注释，处理指令等等，制定了预定义的插入点。</li>\n<li>SAX框架提供了“解析器（Parser）”类和一个抽象类“内容处理器（ContentHandler）”。使用它，首先要创建ContentHandler的子类，并且写一个具体的方法（事件处理模块）去覆写抽象方法。这有个用python写的简单例子。它在控制台打印XML的标签名和标签中的数据。（完整的python SAX例子可以在附件B）。</li>\n<li>图【over-ride abstract methods】</li>\n<li>你扩展“内容处理程序”类和指定事件处理程序：<ul>\n<li>使用SAX的 make_parser 工厂函数解析器对象。</li>\n<li>实例化“CustomHandler”类创建一个“myContentHandler”对象</li>\n<li>告诉解析器对象使用“myContentHandler”对象处理XML内容</li>\n<li>将XML文本传给解析器，让事件处理模块去工作</li>\n</ul>\n</li>\n<li>这有用Pyhton怎样完成的过程：</li>\n<li>图【python parse XML in file】</li>\n</ul>\n<h3 id=\"Why-programming-with-a-framwork-is-hard-为什么用框架编程很难\"><a href=\"#Why-programming-with-a-framwork-is-hard-为什么用框架编程很难\" class=\"headerlink\" title=\"Why programming with a framwork is hard (为什么用框架编程很难)\"></a>Why programming with a framwork is hard (为什么用框架编程很难)</h3><ul>\n<li>到处理只由输入XML文本给解析器（没有更多了）构成的程序的最后一步了。对于一个面向过程背景的程序员，对事件驱动编程会很困惑。在面向过程编程中，控制的主要流程在主程序之内。附属程序或者模块仅仅是公用程序或者帮助调用展示低等级的任务。主程序的控制流通常很长并且复杂，它的复杂让应用有特定的逻辑结构。程序具有形状，并程序员可以看到该形状。</li>\n<li>但是当面向过程的程序员开始使用框架编程，他失去了所有的控制权。没有了清晰的控制流（主程序除了开始了框架的事件循环什么也没做）。并且一旦事件循环开始了，隐藏在框架中的代码就驱动开始动作。该程序剩余的部分仅仅是帮助程序模块（事件处理程序）的集合。总之，程序结构看起来被彻底搞砸了。（框架和公共库是不同的。当使用公共库时，程序员可以完全控制程序流程，当他们需要公共库时调用它们，主动权在程序员。但是在框架中，是在框架需要时，框架负责调用程序员写的事件处理程序模块。主动权在框架。这是谁负责的问题。）</li>\n<li>所以面向过程的程序员经常发现，在它们第一次遇到事件驱动和框架驱动编程时觉得完全不能理解！经验和熟悉会逐步减少这种感觉，这是毫无疑问的（从面向过程编程转移到事件驱动编程时一个很大的心里范式的转变）。这就是Robin Dunn 和 Dafydd Rees 在文章开始时描述的范式转变。</li>\n</ul>\n<h2 id=\"GUI-programming-GUI编程\"><a href=\"#GUI-programming-GUI编程\" class=\"headerlink\" title=\"GUI programming (GUI编程)\"></a>GUI programming (GUI编程)</h2><h3 id=\"Why-GUI-programming-is-hard-为什么GUI编程很难\"><a href=\"#Why-GUI-programming-is-hard-为什么GUI编程很难\" class=\"headerlink\" title=\"Why GUI programming is hard (为什么GUI编程很难)\"></a>Why GUI programming is hard (为什么GUI编程很难)</h3><ul>\n<li>现在我们看到了框架时如何工作的，来让我们看一下最常用的框架和事件驱动编程：GUIs（图形用户界面 graphical user interfaces）</li>\n<li>GUI编程时困难的，们个人都这么认为。</li>\n<li>首先，只需的指定GUI的外观就需要大量工作。每个窗口小部件（每个按钮、标签、菜单、输入框、列表框等等）都必须告诉它应该长什么样（形状、大小、前景色、背景色、边框样式、字体等等），他应该能确定他自己的位置，比如怎样在GUI大小改变时做出适配，怎样适应整个GUI的层次结构。仅仅是指出GUI怎么展现就有大量的工作。（这就是为什么框架中会有IDEs和屏幕画家。它们的工作就是减轻GUI编程的负担）</li>\n<li>第二（与本文主题最相关），GUI编程很难是因为在GUI中有各种事件要处理。几乎每个GUI中的窗口小部件（每个按钮、多选框、单选框、数据输入区域、列表框（包括列表中每个项目）、文本框（包括水平和垂直滑块）、菜单栏、菜单栏图表、下拉菜单、下拉菜单中的每一项 等等很多）。几乎每个都是事件生成器，都能生成各种类型的事件。这还没完，硬件输入设备也是事件生成器。鼠标可以生成左键点击、右键点击、左键双击、右键双击、按钮按下事件（为了初始化拖拽操作）、鼠标移动事件、按钮抬起事件（为了结束拖拽操作）等一些其他事件。键盘上每个字母、数字、可敲击的按键和功能按键（包括单独和与SHIFT、ALT、CONTROL组合的按键）都可以生成事件。有大量的事件被送入“分发”模块的事件循环，GUI程序员必须为每个GUI用户可能生成的事件写好事件处理程序。</li>\n<li>第三，事实上每个GUI工具包都以框架的形式提供给程序员。GUI框架（像SAX框架）的目的是减轻GUI程序员的负担。举个例子，GUI框架提供事件循环和事件队列来缓解程序员的工作。但是，正如我们看到的SAX，使用框架就意味着大块的程序控制流被隐藏在框架的封装机器当中，并且对与GUI程序员不可见。这意味着GUI程序员必须掌握范式的转变，转移到事件驱动编程。</li>\n<li>这有很多事要处理。这还不是全部，这又“观察者”模式需要掌握……</li>\n</ul>\n<h3 id=\"The-Observer-Pattern-观察者模式\"><a href=\"#The-Observer-Pattern-观察者模式\" class=\"headerlink\" title=\"The Observer Pattern (观察者模式)\"></a>The Observer Pattern (观察者模式)</h3><ul>\n<li>观察者模式在GUI框架的事件驱动编程中使用的很广泛。所以我们用迂回的方式来解释观察者模式。等到这个话题结束，我们将返回到GUI编程上面来，并给出观察者模式是怎样在GUI编程中使用的。</li>\n<li>第一次命名和描述观察者模式是在有名的“Gang of Four”的书“设计模式”中（出自 Gamma，Helm， Johonson， Vlissides （Addison-Wesley， 1995））。 观察者模式的基本想法Dafydd Rees引用了导言中的原理。这个原理是“好莱坞原理”：“不要来找我，我会叫你”。当然这个名字来自于演戏或者电影的演员试镜中。导演（电影中掉选角色的人），不想受到想演他的戏还没得到角色的演员找他的困扰，所以他告诉大家，“不要来找我们，我会回来找你”。</li>\n<li>好莱坞原理更长的版本是：<ul>\n<li>“不要来找我们，给我们你的电话，当我们想给你一份工作的时候我们会找你”。</li>\n</ul>\n</li>\n<li>这就是观察者模式的本质。</li>\n<li>在观察者模式中，有一个主体和多个观察者实体。在试演场景中，导言就是主体，演员就是观察者。当事件发生（导演对他们感兴趣）的时候观察者想要主体通知它们，所以它们在主体那里注册（留下能找到他们的方式说明）。当感兴趣的事情（比如选好了演员）发生时，主体就会通知它们。为了完成这项工作，主体要保存一个列表，列表中记录了所有注册观察者的名字和地址。当有趣的事情发生时，他会通过他的观察者列表去通知在这类事件中注册此类事件的哪个观察者。</li>\n<li>观察者模式也叫做“发布/订阅”模式。回想一下订阅报纸的例子。在“发布/订阅”模式中，主体就是信息或出版物的发布者。观察者就是出版物的订阅者。注册的过程叫做订阅，通知的过程叫做发刊。“发布/订阅”是个合适的名字，适用于长时间内重复发生通知/发布的情况，相同的通知发送给多个订阅者，并且订阅者可以取消订阅。</li>\n<li>观察者模式是事件处理模式中的特殊例子，原因是我觉得更应该叫做订阅程序处理模式。</li>\n<li>下一页使用python实现的观察者模式。在这个例子中，还继续使用好莱坞的主题，观察者是演员。主体是一个天才代理人叫做HotShots。演员在天才代理人那里注册，当有一个演员角色的试镜，代理人会通知演员。自从代理人不断地给演员发通知，这个例子就有了发布/订阅模式的味道。</li>\n<li>（如果你是Java程序员，请不要担心，事实上我们是想减少定义CastingCall和Observer类。这在像python这种动态语言中是可能的，现在这里是为了保持代码简短。在Java中，你需要声明类和它们的实例变量的细节）。</li>\n<li>图【Python showing Observer pattern】</li>\n<li>正如你在代码中看到的那样，天才代理人（主体）是它自己的事件处理程序。具体的说，他的“notify”方法是“CastingCall”事件的事件处理程序。</li>\n<li>天才代理人通过发送“CastingCall”到它自己的“notifyActors”方法来处理“CastingCall”。“notifyActors”方法通过通过代理人的订阅人/观察者/演员列表找到相应人选并且发送通知给合适的订阅者。</li>\n<li>在真实的应用中，通知的过程将包括与每个演员（事件处理程序）联系，演员会通过选角的方式来回应。然而，在这个简单的例子中，通知的过程只包含了打印一个信息来说明这个演员被通知了。</li>\n<li>如果你运行这个程序，会得到如下输出：</li>\n<li>图【Python showing Observer pattern Output】</li>\n</ul>\n<h3 id=\"Event-Objects-事件对象\"><a href=\"#Event-Objects-事件对象\" class=\"headerlink\" title=\"Event Objects (事件对象)\"></a>Event Objects (事件对象)</h3><ul>\n<li>这个程序有个功能，你应该特别注意。它使用了CastingCall对象的时候带着参数（实例化变量）“source”和“role”。在这里，CastingCall对象是事件对象（控制事件的对象）。</li>\n<li>事件对象是事件驱动编程中非常好的工具。在面向对象的编程语言中，事件或者事务都是极端受限的。在一些案例中，如果你想发送一个事件到以事件处理器中，你发送的所有都是一个包含事务代码的字符串。但是面向对象技术通过允许我们创建和忽略事件对象完全的改变了它。事件对象的本质是将我们需要的时间信息打包起来。</li>\n<li>一个事件对象当然也可以携带触发它事件种类的名字。但是，依赖与应用，它可以携带更多信息。在这个HotShots天才代理的案例中，事件对象包含选角色的“source”和role信息。</li>\n<li>在其他应用中，我们可能想放入大量完整的信息到我们的事件对象中。考虑一下著名的Model-View-Controller（MVC）模式。观察者模式就是MVC的核心。在MVC中，Model是一个管理数据和一些应用域的对象（它是观察者模式中的主体）。Views在Model中作为观察者注册。当Controller改变了Model，Model就会通知订阅它的观察者（Views）这个（Model）改变了。</li>\n<li>最简单的MVC版本被叫做“pull”（拉取）版本。在这个版本中，事件对象（当Model变化时，Model向Views发送的通知）几乎不包含什么信息。Model的描述没有改变，他只是通知Views发生了某种变化。当Views收到了这样的通知，它们必须从Model拉取信息。这样，它们必须询问Model当前状态的信息，并且从这些信息中刷新它们自己的状态。</li>\n<li>大多数复杂的MVC版本叫做“push”（推送）版本。在这个版本中，Model 推送变化信息给Views。事件对象发送给Views，对象包含了大量复杂的信息（Model产生的一个完整详尽的变化描述）。当Views收到了这些信息，它就拥有了所有信息，他会根据这些信息更改他自己。</li>\n<li>MVC的“push”和“pull”版本的根本区别简单来说就是放入事件对象包中的信息总数不同。</li>\n</ul>\n<h3 id=\"The-Registered-Handlers-pattern-in-GUI-applications-GUI应用程序中的“注册处理程序”模式\"><a href=\"#The-Registered-Handlers-pattern-in-GUI-applications-GUI应用程序中的“注册处理程序”模式\" class=\"headerlink\" title=\"The Registered Handlers pattern in GUI applications (GUI应用程序中的“注册处理程序”模式)\"></a>The Registered Handlers pattern in GUI applications (GUI应用程序中的“注册处理程序”模式)</h3><ul>\n<li>现在你已经熟悉了基本的 观察者/注册 处理程序模式，来让我们看看这个模式在GUI编程中是如何使用的。</li>\n<li>这有另一个程序的代码。在结构上，这段代码和Hotshots天才代理的代码很像，但是名字用了处理程序模式的专用术语，事件是GUI事件。</li>\n<li>在这个例子中，“主体”是分发模块（工作在GUI中的事件循环）。</li>\n<li>为了保持代码简短，程序只包含观察者（“demoHandler”函数是双击鼠标左键的事件处理函数）。</li>\n<li>展示这个处理程序的动作，程序生成一个模仿鼠标左键双击的事件（LeftMouseDoubleClick 事件）。</li>\n<li>图【Python showing Registered Handlers pattern】</li>\n<li>如果你运行这个代码，会得到如下输出：<ul>\n<li>图【Handling LeftMouseDoubleClick from mouse】</li>\n</ul>\n</li>\n<li>在如下语句中：<ul>\n<li>图【demoDispatcher.registerObserver( demoHandler, MOUSE_LEFT_DOUBLE)】</li>\n</ul>\n</li>\n<li>和这句：<ul>\n<li>图【observer.eventHandler = argEventHandler】</li>\n</ul>\n</li>\n<li>程序在传递“demoHandler”函数对象的引用。它这是将函数作为“全功能对象”（支持所有操作，基本的包括：作为参数传递、从函数返回、赋值给其他变量）。这不是所有的编程语言都支持的，也就是意味着，在不同的编程语言中，实现观察者/注册处理程序模式的方式会很不一样。</li>\n</ul>\n<h3 id=\"Registering-Event-Handlers-in-Python-“Binding”-Pyhton中的注册事件处理程序-“绑定”\"><a href=\"#Registering-Event-Handlers-in-Python-“Binding”-Pyhton中的注册事件处理程序-“绑定”\" class=\"headerlink\" title=\"Registering Event-Handlers in Python - “Binding” (Pyhton中的注册事件处理程序-“绑定”)\"></a>Registering Event-Handlers in Python - “Binding” (Pyhton中的注册事件处理程序-“绑定”)</h3><ul>\n<li>这些是“注册处理程序”模式后的基本思想。现在让我们看一下在Python和Java的GUI应用中“注册处理程序”模式是什么样的。</li>\n<li>开源动态语言如：Python、Perl 和 Ryby 通常提供多样的开源GUI框架接口开支持GUI编程。在Python中，也提供了一些这样的接口。最流行的是tkinter（向Tcl/Tk提供的接口）和wxPython（向wxWidgets提供的接口）。</li>\n<li>使用这些接口的基本概念是非常相似的。在接下来的讨论中，我会用Python和tkinter的例子，来阐述在GUI编程中“注册处理程序”模式的样子。</li>\n<li>在Python和tkinter中，所有的GUI事件都术语一个单独的类：“event”。事件处理程序带着GUI窗口小部件（按钮之类的）注册到程序中，为了处理特定类型的事件，比如鼠标点击，按键按下。在PYthon中，注册一个事件处理程序的过程叫做“binding”（）绑定。</li>\n<li>这有个简单的例子。假设我们的程序已经有了一个事件处理程序（一个函数或者方法）叫做“OKButtonEventHandler”。它的工作是处理发生在GUI中的“OK”按钮上的事件。</li>\n<li>注意，在Python中没有特别或者神奇的事情发生，Python中没有叫做“OkButtonEventHandler”的程序（只要我们想，我们可以将这个程序的名字叫做“Floyd”或者“Foobar”都可以）。我们将要看到是Python和Java中唯一不同的地方。</li>\n<li>接下来的代码片段创建了在观察者模式中的“subject 主体”窗口小部件。这个主体是一个GUI窗口小部件（一个按钮），它可以展示文本“OK”。这个OK按钮对象是一个Tkiner.Button类的实例对象。</li>\n<li>图【OkButton = Tkinter.Button(parent, text=”Ok”)】</li>\n<li>在调用Button类的构造函数中，“parent”参数链接了按钮对象到其所有者的GUI对象上（可能是框架或者窗口）。</li>\n<li>Tkinter小部件提供了一个叫做“bind 绑定”的方法来将事件绑定到窗口小部件上。更精确的说，“bind”方法提供了一种绑定或者说结合三个不同的事情：<ul>\n<li>一个事件类型（例如，鼠标左键点击，或者在键盘按下回车键）。</li>\n<li>一个窗口小部件（例如，在GUI上一个特定的按钮窗口小部件）。</li>\n</ul>\n</li>\n<li>例如，我们想在窗口的“关闭”按钮上绑定一个鼠标左键单击的函数或者方法：“closeProgram”。想要的效果是，当用户鼠标点击“关闭”按钮时，调用“closeProgram”关闭窗口。</li>\n<li>这有一个代码片段，绑定了一个OKButtonEventHandler程序和键盘事件（“\\<return>”）的组合到OKButton窗口小部件：</return></li>\n<li>图【OkButton.bind(“\\<return>“, OkButtonEventHandler)】</return></li>\n<li>该语句将作为观察者的OkButton窗口小部件和OkButtonEventHander函数注册到键盘事件“\\<return>”中（当Ok按钮对象获得键盘焦点时发生的事件）。</return></li>\n<li>这有另一段代码片段（可能就在同一个程序中发生，就在上一个代码之后）。它绑定了OkButtonEventHandler程序和鼠标左键点击事件到Ok按钮窗口小部件：</li>\n<li>图【OkButton.bind(“\\<button-1>“, OkButtonEventHandler)】</button-1></li>\n<li>当这两个事件中的任何一个发生了，事件将事件对象作为参数发送给OkButtonEventHandler函数。OkButtonEventHandler函数可以（如果他想）询问事件对象，并且决定是否触发一个按键按下或者鼠标点击事件。</li>\n</ul>\n<h3 id=\"Registering-Event-Handlers-in-Java-“listeners”-Java中的注册事件处理程序-“监听”\"><a href=\"#Registering-Event-Handlers-in-Java-“listeners”-Java中的注册事件处理程序-“监听”\" class=\"headerlink\" title=\"Registering Event-Handlers in Java - “listeners” (Java中的注册事件处理程序-“监听”)\"></a>Registering Event-Handlers in Java - “listeners” (Java中的注册事件处理程序-“监听”)</h3><ul>\n<li>Java也支持GUI事件处理程序注册技术，但是它的方式和Python的有些不一样。</li>\n<li>Java提供了多种GUI编程的选择（AWT和Swing）。这允许程序员可以用两种方式创建GUI的视觉层，并且监听GUI事件。</li>\n<li>对于GUI的事件处理方面，java.awt.event包提供了许多不同的事件对象类型：<ul>\n<li>ActionEvent        InvocationEvent</li>\n<li>AdjustmentEvent    ItemEvent</li>\n<li>ComponentEvent     KeyEvent</li>\n<li>ContainerEvent     MouseEvent</li>\n<li>FocusEvent         MouseWheelEvent</li>\n<li>InputEvent         PaintEvent</li>\n<li>InputMethodEvent   TextEvent</li>\n</ul>\n</li>\n<li>这些事件的类型每个都包含适合它类型的变量和方法。例如，“MouseEvent”对象包含鼠标事件的变量个方法，“KeyEvent”对象包含键盘事件的变量个方法。举个例子：<ul>\n<li>“MouseEvent.getButton()”传递了鼠标按钮引发的事件。</li>\n<li>“MouseEvent.getClickCount()”传递了触发鼠标点击的数量的事件</li>\n<li>“MouseEvent.getPoint()”告诉在GUI组件中鼠标光标位置的x，y坐标。</li>\n<li>“KeyEvent.getKeyChar()”告诉了键盘按下了哪个按键。</li>\n</ul>\n</li>\n<li>java.awt.event包也提供了通用了事件监听接口和专门监听接口集合来扩展它。专门监听接口如：<ul>\n<li>ActionListener       MouseListener</li>\n<li>ContainerListener    MouseMotionListener</li>\n<li>FocusListener        MouseWheelListener</li>\n<li>InputMethodListener  TextListener</li>\n<li>ItemListener         WindowFocusListener</li>\n<li>KeyListener          WindowListener</li>\n</ul>\n</li>\n<li>这些专门的监听接口围绕着不同的事件类型建立。这些处理相同类型的事件对象（一个监听接口是方法（事件处理程序）的集合）。例如，在鼠标监听接口中的方法处理鼠标事件，“KeyListener”接口的方法处理“KeyEvent”事件，诸如此类。</li>\n<li>在接口中，事件处理程序具有描述性的硬编码名称。例如，“MouseListener”接口提供五个事件处理程序方法：<ul>\n<li>mouseClicked(MouseEvent e)</li>\n<li>mouseEntered(MouseEvent e)</li>\n<li>mouseExited(MouseEvent e)</li>\n<li>mousePressed(MouseEvent e)</li>\n<li>mouseReleased(MouseEvent e)</li>\n</ul>\n</li>\n<li>GUI由多个GUI组件（窗口小部件）组成，例如面板、列表、按钮等。当GUI程序运行起来，窗口小部件是GUI事件（鼠标点击、按键等）的来源。</li>\n<li>就观察者而言，窗口小部件是模式的“主体”。因此，每个窗口小部件必须提供一些让观察者注册的方法。在Java中，这通过每个Java的GUI类（JPanel、Button、JList等）提供注册观察者对象的方法的方式完成。JPanel提供了一个“addMouseListener()”方法来注册鼠标事件的观察者；JButton提供“addActionListener()；诸如此类。</li>\n<li>建立GUI程序，一个Java程序必须做如下任务：<ul>\n<li>创建和定位GUI和窗口小部件的视觉化组件。</li>\n<li>创建一个或多个监听对象（在适合的监听接口中，对象实现了所有的事件处理程序的方法）。</li>\n<li>使用窗口小部件的“add[xxx]Listener()”来注册监听对象和适合的主体窗口小部件。</li>\n</ul>\n</li>\n<li>当GUI事件（例如鼠标点击事件）在主体窗口小部件发生时，在注册监听对象中，窗口小部件调用“mouseClicked()”事件处理程序方法，并将鼠标点击事件传递给它。</li>\n<li>这有个基于Sun公司教程的代码示例“怎样写一个鼠标监听”：</li>\n<li>图【How to Write a Mouse Listener】</li>\n<li>在代码中，“inputArea”对象是事件生成器。“mouseClicked()”方法是事件处理程序。它也是注册处理程序/观察者模式的例子。在观察者模式中“inputArea”是主体，如下这行：</li>\n<li>图【inputArea.addMouseListener(this)】</li>\n<li>在“inputArea”中注册的“this”（DemoGUI）是观察者。</li>\n<li>有趣的是，则个例子展示了Java中是怎么样完成多继承的。在这个例子中，DemoGUI类是GUI窗口小部件也是监听者。它是一个从JPanel继承的JPanel，所以对于inputArea窗口小部件来说它是GUI容器对象。并且他还是监听者（它实现了“MouseListener”接口中的方法（如“MouseClicked”））。</li>\n<li>注意在Java中，事件处理程序方法通过listener接口实现方法的定义，所以名字（如“mouseClick”）是由接口来决定的，所以在起名字的问题上程序员没有选择。Python中的容器，我们可以看到，程序员可以以他们认为合适的任何方式给事件处理方法起名字。</li>\n</ul>\n<h3 id=\"Callback-programming-回调编程\"><a href=\"#Callback-programming-回调编程\" class=\"headerlink\" title=\"Callback programming (回调编程)\"></a>Callback programming (回调编程)</h3><ul>\n<li>当你读GUI框架的文档的时候，你会注意到观察者/事件处理程序叫做“callback”，因为主体窗口小部件会“回调”它们去处理事件。所以你经常看到这种编程类型叫做“回调编程”。</li>\n</ul>\n<h3 id=\"GUI-programming-summary-GUI编程-概要\"><a href=\"#GUI-programming-summary-GUI编程-概要\" class=\"headerlink\" title=\"GUI programming - summary (GUI编程-概要)\"></a>GUI programming - summary (GUI编程-概要)</h3><ul>\n<li>这里我们全身心的投入到GUI应用中事件驱动编程的论题中。或者应该说，我们讨论的是GUI编程的上下文环境中的处理程序模式。</li>\n<li>从根本上来说，GUI编程和其他那些我们见过的处理程序模式的例子没有太多不同。GUI编程和其他处理程序模式的形式不同在于，它大多总是牵扯到“观察者模式”。这就是为什么：GUI城边大多总是包含注册或绑定的过程（事件处理程序（观察者）捆绑到（注册到）事件生成器（主体））。</li>\n<li>注册的过程开起来就是基础的事件处模式上的一个小变化（这只是一个结合事件处理程序和事件生成者的特殊方式）。</li>\n</ul>\n<h2 id=\"Maintaining-State-维持状态\"><a href=\"#Maintaining-State-维持状态\" class=\"headerlink\" title=\"Maintaining State (维持状态)\"></a>Maintaining State (维持状态)</h2><ul>\n<li>许多事件驱动应用程序时无状态的。者意味着当应用程序处理完成了一个事件，应用程序没有被事件改变。</li>\n<li>与无状态应用对立的时有状态应用。有状态的应用程序可以通过事件来改变应用的进程。具体来说，有状态程序可以记住或保持事件之间的信息，它们所记住的信息（它们的状态信息）可以通过事件来改变。</li>\n<li>锤子是个无状态的工具，如果你要钉钉子，锤子就和你钉钉子之前没区别，锤子还是之前那样。订书机时有状态的工具，如果你用它钉一些纸，钉的这个动作就会改变它的状态（在钉这个动作之后，订书机就会比之前少一个订书钉）。</li>\n<li>在大多数基本Web游览的类型中，一个Web服务器收到一个展示的特定页的请求，返回请求页，在结束之后什么都没记住。这就是无状态的应z。大多数有经验的网页会展示访问次数（“自从2000年1月1日，这个页面已经被访问了876532次”）。要做到这个，这个应用的背后网页必须记住被访问的次数，并且在每次网页被访问时增长次数。这个应用就是有状态的。</li>\n</ul>\n<h3 id=\"Rejection-invalid-transactions-拒绝无效事务\"><a href=\"#Rejection-invalid-transactions-拒绝无效事务\" class=\"headerlink\" title=\"Rejection invalid transactions (拒绝无效事务)\"></a>Rejection invalid transactions (拒绝无效事务)</h3><ul>\n<li>在之前的讨论中，我们注意到面向对象编程是一种事件驱动编程。在大多数案例中，面向对象编程包括的对象都是有状态的。比如一个“栈”在它的实例化变量中维持着它的状态，在下图中这个区域标记成“internal data 内部数据”。</li>\n<li>图【Stack object diagram】</li>\n<li>当我们实例化Stack类去创建stack对象时，stack开始为空。</li>\n<li>现在假设下列事件序列发生：<ul>\n<li>一个“push(X)”事件到达。X是添加到栈中，改变栈的状态。</li>\n<li>一个“pop()”事件到达。X从栈中移除（再次改变栈状态）并且返回。栈现在空了。</li>\n<li>另一个“pop()”事件到达。</li>\n</ul>\n</li>\n<li>现在我们遇到了一个问题。栈不能满足此需求。它不能移除并返回栈顶元素，因为栈顶没有元素了；栈是空的。</li>\n<li>这个例子阐述了重要的有状态应用的特性。一般来说，有状态应用定义了（至少隐式的）可接受“状态+事务”类型对的列表。在列表中的每一对，当应用处于指定状态时，应用可以处理指定类型的事务。但是如果到达的事务在当前的状态中不可接受，事务必须被拒绝。</li>\n<li>这有很多相似的这种例子：<ul>\n<li>一般来说，一个成年人如果他想结婚，他就可以结婚，但是如果他已经结婚了，那么就不能再结婚了（X的配偶由文化决定）。</li>\n<li>一般来说，你可以从你的银行账户存取钱，但是你不能从你的账户中取出更多的钱。</li>\n<li>一般来说，你可以兑换你的飞行常客里程以免费飞行，但是航空公司不允许你再繁忙旅行的“断电时段”兑换，比如感恩节前一天。</li>\n<li>一般来说，数据库应用可以再数据中中更新一条记录，但是它不能更新被作者应用锁定的记录。</li>\n</ul>\n</li>\n<li>应用程序由多种方法来相应无效的事务。当然最简单的就是忽略它。但是，一般来说,最好的相应方式是提出一个异常，并让被提交事务的模块处理异常。</li>\n<li>依赖于使用语言的能力，应用提出一个通用异常并伴随一条描述错误的信息，或者可以对指定的问题类型，定义指定的异常。一个栈的实例可以定义为：<ul>\n<li>“StackEmptyException” 栈空异常，当栈是空的并且受到“Pop()”请求时提出此异常。</li>\n<li>“StackOverflowException” 栈溢出异常，当栈满了，并且收到了“Push()”请求时提出此异常。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"State-Machines-状态机\"><a href=\"#State-Machines-状态机\" class=\"headerlink\" title=\"State Machines (状态机)\"></a>State Machines (状态机)</h3><ul>\n<li>在一些案例中，状态机是有效的思考具有生命周期对象（有状态的计算机应用）的方法。在它的生命周期中，有状态对象通过相应事务（事件）来在不同状态之间切换。</li>\n<li>对象的这种行为叫做“有限状态机 Finite State Machine”（FSM）或者“定向有限状态机 Directed Finite Automaton”（DFA）。描述有限状态机的典型方式是用“状态事务图 State Transition Diagram”（STD）。在STD中，圆圈代表状态，用事务走向的事件名标记的箭头代表了事务。</li>\n<li>这有个STD的例子，它代表了一个人的生活和婚姻历史（由文化规定，同一时间只能由一个配偶）。</li>\n<li>图【STD for life and marriage history of a person】</li>\n<li>在STD中，状态是：“SINGLE 单身”、“MARRIED 已婚”、“DEAD 死亡”。当一个人开始他的生活，它是单身的（开始的状态是SINGLE）。他可能还没有结婚就死亡了，或者他结婚了。他可能在结婚之后死亡，或者通过离婚或丧偶重新回到单身。DEAD是“终点状态”（没有事件事务从这里出去）。</li>\n<li>这个Person类的伪代码如下：</li>\n<li>图【Person class】</li>\n<li>在上述我们讨论的状态中，我们使用“state 状态”和“state information”状态信息指人的所有有状态信息，是对象实例化变量的完整集合。但是当讨论到STD和FSM时，我们在有限状态机中使用“state”这个词去指特定的没有关联的状态。</li>\n<li>遗憾的是，还没有标准术语来区分“state”这个单词的两种意思。Michael Jackson 使用术语“state vector 状态向量”来指第一种情况（“vector”变量列表包含一个对象的状态信息）。程序员经常使用“status”（如“status_flag”,“status_indicator”）来指第二种情况。</li>\n<li>在本文余下部分，一般上下文会指出我用的是哪种“state”。当有可能产生混淆时，我会使用“state vector”（或者“state_information”）和“status”去让事情保持清晰。</li>\n</ul>\n<h3 id=\"Coding-a-Finite-State-Machine-1-编写一个有限状态机1\"><a href=\"#Coding-a-Finite-State-Machine-1-编写一个有限状态机1\" class=\"headerlink\" title=\"Coding a Finite State Machine 1 (编写一个有限状态机1)\"></a>Coding a Finite State Machine 1 (编写一个有限状态机1)</h3><ul>\n<li>有很多不同的技术来编码实现一个有限状态机。在给出的例子中，你选择那种技术取决于你的应用类型和你所用语言的特性。正是因为这些，我会给你介绍你个典型的FSM程序实现的例子。</li>\n<li>这有个有限状态机的状态转换图，它的目的是分解文字的输入流到文字组和空白组。</li>\n<li>图【Break Input Stream STD】</li>\n<li>在接下来的几页有实现此FSM的源码。在看源码之前，我要指出几点关于它的事。</li>\n<li>首先，这是一个解析程序。它会读取文字的输入流，分解它到文字组（tokens 标志令牌），通过类型来标记“tokens 标志令牌”。解析（这是在标记化编译阶段和处理标记语言如HTML和XML完成的）是一个经典的阐述实现有限状态机的程序。</li>\n<li>第二，它使用了经典的设计模式来编码有限状态机。对于许多应用，当处理一个事务时，FSM程序必须要做如下三件事：<ul>\n<li>与离开当前状态相关的活动</li>\n<li>改变当前状态到新状态</li>\n<li>与进入新状态相关的活动</li>\n</ul>\n</li>\n<li>我在活动应该发生的地方写了注释。</li>\n<li>最后，这个程序膳食了我们在处理程序模式中期望看到的特性。输入流时事件队列。从输入流中读取一个字符是从事件队列中取出一个事件。一个时间循环检查每个字符、事件、事务去决定它是否是文字还是空白，然后分发它们到合适的处理程序。当然也会编码一个“EndOfEvents”（输入流最后）事件，在此事件到来时，将结束事件循环。</li>\n<li>如下就是使用Python编写的源码实现。</li>\n<li>图【Implements FSM】</li>\n<li>在这个非常简单的例子中，程序解析如下字符串：</li>\n<li>图【”Suzy Smith Loves    John Jones”】</li>\n<li>生成如下输出：</li>\n<li>图【Implements Output】</li>\n</ul>\n<h3 id=\"Coding-a-Finite-State-Machine-2-编写一个有限状态机2\"><a href=\"#Coding-a-Finite-State-Machine-2-编写一个有限状态机2\" class=\"headerlink\" title=\"Coding a Finite State Machine 2 (编写一个有限状态机2)\"></a>Coding a Finite State Machine 2 (编写一个有限状态机2)</h3><ul>\n<li>作为一个实际问题，一会发现你使用了如下概念：<ul>\n<li>输入一个状态state（status）</li>\n<li>保持状态信息state information（the state vector）</li>\n<li>离开一个状态state（status）</li>\n<li>拒绝当前状态下无效的事务</li>\n</ul>\n</li>\n<li>在你选择去写的多种事件驱动程序里。<ul>\n<li>在GUI程序中，窗口小工具经常需要记住它们的状态。如果一个用户点击了复选框，GUI应用需要知道复选框当前的状态（选中，未选中）为了在两种状态中切换。</li>\n<li>在线应用需要记住所有种类的状态信息。如果一个用户登录一个安全的应用，用错误的密码连续提交三次，用户有可能被锁定。</li>\n<li>在Web应用中，程序经常需要记住它们的状态。如果一个购物车应用用户提交没有登录他账单信息的订单，要将错误反馈给他，并且拒绝提交事件。</li>\n<li>在分析一个编程语言时，是否接受特殊字符（如波浪字符、问号）在原文中出现。它可能在注释或者当出现在引号中没出现在其他地方时可以接受。</li>\n</ul>\n</li>\n<li>在SAX处理XML中，事件驱动应用类型的状态问题非常明显。实际上，SAX分析器提供的了startElement”和“endElement”方法实际上是“startState 开始状态”和“endState 结束状态”。当你遇到某些类型的开始标签（如”\\<h1>“），你实际上在进入一个状态。在文档中发生在这个状态上下文中所有之后的元素直到你遇到相应的末尾标签（如“\\<h1>”）。</h1></h1></li>\n<li>这有一个用Python写的SAX程序代码片段，用来检查确保在输入中不包含“\\<br>”标签或者头标签嵌套在其他头标签里的情况。</li>\n<li>图【CustomizedHandler class】</li>\n<li>对比这个代码结构和解析文字和空格的代码。</li>\n<li>解析程序非常简单，所以一旦我们进入“handlerSpace”或“handLetter”函数中，解析程序知道他要处理事务所需的一切。这对于这个程序还不够。一旦我么进入了“startElement”或“endElement”方法，我们要进一步检查我们处理的标签种类。</li>\n<li>但是一旦我们知道我们处理事件的种类，处理就变得非常简单。从根本上来说，它包含设置和检查“status information 状态信息”（inHeadingStatus）和“state-vector 状态向量信息”（currentHeadingTag），并且基于当前状态允许或拒绝事务。</li>\n</ul>\n<h3 id=\"Way-to-remember-state-记住状态的方法\"><a href=\"#Way-to-remember-state-记住状态的方法\" class=\"headerlink\" title=\"Way to remember state (记住状态的方法)\"></a>Way to remember state (记住状态的方法)</h3><ul>\n<li>许多有状态的应用只需在程序运行时记住它们的状态即可。一些应用没有记住它们状态信息的问题，它们只需要在内存中存储即可。例如，在我们的解析程序中，我们使用了state和outstring global变量。在我们的SAX内容处理程序中，我们使用的“inHeadingStatus”和“currentHeadingTag”内容处理程序对象的实例变量。</li>\n<li>但是其他有状态的应用需要推迟执行，也就是说，它们需要在内存以外存储信息。如这个应用：<ul>\n<li>存储状态信息的责任交到一些可以续存储的媒介中，例如存储在硬盘上的一个文件或数据库。当它启动的时候，它从数据库中恢复它的状态信息，在结束之前再将状态信息存回（持久化）数据库。</li>\n</ul>\n</li>\n<li>或者这样：<ul>\n<li>委托它的调用者负担起存储状态信息的责任。开始时，它从它的调用者收到状态信息，在它结束时再返回状态信息给它的调用者。</li>\n</ul>\n</li>\n<li>Web应用程序是这种有状态应用程序的好例子，因为它们经常使用这两种例子来存储状态信息。考虑“nozama.com”这个网站，一个虚构的经典的用户和Web游览器模式的Web购物应用：<ul>\n<li>打开“nozama.com”Web页</li>\n<li>他通过反复游览“Nozama”产品分类选择产品，一个一个的将产品放到购物车中。</li>\n<li>输入他的账单和购物信息</li>\n<li>提交他的订单</li>\n</ul>\n</li>\n<li>在任何给定时间，可能同时有成百上千的用户使用购物程序。Nozama必须交替从不同购物程序阶段的不同客户的请求中取出并处理。遗憾的是，简单的Web技术为Nozama提供购物者的直接链接。</li>\n<li>Nozama和类似的应用需要一种识别与特定客户端对话的方法。如一个叫做session的对话。Nozama需要管理创建、保持和存储session信息过程的方法。</li>\n<li>这有怎么做的方法。</li>\n<li>当一个用户打开Nozama网站，Nozama创建一个临时的session对象。用户通过购物程序，Nozama添加用户给出的信息（选择的产品、账单、购物信息）到他的session对象的状态信息。最后当用户提交他的订单时session的生命周期结束。</li>\n<li>Nozama通过给每个session一个sessionID，存储session的state vector（他的状态信息）到数据库来跟踪sessions，其中sessionID时state vector的关键。</li>\n<li>一旦启动一个session，在所有网页中Nozama包括session ID将它发送给用户，通过用户以某种方式编码，并且Nozame作为每个页面请求的一部分返回。当Nozama收到一个包含session ID的请求，它使用session ID作为密钥从数据库中去恢复session的vector information。在Nozama处理完用户的请求后，它会在数据库中更新和替换state vector，并且返回一个响应给用户。</li>\n<li>图【Nozama schematic】</li>\n<li>要记住我们说的，有状态应用要记住它的状态信息，可以用存储到可持久化的媒介上，或者用调用它的调用者代理存储。Nozama使用了这两种策略。他在硬盘的数据库中存储了用户的实际状态信息。但是在这个案例中，它同样的也给了它的调用者（客户端游览器）状态信息。客户端游览器负责记录一次的状态信息：session ID。</li>\n<li>还有一种策略是Nozama通过把整个session状态发送到游览器，让游览器记住他。如果Nozama这样做了，它就不用在数据库中存储信息，它就会变得更简单。但是前后端传输的state vector信息包会变大，导致降低相应时间。</li>\n<li>代替策略确实有一个明显的优势，如果用户在完成购物前放弃购物，则在数据库中则没有孤立的session信息。对比数据库的策略，Nozama必须实现一个检测session超时放弃的通知。当一段时间（比如30分钟）之后，session的状态信息将无法访问，Nozama将考虑到将session终止，并且从数据库中删除状态信息。</li>\n</ul>\n<h2 id=\"Conlusion-结尾\"><a href=\"#Conlusion-结尾\" class=\"headerlink\" title=\"Conlusion (结尾)\"></a>Conlusion (结尾)</h2><ul>\n<li>接下来我们总结一下这篇简短的介绍事件驱动编程（处理程序模式和它的变体）和相关的编程问题的文章。</li>\n<li>正如你所看到的，理解事件驱动编程是能够完成许多软件开发任务（面向对象编程、面向对象系统分析和设计、用SAX解析器解析XML、GUI编程、Web编程、甚至是词法分析）的关键。</li>\n<li>祝你的事件驱动编程顺利。</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"事件驱动编程\"><a href=\"#事件驱动编程\" class=\"headerlink\" title=\"事件驱动编程\"></a>事件驱动编程</h1><ul>\n<li>原文：Event-Driven-Programming: Introduction, Tutorial, History</li>\n<li>作者：Stephen Ferg</li>\n<li>进度：完成所有章节的初步翻译</li>\n<li>翻译：<a href=\"https://smalbox.top\" target=\"_blank\" rel=\"noopener\">SmalBox</a></li>\n<li>原文版权：<a href=\"http://creativecommons.org/licenses/by/2.5/\" target=\"_blank\" rel=\"noopener\">Creative Commons Attribution License</a></li>\n<li>翻译版权：<a href=\"https://raw.githubusercontent.com/SmalBox/Book/master/LICENSE\" target=\"_blank\" rel=\"noopener\">Apache-2.0</a></li>\n<li>翻译项目地址：<a href=\"https://github.com/SmalBox/Book\" target=\"_blank\" rel=\"noopener\">点击查看项目</a></li>\n<li><em>注：译文无配图，图片请参考原文(<a href=\"https://github.com/SmalBox/Book/blob/EventDrivenProgramming/event_driven_programming.pdf\" target=\"_blank\" rel=\"noopener\">点击获取原文</a>)</em></li>\n</ul>\n<hr>\n\n<h1 id=\"EventDrivenProgramming-Introduction-Tutorial-History\"><a href=\"#EventDrivenProgramming-Introduction-Tutorial-History\" class=\"headerlink\" title=\"EventDrivenProgramming: Introduction, Tutorial, History\"></a>EventDrivenProgramming: Introduction, Tutorial, History</h1><ul>\n<li>《事件驱动编程:介绍，教程，历史》</li>\n</ul>\n<h2 id=\"In-The-Beginning-Transaction-Analysis-开始-事务分析\"><a href=\"#In-The-Beginning-Transaction-Analysis-开始-事务分析\" class=\"headerlink\" title=\"In The Beginning - Transaction Analysis (开始-事务分析)\"></a>In The Beginning - Transaction Analysis (开始-事务分析)</h2><ul>\n<li>我的故事开始于1970年后期。在那些日子里，经典的计算机系统是批处理系统。输入数据还是经典的在带子上的顺序文件。这些文件带子旋转，被其他程序处理,然后写入到到其他文件，文件又被其他程序处理，如此反复。计算机系统的标准模式是一个流水线。原始数据从一个门进入，然后他们被反复的处理，最后结果会从另一个门出来。</li>\n<li>这种思维模式奠定了1970年代“结构化”系统开发方式。结构化方法之父是 拉里·康斯坦丁（Larry L. Constantine）。他的父公司是IBM的系统研究所。最成功的结构化倡导者是 爱德华·尤登（Edward Yourdon） 。到这种程度以致 尤登（Yourdon）和结构化分析和设计方法 几乎成为了同义词。</li>\n<li>在1974年，起初结构化这个术语出现在IBM系统之旅的文章中,它们被G,W,L，叫做结构化设计。在1975年，Larry Constantine 的一名学生 G M，在IBM SRI 发表了一篇“通过复合设计获得可靠软件”的文章。然后在1977和1978年，几乎同时地，几个关于结构化方法的重要的书出现了。它们是“机构化设计”-Ed Yourdon，Larry Constantine，“结构化分析和系统详述”-Tom De Marco,“结构化系统分析”-Chris Gane, Trish Sarson,“结构化系统开发”-Ken Orr。也许最有影响力的是Tom De Marco 的 “结构化分析和系统详述” ，这本书在伦敦出版社发布。</li>\n</ul>\n<h3 id=\"Dataflow-Diagrams-数据流图\"><a href=\"#Dataflow-Diagrams-数据流图\" class=\"headerlink\" title=\"Dataflow Diagrams (数据流图)\"></a>Dataflow Diagrams (数据流图)</h3><ul>\n<li>结构化分析使用“数据流图”（DFDs）去展示计算机系统的逻辑结构。在DFD中,顺序文件中的记录被概念化为，通过管道 或 沿着传送带移动的数据包，成为数据流。数据包在各个一系列工作区中传递被叫做“处理”，他们被筛选、使用、增强或者改变，最后通往下一个工作区。这有一个数据流图，来自 “数据分析和系统详述” 的316页。</li>\n<li>图【transform analysis】</li>\n<li>用这种方式描述的系统被叫做 “transform analysis”</li>\n<li>D M又简短的介绍了第二种分析方式，叫做 “transaction analysis” 并且提供了这张图。</li>\n<li>图【transaction analysis】</li>\n<li>他阐述了“transform”和“transaction”分析的不同如下：<ul>\n<li>“transform analysis” 应用于那些能明确区分出 输入流、处理中心、输出流的应用。在数据流图术语中,“transform” 由线性网格表示。</li>\n<li>“transaction analysis” 应用于有着突发并行数据流特性应用的“事务中心”。</li>\n</ul>\n</li>\n<li>D M 实际上只花了很少的时间来条论“事务分析”。但是在“结构化设计”这本书里的这个主题却受到了跟多的关注。在第11章，Y和C将第一次描述事务分析归功于P。Y和C描述事务分析是“一个更灵活，SAPTAD技术的更复杂更新”。</li>\n<li>“事务分析”建议通过数据流图表示，类似于图11.1，一个“transform”分裂出一个输入流，和若干个输出子流。这就是一个事件驱动的原型图。</li>\n<li>图【11.1】</li>\n<li>他说：一个“事务”是从一些“元素的数据、控制、信号、事件、或者状态的改变”开始，然后发送到事务中心做处理。</li>\n<li>一个“事务中心”必须具备如下条件：<ul>\n<li>以原始的形式（获取和相应）获得事务</li>\n<li>分析每一个事务，确定他的类型</li>\n<li>根据事务类型分发</li>\n<li>完成每一个事务的处理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Structure-Charts-结构图\"><a href=\"#Structure-Charts-结构图\" class=\"headerlink\" title=\"Structure Charts (结构图)\"></a>Structure Charts (结构图)</h3><ul>\n<li>一个数据流图展示了一个系统必须执行的逻辑功能，但没有说明执行这些功能的程序设计。在结构化分析和设计中，一个不同的图叫做“结构图”，它用来展示程序设计。在“结构图”中，矩形代表模块（函数或子程序）。矩形按等级排列，呼叫模块在上方，被呼叫模块在下方。</li>\n<li>从事务处理数据流图 转换到的结构图如下：</li>\n<li>图【11.2】</li>\n<li>在这个图中，虚线箭头代表控制流从顶部流入事务中心。事务被“GETTRAN”函数获得。一旦事务被捕获，将被分析判断他的类型（它的事务代码）并向上传递给“事务中心”。之后，将发送给“分发”模块，它将根据事务类型分发给不同的事务处理模块。</li>\n</ul>\n<h2 id=\"The-Handlers-Design-Pattern-处理程序设计模式\"><a href=\"#The-Handlers-Design-Pattern-处理程序设计模式\" class=\"headerlink\" title=\"The Handlers Design Pattern (处理程序设计模式)\"></a>The Handlers Design Pattern (处理程序设计模式)</h2><ul>\n<li>如果Y和C的文章写在今天，他们很有可能将他们的“事务分析”的概念叫做设计模式。我将叫它们“处理程序模式”。</li>\n<li>这有一个“处理程序模式”的图.这个图是接着图11.1的事务分析原始数据流图。</li>\n<li>图【Handlers pattern】</li>\n<li>在图中可以看到：<ul>\n<li>有一个数据流叫做“事件”（Y和C叫它“事务”）</li>\n<li>有一个“分发模块”（Y和C叫它“事务中心”）</li>\n<li>还以一系列的处理程序</li>\n</ul>\n</li>\n<li>“分发模块”的工作是获取每个进来的事件，分析事件决定事件的类型，然后发送事件到可以处理对应类型事件的处理程序中。</li>\n<li>“分发模块”必须处理一连串的输入事件流，所以它的逻辑必须包括一个“事件循环”，所以它可以获取事件、分发它，然后循环回来在输入流中处理下一个事件。</li>\n<li>一些应用（例如，控制硬件的应用）可能把事件流看作是无线有效的。但是对于大多数事件处理应用，事件流是有限的，通过在流的最后用一些特殊的事件(一个文件结尾的标志，或者按ESCAPE键，或在GUI上左键点击关闭按钮)标识。在这些应用中，“分发模块”逻辑必须包含“退出”能力来在事件流末尾被发现去结束事件循环。</li>\n<li>在一些情况下，“分发模块”做出的决定可能不能恰当的处理这个事件，它们会丢弃这个事件或者引发（抛出）一个异常。GUI应用一般对类似鼠标按钮点击之类的事件感兴趣，但是对鼠标运动事件不感兴趣。所以在GUI应用中，事件没有处理程序时，通常会被抛弃。对于大多数其他类型的应用，一个不能被识别的事件在输入流中组成一个错误，一个适当的操作是是引出异常。</li>\n<li>这是经典的分发模块的伪代码，来展示一下所有特性：<ul>\n<li>事件循环</li>\n<li>“退出”操作</li>\n<li>判断事件类型，在类型的基础上选择一个恰当的处理程序。</li>\n<li>对没有相应处理程序的处置。</li>\n<li>图【分发模块 伪代码】</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"The-Headless-Handlers-Pattern-无头处理程序模式\"><a href=\"#The-Headless-Handlers-Pattern-无头处理程序模式\" class=\"headerlink\" title=\"The Headless Handlers Pattern (无头处理程序模式)\"></a>The Headless Handlers Pattern (无头处理程序模式)</h3><ul>\n<li>这里有几个处理程序模式的变形体。其中一个是“无头处理程序”模式。在这个模式中，“分发模块”要么确实，要么不是随时可见。去掉“分发模块”，剩下的全部都是事件处理程序的集合。</li>\n<li>图【Headless Handlers Pattern】</li>\n</ul>\n<h3 id=\"The-Extended-Handlers-Pattern-扩展处理程序模式\"><a href=\"#The-Extended-Handlers-Pattern-扩展处理程序模式\" class=\"headerlink\" title=\"The Extended Handlers Pattern (扩展处理程序模式)\"></a>The Extended Handlers Pattern (扩展处理程序模式)</h3><ul>\n<li>另一种变体是“扩展处理程序”模式。在这种变体中，模式包括一个“事件生成器”组件，这个生成器可以生成“分发程序”可以处理的事件流。</li>\n<li>图【Extended Handlers Pattern】</li>\n</ul>\n<h3 id=\"The-Event-Queue-事件队列\"><a href=\"#The-Event-Queue-事件队列\" class=\"headerlink\" title=\"The Event Queue (事件队列)\"></a>The Event Queue (事件队列)</h3><ul>\n<li>在一些案例中，“分发模块”和处理程序可能不能够在事件来的时候尽快的处理他们。在这些案例中，解决方案是将事件输入流存入缓冲区，在事件生成和事件分发当中将“事件队列”引入事件流。事件可以快速的添加到队列的末尾，“分发模块”也可以以最快的速度从队列的前端取出它们。</li>\n<li>GUI应用通常都有事件队列。重要的事件例如鼠标点击可能需要一些事件来处理。在处理当中，其他的事件如鼠标移动事件就要累加在缓冲区中。当缓冲区再次空闲时，它就可以立即抛弃可忽略的事件-鼠标移动事件，然后快速清空序列。</li>\n</ul>\n<h3 id=\"Some-Examples-of-the-Handlers-Pattern-处理程序-举例\"><a href=\"#Some-Examples-of-the-Handlers-Pattern-处理程序-举例\" class=\"headerlink\" title=\"Some Examples of the Handlers Pattern (处理程序-举例)\"></a>Some Examples of the Handlers Pattern (处理程序-举例)</h3><ul>\n<li>现在我们已经介绍了处理程序模式，我应该给你看一些关于这个模式的例子。这些方法和技术可能很相似，但是可能你从来没有在“事件驱动编程”的角度去思考它们。</li>\n</ul>\n<h3 id=\"Objects-对象\"><a href=\"#Objects-对象\" class=\"headerlink\" title=\"Objects (对象)\"></a>Objects (对象)</h3><ul>\n<li>在90年代，面向对象的技术方法逐渐的使七八十年代的结构化的方法失去了光芒。软件方法论者开始用新的图表标记法做实验，去阐述面向对象的概念。与此同时，“对象图”是这些流行的图之一（由GradyBooch发明）。这有一个对象图表的例子。</li>\n<li>图【object diagram of a STACK object】</li>\n<li>在这个“对象图”中，“Stack”是一个对象类型（或者叫做“类”）。“Push”、“pop”、“peek”是他的方法。想要使用“Stack”类，你需要创建stack对象，然后使用对象的方法去做一些事情。</li>\n<li>图【create and usage stack object】</li>\n<li>我喜欢“对象图”，因为它们清楚的展示了一个对象在“无头程序处理模式”中的示例。一个“对象图”，同样的也是一个基本的“无头处理程序”，除了事件是从左面来的而不是从顶部来的。举个例子，Stack类是可以处理“push”、“push”、“pop”事件的一系列事件处理程序（面向对象中叫做“方法”）的集合</li>\n<li>写到这里，如果你是一个面向对象的程序员，你应该已经知道什么是事件驱动编程了。毫不夸张地说，当你在写对象的方法的时候，你就是在写事件的处理程序。</li>\n</ul>\n<h3 id=\"System-系统\"><a href=\"#System-系统\" class=\"headerlink\" title=\"System (系统)\"></a>System (系统)</h3><ul>\n<li>正如我们所看到的，在“结构化系统分析“中，计算机系统被概念化为工厂。原始的原料流入工厂，在传送机的带子（数据流）上前向流动，穿过工作站（处理）最终结束旅程的产品被从门推出。</li>\n<li>原始原料的提供者是“源（sources）”，最终产品的消费者是“盥洗盆（sinks）”。“sources”和“sinks”是数据流的“终端（terminator）”-（它们是数据流开始和结束的地方）。</li>\n<li>“上下文关系图”用来展示系统在终端上下文中关系的状况。这有一个上下文关系图，来自De Marco 的“结构化分析和系统详述”中第59页。</li>\n<li>图【context diagram】</li>\n<li>在1984年，Stephe McMenamin 和 John Palmer 发表了 “基本系统分析（Essential Systems Analysis）”（ESA）。ESA 建立并扩展了结构分析的早期工作，但是它也介绍了计算机系统的概念模式中基本的变化。</li>\n<li>ESA 认为计算机系统不是一个工厂，是一个激励/反馈的机器。激励是在外部世界中，通过终端发送到系统的事件。系统自己概念化为一系列事件处理程序（基本活动）。当一个事件到达，系统就活动了起来，基本活动开始处理事件，然后系统再次进入睡眠状态（静默），直到下一个事件到来。</li>\n<li>基本活动反馈事件是通过在系统核心的数据存储中读写，和产生输出数据流的方式。系统的数据存储构成了“基本内存（essential memory）”。</li>\n<li>这张图展示了计算机系统的基本部分，他们是概念化的ESA。</li>\n<li>图【Characteristic shape of an event-partitioned DFD】</li>\n<li>基本上，ESA展示了一个简单的计算机系统，是一个巨大的面型对象风格对象。系统的基本活动是对象的方法，基本内存是他的内部数据。这个对象是“无头处理程序模式”的例子，它的方法扮演了处理程序的角色，所以在这里完整的计算机系统是一个“无头处理程序模式”的例子，基本活动扮演了处理程序的角色。</li>\n<li>“处理程序模式”中，最完善的系统概念化是JSD（Jackson System Development），都写在了 Michael Jackson 的“系统开发”（1983）这本书中。JSD 是好方法，以论证的方式第一次真的面向对象分析和设计方法。</li>\n<li>JSD系统的设计用SID（system implementation diagram 系统执行图）展示。这是一个典型的SID，来自“系统开发”的293页。</li>\n<li>图【SID】</li>\n<li>在图的顶部，我们看到的“分发模块”在JSD中叫做“调度程序（scheduler）”。事件流从外部系统到达；它叫做SCIN（“调度输入程序 scheduler input”）。事件被发送到CUST-1或ENQ（事件处理程序）。系统内部数据存储到数据库表中，这个表叫做“状态向量（state vector）”文件（成为SVFILE）。EREPLIES是响应中生产出的答复流，去处理询问事件。</li>\n<li>CUST-1 和 ENQ 不是函数；他们是完整对象。这意味着JSD在两个层面使用了“程序处理模式”。在上层，整个系统以完整的“处理程序模式”为出发点，调度程序作为分发模块，对象做事件处理者。第二层面向对象方式的对象，这些方法函数作为事件的处理程序，处理从调度者或者其他对象来的事件。</li>\n<li>ESA 和 JSD 标志着我们的思想从早期的结构化方法中发生巨大的转变。发生巨大转变的原因是，快速发展的数据库技术的出现。在早期的结构化分析的日子里，“数据库管理系统（DBMSs）”基本上不存在。但是，到ESA和JSD出现的时候，计算机化数据处理快速发展，从批处理系统处理顺序文件到在线系统处理数据库。首先它是链接起来的表 DBMSs （IBM 的 IMS， Cullinane的 Cullinet，和 Cincom 的 Total）。紧接着是反向列表DBMSs（adabas，模式204），接下来是关系数据库（DB2，Ingres，Oracle）。DBMS技术的进步便随着数据库设计方法学的开发。</li>\n<li>随着数据库技术的进步和其大规模的使用，大量的开发者都来使用数据库（不是访问他的软件）最为计算机系统的核心。因此，计算机系统的新模式 -作为一系列事件处理程序周边并提供接口给作为系统核心的数据库- 在那时候是非常棒的产品。</li>\n</ul>\n<h3 id=\"Client-Server-Architecture-客户端-服务器架构\"><a href=\"#Client-Server-Architecture-客户端-服务器架构\" class=\"headerlink\" title=\"Client-Server Architecture (客户端-服务器架构)\"></a>Client-Server Architecture (客户端-服务器架构)</h3><ul>\n<li>在CS（Client-Server）架构中架构中有一个“处理程序模式”的熟悉示例。“server”是硬件或者软件的管线，它给“客户端”提供了服务。服务端的工作是等待来自客户端的“服务请求”，根据提供的请求服务反馈“服务请求”，然后等待更多的请求。服务端的例子包括：打印服务，文件服务，窗口服务，数据库服务，应用服务和web服务。如果你经常在网上冲浪，你是在和服务器互动，每当你访问一个新的地址，你的web游览器发送一个请求到web服务器，你请求的web页会反馈你的请求。</li>\n<li>Wesey Chun 在“Python 编程核心”的16章中提供了一个简短、清晰的解释来描述“客户端-服务器“架构的基础。（我想稍微的修改了一下文本来提高技术的连贯性）。想象一下，Chun 说：<ul>\n<li>一个既不吃也不睡，也不休息的空闲柜员，在一个从来看不到尾的流水线中服务一个又一个顾客。流水线可能会很长或者有时会空闲，但在任何时候，顾客都有可能会出现。当然，这些柜员是多年前幻想出来的，但是现在的自动柜员机（ATMs）是很接近这个模型的。</li>\n<li>当然，这些柜员是在无限运行的服务器。每个客户端都要发送一个请求服务器的“服务请求”。客户端的请求到达服务器，并以先来先服务的方式处理请求。一次交互完成，客户就走了，服务端要么服务下一个客户，要么等待直到下一个随之而来的客户。</li>\n</ul>\n</li>\n<li>这有一个案例，描述了“处理程序模式”这个术语。</li>\n<li>图【client-serer Handlers pattern】</li>\n<li>每个银行顾客代表了一个从客户端发送来的服务请求（事件，事务）。</li>\n<li>客户排队或者等候服务。服务端和不知疲劳的柜员很相似，因为它们都是事件处理程序的集合，都能处理不同的事件请求。并且银行柜员的“无限循环”也就是“分发模块”的事件循环。</li>\n</ul>\n<h3 id=\"Messaging-Systems-消息系统\"><a href=\"#Messaging-Systems-消息系统\" class=\"headerlink\" title=\"Messaging Systems (消息系统)\"></a>Messaging Systems (消息系统)</h3><ul>\n<li>“消息系统”代表了“程序处理模式”的极端版本。“消息系统”的目的是，在发送者和接收者在不同的物理位置或者运行在不同平台上的情况下，从事件的生成者（发送者）获取事件（消息）并处理（接收者）消息。</li>\n<li>在“消息系统”中，消息通常发送给特定的接收者，所以分发函数（决定接收者应该接收什么消息）是很普通的函数。一个熟悉的“消息系统”的例子是邮局。一个发送者发送一个消息（信件或者包裹）到邮局（“消息系统”）。邮局在消息中读取收信者的地址，并且传送信息给收信者。</li>\n<li>图【Messaging System】</li>\n<li>E-mail “消息系统”本质上和邮局的功能差不多。唯一的不同是E-mail的消息是电子编码而不是物理编码。</li>\n<li>可能大多数精密的消息系统是企业的消息系统，使用“面向消息的中间件”或者MOM。在MOM系统中，发送者和接收者是计算机应用，而不是人。MOM系统允许计算机应用在物理分离或者运行在不同的软硬件平台下互相通信。例如，一个大公司的办公区和服务器在地理位置上分散。MON软件允许在公司的LA处的管理入口系统以电子的形式发送给在Chicago服务器上的应用一个指令结束，也可以在纽约服务器上的程序管理报道，全都不需要人干预。</li>\n<li>再加上，对于这种点对点的通讯模式，MOM产品也支持发布/订阅模式。在发布/订阅模式中，接收者成为了通过主题订阅的订阅者，发送者要发送消息到主题中，而不是个人订阅者）。当主题收到消息，这个主题会将消息发送给所有订阅它的接收者。</li>\n<li>图【publish/subscribe model】</li>\n<li>在MOM系统中，电子通信问题（队列问题，发布/订阅模式的执行问题）使系统的处理程序方面变得简单。然而，这么做的目的使帮助理解MOM系统，作为一个极端简单且专用的处理程序模式的例子。</li>\n</ul>\n<h2 id=\"Frameworks-框架\"><a href=\"#Frameworks-框架\" class=\"headerlink\" title=\"Frameworks (框架)\"></a>Frameworks (框架)</h2><h3 id=\"Object-Oriented-Event-Driven-Programming-面向对象事件驱动编程\"><a href=\"#Object-Oriented-Event-Driven-Programming-面向对象事件驱动编程\" class=\"headerlink\" title=\"Object-Oriented Event-Driven Programming (面向对象事件驱动编程)\"></a>Object-Oriented Event-Driven Programming (面向对象事件驱动编程)</h3><ul>\n<li>现在让我们来看一个全景 - “程序处理”模式在现代计算机的不同方面是怎么体现的。然我们在代码层面看“程序处理”模式是怎样工作的。</li>\n<li>考虑到与客户打交道的业务。业主自然想有一个信息系统来存储、恢复、更新他顾客信息的账户。他想要的系统可以处理各种事件：需要添加一个新的客户账户，可以修改账户名、关闭账户，诸如此类。所以系统必须有处理各种类型事件的事件处理程序。</li>\n<li>图【business information system】</li>\n<li>在面向对象编程出现之前，这些事件处理程序作为子程序来执行。这些代码在分发模块的事件循环中，像下面这样：</li>\n<li>图【dispatcher pseudo-code】</li>\n<li>子程序的类似这样：</li>\n<li>图【subroutines pseudo-code】</li>\n<li>现在，使用面向对象技术，事件处理程序作为对象的方法执行。这些代码在分发模块的事件循环中，像下面这样：</li>\n<li>图【dispatcher OO pseudo-code】</li>\n<li>“账户”类和他的方法（事件处理函数），像下面这样：</li>\n<li>图【account class methods】</li>\n<li>使用面向对象技术这种方式没有很激动。基本上来说，我们只是用对象取代了数据库记录；换句话说，数据处理的过程没什么变化。</li>\n<li>但是它变得更有趣……</li>\n</ul>\n<h3 id=\"Frameworks-框架-1\"><a href=\"#Frameworks-框架-1\" class=\"headerlink\" title=\"Frameworks (框架)\"></a>Frameworks (框架)</h3><ul>\n<li>使用面向对象技术可以相对容易的开发普遍的、可复用的类。这是面向对象技术的一个优势。</li>\n<li>举个例子，假设有一个商业的，多用途的业务类产品-“通用业务”。通用业务是一个软件框架，可以直到怎样展示多样的一般化商业功能（打开顾客账号，关闭顾客账号，诸如此类）。显然，因为所有的业务不同，通用业务允许可以根据业务特定的需求定制框架。</li>\n<li>假设接下来，Bob是一个小的业务员，他买了一个通用业务软件。在他使用软件之前，Bob需要根据他的需求定制软件。我们能想到Bob有很多定制化的事情要做：他的名字、他卖的东西的名字、它允许使用哪种信用卡，诸如此类。但是经过讨论，让我们看看Bob最急迫的需求，他想定制通用业务来使用MySQL存储账号信息。</li>\n<li>通用业务是已经写好的。他不能预测到企业将使用哪个DBMS。这意味着通用业务（就算知道怎样打开和关闭用户账号）不知道怎样持久化数据库的账户数据。当然，他也不可能知道企业用什么DBMS（Oracle， Sybase， DB2， MySQL，Postgres），通用业务不知道在账户类的“persist()”方法中该写什么代码。</li>\n<li>这意味着Bob必须自己在他的“persist()”方法中写代码。</li>\n<li>也就是说，通用业务有个问题，它怎么确保像Bob这样的用户会给“persist()”方法写代码呢？</li>\n<li>通用业务给出的解决方法不是提供一个全功能的账户类，而是提供半成品类（仅实现全功能账户类的某些方法）。实现的这部分，我们叫它通用账号类。通用账号类提供一些方法的完整实现，并且给像Bob这样的业务员预留了“插入点”，Bob必须添加他的业务代码。</li>\n<li>“插入点”是代码中的位置，在软件框架中期望事件处理程序插入的地方。事件处理程序本身叫做“插件（plug-ins）”</li>\n<li>包含“插入点”的半成品类的技术学名叫做“抽象类”。不同语言提供不同的方式定义插入点。例如，java提供了关键字“abstract”和叫做“abstract methods”的插入点。</li>\n<li>抽象方法不是真的方法。而是方法的占位符；一个可以插入具体方法的地方。包含抽象方法的Java类叫做抽象类。抽象类不能实例化。使用抽象类的唯一方法是创建一个子类开扩展它，然后在子类中定义具体方法（实现抽象类中每一个抽象方法）。Java强制执行此要求。Java不能编译通过企图实例化抽象类的程序。</li>\n<li>这意味着，Bob使用通用业务的通用账号类的方法是他自己创建一个具体的类来扩展它，并且实现抽象方法。如果通用账号类如下：</li>\n<li>图【an abstract lass GenericAccount】</li>\n<li>Bob的账号类如下：</li>\n<li>图【extends GenericAccount】</li>\n<li>Python,一个动态语言，以不同的方式支持“插入点”和抽象类。在Python中，实现一个“插入点”最简单（其他实现抽象方法的方式在附录A中）的方法是定义一个什么都不做的方法，但是提出异常（raise exception）。如果方法没有完全实现，并且有程序调用它，那么就会触发运行时异常。这有一个python写的抽象方法的例子：</li>\n<li>图【python abstract method】</li>\n<li>一条软件的通用术语是这样的工作方式（定义“插入点”，然后需要插件补充）是“框架”。如果你Google搜索术语“框架”以你会获得这样的一些定义。每个定义都包含框架的一部分。一个框架是：<ul>\n<li>用于支撑或者封闭其他的一些东西的骨架结构。</li>\n<li>一个广泛的概述、大纲或者框架，可想向其中添加细节。</li>\n<li>一个可扩展的软件环境，可以根据特定需求定制。</li>\n<li>一系列类，为一些应用的问题提供通用的解决方案。一个框架通常精炼以通过专业化或其他类或类型解决特定问题。</li>\n<li>一个组件，它允许通过写插件模块（框架扩展）的方式扩展其功能性。扩展的开发者通过从框架中定义的类接口写自己的类。</li>\n<li>软件主体设计成高复用模式，加上特定功能的插件以适应特定的系统的功能性需求。当安装了插件，系统将围绕插件表现出相应的行为。</li>\n</ul>\n</li>\n<li>这个框架模式的基本概念是“处理程序模式”。“框架扩展”或者“插件”是“事件处理”模块。</li>\n<li>图【framework and entensions(handlers)】</li>\n</ul>\n<h3 id=\"SAX-an-example-of-a-framework-框架举例-SAX\"><a href=\"#SAX-an-example-of-a-framework-框架举例-SAX\" class=\"headerlink\" title=\"SAX - an example of a framework (框架举例-SAX)\"></a>SAX - an example of a framework (框架举例-SAX)</h3><ul>\n<li>框架有各种形状尺寸，从大到小都有。开看一下真实的框架是怎么使用的，然我们来看一个小框架：SAX（实际上，SAX不是一个框架。他可以在框架中实现的API。但是为了保持事情简单，我们就当它是个框架）。</li>\n<li>XML越来越流行。只有一个结果，就是很多开发者第一时间在SAX（一个简单的XML API）框架中遇到了事件驱动编程。SAX是事件驱动的XML语法分析器。它的工作是打开（解析）XML成可理解的片段。例如，SAX分析器可以分析以下字符串：</li>\n<li>图【XML string】</li>\n<li>解析成如下三个片段：</li>\n<li>图【three pieces】</li>\n<li>使用SAX解析器，你给他一大块XML字符串。它解析XML文本成不同的片段，然后调用适当的预先确定的插件（事件处理程序）去处理片段。</li>\n<li>SAX为解析各种XML的特征，诸如打开和关闭标签（startElement，endElement），标签中间的文本，注释，处理指令等等，制定了预定义的插入点。</li>\n<li>SAX框架提供了“解析器（Parser）”类和一个抽象类“内容处理器（ContentHandler）”。使用它，首先要创建ContentHandler的子类，并且写一个具体的方法（事件处理模块）去覆写抽象方法。这有个用python写的简单例子。它在控制台打印XML的标签名和标签中的数据。（完整的python SAX例子可以在附件B）。</li>\n<li>图【over-ride abstract methods】</li>\n<li>你扩展“内容处理程序”类和指定事件处理程序：<ul>\n<li>使用SAX的 make_parser 工厂函数解析器对象。</li>\n<li>实例化“CustomHandler”类创建一个“myContentHandler”对象</li>\n<li>告诉解析器对象使用“myContentHandler”对象处理XML内容</li>\n<li>将XML文本传给解析器，让事件处理模块去工作</li>\n</ul>\n</li>\n<li>这有用Pyhton怎样完成的过程：</li>\n<li>图【python parse XML in file】</li>\n</ul>\n<h3 id=\"Why-programming-with-a-framwork-is-hard-为什么用框架编程很难\"><a href=\"#Why-programming-with-a-framwork-is-hard-为什么用框架编程很难\" class=\"headerlink\" title=\"Why programming with a framwork is hard (为什么用框架编程很难)\"></a>Why programming with a framwork is hard (为什么用框架编程很难)</h3><ul>\n<li>到处理只由输入XML文本给解析器（没有更多了）构成的程序的最后一步了。对于一个面向过程背景的程序员，对事件驱动编程会很困惑。在面向过程编程中，控制的主要流程在主程序之内。附属程序或者模块仅仅是公用程序或者帮助调用展示低等级的任务。主程序的控制流通常很长并且复杂，它的复杂让应用有特定的逻辑结构。程序具有形状，并程序员可以看到该形状。</li>\n<li>但是当面向过程的程序员开始使用框架编程，他失去了所有的控制权。没有了清晰的控制流（主程序除了开始了框架的事件循环什么也没做）。并且一旦事件循环开始了，隐藏在框架中的代码就驱动开始动作。该程序剩余的部分仅仅是帮助程序模块（事件处理程序）的集合。总之，程序结构看起来被彻底搞砸了。（框架和公共库是不同的。当使用公共库时，程序员可以完全控制程序流程，当他们需要公共库时调用它们，主动权在程序员。但是在框架中，是在框架需要时，框架负责调用程序员写的事件处理程序模块。主动权在框架。这是谁负责的问题。）</li>\n<li>所以面向过程的程序员经常发现，在它们第一次遇到事件驱动和框架驱动编程时觉得完全不能理解！经验和熟悉会逐步减少这种感觉，这是毫无疑问的（从面向过程编程转移到事件驱动编程时一个很大的心里范式的转变）。这就是Robin Dunn 和 Dafydd Rees 在文章开始时描述的范式转变。</li>\n</ul>\n<h2 id=\"GUI-programming-GUI编程\"><a href=\"#GUI-programming-GUI编程\" class=\"headerlink\" title=\"GUI programming (GUI编程)\"></a>GUI programming (GUI编程)</h2><h3 id=\"Why-GUI-programming-is-hard-为什么GUI编程很难\"><a href=\"#Why-GUI-programming-is-hard-为什么GUI编程很难\" class=\"headerlink\" title=\"Why GUI programming is hard (为什么GUI编程很难)\"></a>Why GUI programming is hard (为什么GUI编程很难)</h3><ul>\n<li>现在我们看到了框架时如何工作的，来让我们看一下最常用的框架和事件驱动编程：GUIs（图形用户界面 graphical user interfaces）</li>\n<li>GUI编程时困难的，们个人都这么认为。</li>\n<li>首先，只需的指定GUI的外观就需要大量工作。每个窗口小部件（每个按钮、标签、菜单、输入框、列表框等等）都必须告诉它应该长什么样（形状、大小、前景色、背景色、边框样式、字体等等），他应该能确定他自己的位置，比如怎样在GUI大小改变时做出适配，怎样适应整个GUI的层次结构。仅仅是指出GUI怎么展现就有大量的工作。（这就是为什么框架中会有IDEs和屏幕画家。它们的工作就是减轻GUI编程的负担）</li>\n<li>第二（与本文主题最相关），GUI编程很难是因为在GUI中有各种事件要处理。几乎每个GUI中的窗口小部件（每个按钮、多选框、单选框、数据输入区域、列表框（包括列表中每个项目）、文本框（包括水平和垂直滑块）、菜单栏、菜单栏图表、下拉菜单、下拉菜单中的每一项 等等很多）。几乎每个都是事件生成器，都能生成各种类型的事件。这还没完，硬件输入设备也是事件生成器。鼠标可以生成左键点击、右键点击、左键双击、右键双击、按钮按下事件（为了初始化拖拽操作）、鼠标移动事件、按钮抬起事件（为了结束拖拽操作）等一些其他事件。键盘上每个字母、数字、可敲击的按键和功能按键（包括单独和与SHIFT、ALT、CONTROL组合的按键）都可以生成事件。有大量的事件被送入“分发”模块的事件循环，GUI程序员必须为每个GUI用户可能生成的事件写好事件处理程序。</li>\n<li>第三，事实上每个GUI工具包都以框架的形式提供给程序员。GUI框架（像SAX框架）的目的是减轻GUI程序员的负担。举个例子，GUI框架提供事件循环和事件队列来缓解程序员的工作。但是，正如我们看到的SAX，使用框架就意味着大块的程序控制流被隐藏在框架的封装机器当中，并且对与GUI程序员不可见。这意味着GUI程序员必须掌握范式的转变，转移到事件驱动编程。</li>\n<li>这有很多事要处理。这还不是全部，这又“观察者”模式需要掌握……</li>\n</ul>\n<h3 id=\"The-Observer-Pattern-观察者模式\"><a href=\"#The-Observer-Pattern-观察者模式\" class=\"headerlink\" title=\"The Observer Pattern (观察者模式)\"></a>The Observer Pattern (观察者模式)</h3><ul>\n<li>观察者模式在GUI框架的事件驱动编程中使用的很广泛。所以我们用迂回的方式来解释观察者模式。等到这个话题结束，我们将返回到GUI编程上面来，并给出观察者模式是怎样在GUI编程中使用的。</li>\n<li>第一次命名和描述观察者模式是在有名的“Gang of Four”的书“设计模式”中（出自 Gamma，Helm， Johonson， Vlissides （Addison-Wesley， 1995））。 观察者模式的基本想法Dafydd Rees引用了导言中的原理。这个原理是“好莱坞原理”：“不要来找我，我会叫你”。当然这个名字来自于演戏或者电影的演员试镜中。导演（电影中掉选角色的人），不想受到想演他的戏还没得到角色的演员找他的困扰，所以他告诉大家，“不要来找我们，我会回来找你”。</li>\n<li>好莱坞原理更长的版本是：<ul>\n<li>“不要来找我们，给我们你的电话，当我们想给你一份工作的时候我们会找你”。</li>\n</ul>\n</li>\n<li>这就是观察者模式的本质。</li>\n<li>在观察者模式中，有一个主体和多个观察者实体。在试演场景中，导言就是主体，演员就是观察者。当事件发生（导演对他们感兴趣）的时候观察者想要主体通知它们，所以它们在主体那里注册（留下能找到他们的方式说明）。当感兴趣的事情（比如选好了演员）发生时，主体就会通知它们。为了完成这项工作，主体要保存一个列表，列表中记录了所有注册观察者的名字和地址。当有趣的事情发生时，他会通过他的观察者列表去通知在这类事件中注册此类事件的哪个观察者。</li>\n<li>观察者模式也叫做“发布/订阅”模式。回想一下订阅报纸的例子。在“发布/订阅”模式中，主体就是信息或出版物的发布者。观察者就是出版物的订阅者。注册的过程叫做订阅，通知的过程叫做发刊。“发布/订阅”是个合适的名字，适用于长时间内重复发生通知/发布的情况，相同的通知发送给多个订阅者，并且订阅者可以取消订阅。</li>\n<li>观察者模式是事件处理模式中的特殊例子，原因是我觉得更应该叫做订阅程序处理模式。</li>\n<li>下一页使用python实现的观察者模式。在这个例子中，还继续使用好莱坞的主题，观察者是演员。主体是一个天才代理人叫做HotShots。演员在天才代理人那里注册，当有一个演员角色的试镜，代理人会通知演员。自从代理人不断地给演员发通知，这个例子就有了发布/订阅模式的味道。</li>\n<li>（如果你是Java程序员，请不要担心，事实上我们是想减少定义CastingCall和Observer类。这在像python这种动态语言中是可能的，现在这里是为了保持代码简短。在Java中，你需要声明类和它们的实例变量的细节）。</li>\n<li>图【Python showing Observer pattern】</li>\n<li>正如你在代码中看到的那样，天才代理人（主体）是它自己的事件处理程序。具体的说，他的“notify”方法是“CastingCall”事件的事件处理程序。</li>\n<li>天才代理人通过发送“CastingCall”到它自己的“notifyActors”方法来处理“CastingCall”。“notifyActors”方法通过通过代理人的订阅人/观察者/演员列表找到相应人选并且发送通知给合适的订阅者。</li>\n<li>在真实的应用中，通知的过程将包括与每个演员（事件处理程序）联系，演员会通过选角的方式来回应。然而，在这个简单的例子中，通知的过程只包含了打印一个信息来说明这个演员被通知了。</li>\n<li>如果你运行这个程序，会得到如下输出：</li>\n<li>图【Python showing Observer pattern Output】</li>\n</ul>\n<h3 id=\"Event-Objects-事件对象\"><a href=\"#Event-Objects-事件对象\" class=\"headerlink\" title=\"Event Objects (事件对象)\"></a>Event Objects (事件对象)</h3><ul>\n<li>这个程序有个功能，你应该特别注意。它使用了CastingCall对象的时候带着参数（实例化变量）“source”和“role”。在这里，CastingCall对象是事件对象（控制事件的对象）。</li>\n<li>事件对象是事件驱动编程中非常好的工具。在面向对象的编程语言中，事件或者事务都是极端受限的。在一些案例中，如果你想发送一个事件到以事件处理器中，你发送的所有都是一个包含事务代码的字符串。但是面向对象技术通过允许我们创建和忽略事件对象完全的改变了它。事件对象的本质是将我们需要的时间信息打包起来。</li>\n<li>一个事件对象当然也可以携带触发它事件种类的名字。但是，依赖与应用，它可以携带更多信息。在这个HotShots天才代理的案例中，事件对象包含选角色的“source”和role信息。</li>\n<li>在其他应用中，我们可能想放入大量完整的信息到我们的事件对象中。考虑一下著名的Model-View-Controller（MVC）模式。观察者模式就是MVC的核心。在MVC中，Model是一个管理数据和一些应用域的对象（它是观察者模式中的主体）。Views在Model中作为观察者注册。当Controller改变了Model，Model就会通知订阅它的观察者（Views）这个（Model）改变了。</li>\n<li>最简单的MVC版本被叫做“pull”（拉取）版本。在这个版本中，事件对象（当Model变化时，Model向Views发送的通知）几乎不包含什么信息。Model的描述没有改变，他只是通知Views发生了某种变化。当Views收到了这样的通知，它们必须从Model拉取信息。这样，它们必须询问Model当前状态的信息，并且从这些信息中刷新它们自己的状态。</li>\n<li>大多数复杂的MVC版本叫做“push”（推送）版本。在这个版本中，Model 推送变化信息给Views。事件对象发送给Views，对象包含了大量复杂的信息（Model产生的一个完整详尽的变化描述）。当Views收到了这些信息，它就拥有了所有信息，他会根据这些信息更改他自己。</li>\n<li>MVC的“push”和“pull”版本的根本区别简单来说就是放入事件对象包中的信息总数不同。</li>\n</ul>\n<h3 id=\"The-Registered-Handlers-pattern-in-GUI-applications-GUI应用程序中的“注册处理程序”模式\"><a href=\"#The-Registered-Handlers-pattern-in-GUI-applications-GUI应用程序中的“注册处理程序”模式\" class=\"headerlink\" title=\"The Registered Handlers pattern in GUI applications (GUI应用程序中的“注册处理程序”模式)\"></a>The Registered Handlers pattern in GUI applications (GUI应用程序中的“注册处理程序”模式)</h3><ul>\n<li>现在你已经熟悉了基本的 观察者/注册 处理程序模式，来让我们看看这个模式在GUI编程中是如何使用的。</li>\n<li>这有另一个程序的代码。在结构上，这段代码和Hotshots天才代理的代码很像，但是名字用了处理程序模式的专用术语，事件是GUI事件。</li>\n<li>在这个例子中，“主体”是分发模块（工作在GUI中的事件循环）。</li>\n<li>为了保持代码简短，程序只包含观察者（“demoHandler”函数是双击鼠标左键的事件处理函数）。</li>\n<li>展示这个处理程序的动作，程序生成一个模仿鼠标左键双击的事件（LeftMouseDoubleClick 事件）。</li>\n<li>图【Python showing Registered Handlers pattern】</li>\n<li>如果你运行这个代码，会得到如下输出：<ul>\n<li>图【Handling LeftMouseDoubleClick from mouse】</li>\n</ul>\n</li>\n<li>在如下语句中：<ul>\n<li>图【demoDispatcher.registerObserver( demoHandler, MOUSE_LEFT_DOUBLE)】</li>\n</ul>\n</li>\n<li>和这句：<ul>\n<li>图【observer.eventHandler = argEventHandler】</li>\n</ul>\n</li>\n<li>程序在传递“demoHandler”函数对象的引用。它这是将函数作为“全功能对象”（支持所有操作，基本的包括：作为参数传递、从函数返回、赋值给其他变量）。这不是所有的编程语言都支持的，也就是意味着，在不同的编程语言中，实现观察者/注册处理程序模式的方式会很不一样。</li>\n</ul>\n<h3 id=\"Registering-Event-Handlers-in-Python-“Binding”-Pyhton中的注册事件处理程序-“绑定”\"><a href=\"#Registering-Event-Handlers-in-Python-“Binding”-Pyhton中的注册事件处理程序-“绑定”\" class=\"headerlink\" title=\"Registering Event-Handlers in Python - “Binding” (Pyhton中的注册事件处理程序-“绑定”)\"></a>Registering Event-Handlers in Python - “Binding” (Pyhton中的注册事件处理程序-“绑定”)</h3><ul>\n<li>这些是“注册处理程序”模式后的基本思想。现在让我们看一下在Python和Java的GUI应用中“注册处理程序”模式是什么样的。</li>\n<li>开源动态语言如：Python、Perl 和 Ryby 通常提供多样的开源GUI框架接口开支持GUI编程。在Python中，也提供了一些这样的接口。最流行的是tkinter（向Tcl/Tk提供的接口）和wxPython（向wxWidgets提供的接口）。</li>\n<li>使用这些接口的基本概念是非常相似的。在接下来的讨论中，我会用Python和tkinter的例子，来阐述在GUI编程中“注册处理程序”模式的样子。</li>\n<li>在Python和tkinter中，所有的GUI事件都术语一个单独的类：“event”。事件处理程序带着GUI窗口小部件（按钮之类的）注册到程序中，为了处理特定类型的事件，比如鼠标点击，按键按下。在PYthon中，注册一个事件处理程序的过程叫做“binding”（）绑定。</li>\n<li>这有个简单的例子。假设我们的程序已经有了一个事件处理程序（一个函数或者方法）叫做“OKButtonEventHandler”。它的工作是处理发生在GUI中的“OK”按钮上的事件。</li>\n<li>注意，在Python中没有特别或者神奇的事情发生，Python中没有叫做“OkButtonEventHandler”的程序（只要我们想，我们可以将这个程序的名字叫做“Floyd”或者“Foobar”都可以）。我们将要看到是Python和Java中唯一不同的地方。</li>\n<li>接下来的代码片段创建了在观察者模式中的“subject 主体”窗口小部件。这个主体是一个GUI窗口小部件（一个按钮），它可以展示文本“OK”。这个OK按钮对象是一个Tkiner.Button类的实例对象。</li>\n<li>图【OkButton = Tkinter.Button(parent, text=”Ok”)】</li>\n<li>在调用Button类的构造函数中，“parent”参数链接了按钮对象到其所有者的GUI对象上（可能是框架或者窗口）。</li>\n<li>Tkinter小部件提供了一个叫做“bind 绑定”的方法来将事件绑定到窗口小部件上。更精确的说，“bind”方法提供了一种绑定或者说结合三个不同的事情：<ul>\n<li>一个事件类型（例如，鼠标左键点击，或者在键盘按下回车键）。</li>\n<li>一个窗口小部件（例如，在GUI上一个特定的按钮窗口小部件）。</li>\n</ul>\n</li>\n<li>例如，我们想在窗口的“关闭”按钮上绑定一个鼠标左键单击的函数或者方法：“closeProgram”。想要的效果是，当用户鼠标点击“关闭”按钮时，调用“closeProgram”关闭窗口。</li>\n<li>这有一个代码片段，绑定了一个OKButtonEventHandler程序和键盘事件（“\\<return>”）的组合到OKButton窗口小部件：</return></li>\n<li>图【OkButton.bind(“\\<return>“, OkButtonEventHandler)】</return></li>\n<li>该语句将作为观察者的OkButton窗口小部件和OkButtonEventHander函数注册到键盘事件“\\<return>”中（当Ok按钮对象获得键盘焦点时发生的事件）。</return></li>\n<li>这有另一段代码片段（可能就在同一个程序中发生，就在上一个代码之后）。它绑定了OkButtonEventHandler程序和鼠标左键点击事件到Ok按钮窗口小部件：</li>\n<li>图【OkButton.bind(“\\<button-1>“, OkButtonEventHandler)】</button-1></li>\n<li>当这两个事件中的任何一个发生了，事件将事件对象作为参数发送给OkButtonEventHandler函数。OkButtonEventHandler函数可以（如果他想）询问事件对象，并且决定是否触发一个按键按下或者鼠标点击事件。</li>\n</ul>\n<h3 id=\"Registering-Event-Handlers-in-Java-“listeners”-Java中的注册事件处理程序-“监听”\"><a href=\"#Registering-Event-Handlers-in-Java-“listeners”-Java中的注册事件处理程序-“监听”\" class=\"headerlink\" title=\"Registering Event-Handlers in Java - “listeners” (Java中的注册事件处理程序-“监听”)\"></a>Registering Event-Handlers in Java - “listeners” (Java中的注册事件处理程序-“监听”)</h3><ul>\n<li>Java也支持GUI事件处理程序注册技术，但是它的方式和Python的有些不一样。</li>\n<li>Java提供了多种GUI编程的选择（AWT和Swing）。这允许程序员可以用两种方式创建GUI的视觉层，并且监听GUI事件。</li>\n<li>对于GUI的事件处理方面，java.awt.event包提供了许多不同的事件对象类型：<ul>\n<li>ActionEvent        InvocationEvent</li>\n<li>AdjustmentEvent    ItemEvent</li>\n<li>ComponentEvent     KeyEvent</li>\n<li>ContainerEvent     MouseEvent</li>\n<li>FocusEvent         MouseWheelEvent</li>\n<li>InputEvent         PaintEvent</li>\n<li>InputMethodEvent   TextEvent</li>\n</ul>\n</li>\n<li>这些事件的类型每个都包含适合它类型的变量和方法。例如，“MouseEvent”对象包含鼠标事件的变量个方法，“KeyEvent”对象包含键盘事件的变量个方法。举个例子：<ul>\n<li>“MouseEvent.getButton()”传递了鼠标按钮引发的事件。</li>\n<li>“MouseEvent.getClickCount()”传递了触发鼠标点击的数量的事件</li>\n<li>“MouseEvent.getPoint()”告诉在GUI组件中鼠标光标位置的x，y坐标。</li>\n<li>“KeyEvent.getKeyChar()”告诉了键盘按下了哪个按键。</li>\n</ul>\n</li>\n<li>java.awt.event包也提供了通用了事件监听接口和专门监听接口集合来扩展它。专门监听接口如：<ul>\n<li>ActionListener       MouseListener</li>\n<li>ContainerListener    MouseMotionListener</li>\n<li>FocusListener        MouseWheelListener</li>\n<li>InputMethodListener  TextListener</li>\n<li>ItemListener         WindowFocusListener</li>\n<li>KeyListener          WindowListener</li>\n</ul>\n</li>\n<li>这些专门的监听接口围绕着不同的事件类型建立。这些处理相同类型的事件对象（一个监听接口是方法（事件处理程序）的集合）。例如，在鼠标监听接口中的方法处理鼠标事件，“KeyListener”接口的方法处理“KeyEvent”事件，诸如此类。</li>\n<li>在接口中，事件处理程序具有描述性的硬编码名称。例如，“MouseListener”接口提供五个事件处理程序方法：<ul>\n<li>mouseClicked(MouseEvent e)</li>\n<li>mouseEntered(MouseEvent e)</li>\n<li>mouseExited(MouseEvent e)</li>\n<li>mousePressed(MouseEvent e)</li>\n<li>mouseReleased(MouseEvent e)</li>\n</ul>\n</li>\n<li>GUI由多个GUI组件（窗口小部件）组成，例如面板、列表、按钮等。当GUI程序运行起来，窗口小部件是GUI事件（鼠标点击、按键等）的来源。</li>\n<li>就观察者而言，窗口小部件是模式的“主体”。因此，每个窗口小部件必须提供一些让观察者注册的方法。在Java中，这通过每个Java的GUI类（JPanel、Button、JList等）提供注册观察者对象的方法的方式完成。JPanel提供了一个“addMouseListener()”方法来注册鼠标事件的观察者；JButton提供“addActionListener()；诸如此类。</li>\n<li>建立GUI程序，一个Java程序必须做如下任务：<ul>\n<li>创建和定位GUI和窗口小部件的视觉化组件。</li>\n<li>创建一个或多个监听对象（在适合的监听接口中，对象实现了所有的事件处理程序的方法）。</li>\n<li>使用窗口小部件的“add[xxx]Listener()”来注册监听对象和适合的主体窗口小部件。</li>\n</ul>\n</li>\n<li>当GUI事件（例如鼠标点击事件）在主体窗口小部件发生时，在注册监听对象中，窗口小部件调用“mouseClicked()”事件处理程序方法，并将鼠标点击事件传递给它。</li>\n<li>这有个基于Sun公司教程的代码示例“怎样写一个鼠标监听”：</li>\n<li>图【How to Write a Mouse Listener】</li>\n<li>在代码中，“inputArea”对象是事件生成器。“mouseClicked()”方法是事件处理程序。它也是注册处理程序/观察者模式的例子。在观察者模式中“inputArea”是主体，如下这行：</li>\n<li>图【inputArea.addMouseListener(this)】</li>\n<li>在“inputArea”中注册的“this”（DemoGUI）是观察者。</li>\n<li>有趣的是，则个例子展示了Java中是怎么样完成多继承的。在这个例子中，DemoGUI类是GUI窗口小部件也是监听者。它是一个从JPanel继承的JPanel，所以对于inputArea窗口小部件来说它是GUI容器对象。并且他还是监听者（它实现了“MouseListener”接口中的方法（如“MouseClicked”））。</li>\n<li>注意在Java中，事件处理程序方法通过listener接口实现方法的定义，所以名字（如“mouseClick”）是由接口来决定的，所以在起名字的问题上程序员没有选择。Python中的容器，我们可以看到，程序员可以以他们认为合适的任何方式给事件处理方法起名字。</li>\n</ul>\n<h3 id=\"Callback-programming-回调编程\"><a href=\"#Callback-programming-回调编程\" class=\"headerlink\" title=\"Callback programming (回调编程)\"></a>Callback programming (回调编程)</h3><ul>\n<li>当你读GUI框架的文档的时候，你会注意到观察者/事件处理程序叫做“callback”，因为主体窗口小部件会“回调”它们去处理事件。所以你经常看到这种编程类型叫做“回调编程”。</li>\n</ul>\n<h3 id=\"GUI-programming-summary-GUI编程-概要\"><a href=\"#GUI-programming-summary-GUI编程-概要\" class=\"headerlink\" title=\"GUI programming - summary (GUI编程-概要)\"></a>GUI programming - summary (GUI编程-概要)</h3><ul>\n<li>这里我们全身心的投入到GUI应用中事件驱动编程的论题中。或者应该说，我们讨论的是GUI编程的上下文环境中的处理程序模式。</li>\n<li>从根本上来说，GUI编程和其他那些我们见过的处理程序模式的例子没有太多不同。GUI编程和其他处理程序模式的形式不同在于，它大多总是牵扯到“观察者模式”。这就是为什么：GUI城边大多总是包含注册或绑定的过程（事件处理程序（观察者）捆绑到（注册到）事件生成器（主体））。</li>\n<li>注册的过程开起来就是基础的事件处模式上的一个小变化（这只是一个结合事件处理程序和事件生成者的特殊方式）。</li>\n</ul>\n<h2 id=\"Maintaining-State-维持状态\"><a href=\"#Maintaining-State-维持状态\" class=\"headerlink\" title=\"Maintaining State (维持状态)\"></a>Maintaining State (维持状态)</h2><ul>\n<li>许多事件驱动应用程序时无状态的。者意味着当应用程序处理完成了一个事件，应用程序没有被事件改变。</li>\n<li>与无状态应用对立的时有状态应用。有状态的应用程序可以通过事件来改变应用的进程。具体来说，有状态程序可以记住或保持事件之间的信息，它们所记住的信息（它们的状态信息）可以通过事件来改变。</li>\n<li>锤子是个无状态的工具，如果你要钉钉子，锤子就和你钉钉子之前没区别，锤子还是之前那样。订书机时有状态的工具，如果你用它钉一些纸，钉的这个动作就会改变它的状态（在钉这个动作之后，订书机就会比之前少一个订书钉）。</li>\n<li>在大多数基本Web游览的类型中，一个Web服务器收到一个展示的特定页的请求，返回请求页，在结束之后什么都没记住。这就是无状态的应z。大多数有经验的网页会展示访问次数（“自从2000年1月1日，这个页面已经被访问了876532次”）。要做到这个，这个应用的背后网页必须记住被访问的次数，并且在每次网页被访问时增长次数。这个应用就是有状态的。</li>\n</ul>\n<h3 id=\"Rejection-invalid-transactions-拒绝无效事务\"><a href=\"#Rejection-invalid-transactions-拒绝无效事务\" class=\"headerlink\" title=\"Rejection invalid transactions (拒绝无效事务)\"></a>Rejection invalid transactions (拒绝无效事务)</h3><ul>\n<li>在之前的讨论中，我们注意到面向对象编程是一种事件驱动编程。在大多数案例中，面向对象编程包括的对象都是有状态的。比如一个“栈”在它的实例化变量中维持着它的状态，在下图中这个区域标记成“internal data 内部数据”。</li>\n<li>图【Stack object diagram】</li>\n<li>当我们实例化Stack类去创建stack对象时，stack开始为空。</li>\n<li>现在假设下列事件序列发生：<ul>\n<li>一个“push(X)”事件到达。X是添加到栈中，改变栈的状态。</li>\n<li>一个“pop()”事件到达。X从栈中移除（再次改变栈状态）并且返回。栈现在空了。</li>\n<li>另一个“pop()”事件到达。</li>\n</ul>\n</li>\n<li>现在我们遇到了一个问题。栈不能满足此需求。它不能移除并返回栈顶元素，因为栈顶没有元素了；栈是空的。</li>\n<li>这个例子阐述了重要的有状态应用的特性。一般来说，有状态应用定义了（至少隐式的）可接受“状态+事务”类型对的列表。在列表中的每一对，当应用处于指定状态时，应用可以处理指定类型的事务。但是如果到达的事务在当前的状态中不可接受，事务必须被拒绝。</li>\n<li>这有很多相似的这种例子：<ul>\n<li>一般来说，一个成年人如果他想结婚，他就可以结婚，但是如果他已经结婚了，那么就不能再结婚了（X的配偶由文化决定）。</li>\n<li>一般来说，你可以从你的银行账户存取钱，但是你不能从你的账户中取出更多的钱。</li>\n<li>一般来说，你可以兑换你的飞行常客里程以免费飞行，但是航空公司不允许你再繁忙旅行的“断电时段”兑换，比如感恩节前一天。</li>\n<li>一般来说，数据库应用可以再数据中中更新一条记录，但是它不能更新被作者应用锁定的记录。</li>\n</ul>\n</li>\n<li>应用程序由多种方法来相应无效的事务。当然最简单的就是忽略它。但是，一般来说,最好的相应方式是提出一个异常，并让被提交事务的模块处理异常。</li>\n<li>依赖于使用语言的能力，应用提出一个通用异常并伴随一条描述错误的信息，或者可以对指定的问题类型，定义指定的异常。一个栈的实例可以定义为：<ul>\n<li>“StackEmptyException” 栈空异常，当栈是空的并且受到“Pop()”请求时提出此异常。</li>\n<li>“StackOverflowException” 栈溢出异常，当栈满了，并且收到了“Push()”请求时提出此异常。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"State-Machines-状态机\"><a href=\"#State-Machines-状态机\" class=\"headerlink\" title=\"State Machines (状态机)\"></a>State Machines (状态机)</h3><ul>\n<li>在一些案例中，状态机是有效的思考具有生命周期对象（有状态的计算机应用）的方法。在它的生命周期中，有状态对象通过相应事务（事件）来在不同状态之间切换。</li>\n<li>对象的这种行为叫做“有限状态机 Finite State Machine”（FSM）或者“定向有限状态机 Directed Finite Automaton”（DFA）。描述有限状态机的典型方式是用“状态事务图 State Transition Diagram”（STD）。在STD中，圆圈代表状态，用事务走向的事件名标记的箭头代表了事务。</li>\n<li>这有个STD的例子，它代表了一个人的生活和婚姻历史（由文化规定，同一时间只能由一个配偶）。</li>\n<li>图【STD for life and marriage history of a person】</li>\n<li>在STD中，状态是：“SINGLE 单身”、“MARRIED 已婚”、“DEAD 死亡”。当一个人开始他的生活，它是单身的（开始的状态是SINGLE）。他可能还没有结婚就死亡了，或者他结婚了。他可能在结婚之后死亡，或者通过离婚或丧偶重新回到单身。DEAD是“终点状态”（没有事件事务从这里出去）。</li>\n<li>这个Person类的伪代码如下：</li>\n<li>图【Person class】</li>\n<li>在上述我们讨论的状态中，我们使用“state 状态”和“state information”状态信息指人的所有有状态信息，是对象实例化变量的完整集合。但是当讨论到STD和FSM时，我们在有限状态机中使用“state”这个词去指特定的没有关联的状态。</li>\n<li>遗憾的是，还没有标准术语来区分“state”这个单词的两种意思。Michael Jackson 使用术语“state vector 状态向量”来指第一种情况（“vector”变量列表包含一个对象的状态信息）。程序员经常使用“status”（如“status_flag”,“status_indicator”）来指第二种情况。</li>\n<li>在本文余下部分，一般上下文会指出我用的是哪种“state”。当有可能产生混淆时，我会使用“state vector”（或者“state_information”）和“status”去让事情保持清晰。</li>\n</ul>\n<h3 id=\"Coding-a-Finite-State-Machine-1-编写一个有限状态机1\"><a href=\"#Coding-a-Finite-State-Machine-1-编写一个有限状态机1\" class=\"headerlink\" title=\"Coding a Finite State Machine 1 (编写一个有限状态机1)\"></a>Coding a Finite State Machine 1 (编写一个有限状态机1)</h3><ul>\n<li>有很多不同的技术来编码实现一个有限状态机。在给出的例子中，你选择那种技术取决于你的应用类型和你所用语言的特性。正是因为这些，我会给你介绍你个典型的FSM程序实现的例子。</li>\n<li>这有个有限状态机的状态转换图，它的目的是分解文字的输入流到文字组和空白组。</li>\n<li>图【Break Input Stream STD】</li>\n<li>在接下来的几页有实现此FSM的源码。在看源码之前，我要指出几点关于它的事。</li>\n<li>首先，这是一个解析程序。它会读取文字的输入流，分解它到文字组（tokens 标志令牌），通过类型来标记“tokens 标志令牌”。解析（这是在标记化编译阶段和处理标记语言如HTML和XML完成的）是一个经典的阐述实现有限状态机的程序。</li>\n<li>第二，它使用了经典的设计模式来编码有限状态机。对于许多应用，当处理一个事务时，FSM程序必须要做如下三件事：<ul>\n<li>与离开当前状态相关的活动</li>\n<li>改变当前状态到新状态</li>\n<li>与进入新状态相关的活动</li>\n</ul>\n</li>\n<li>我在活动应该发生的地方写了注释。</li>\n<li>最后，这个程序膳食了我们在处理程序模式中期望看到的特性。输入流时事件队列。从输入流中读取一个字符是从事件队列中取出一个事件。一个时间循环检查每个字符、事件、事务去决定它是否是文字还是空白，然后分发它们到合适的处理程序。当然也会编码一个“EndOfEvents”（输入流最后）事件，在此事件到来时，将结束事件循环。</li>\n<li>如下就是使用Python编写的源码实现。</li>\n<li>图【Implements FSM】</li>\n<li>在这个非常简单的例子中，程序解析如下字符串：</li>\n<li>图【”Suzy Smith Loves    John Jones”】</li>\n<li>生成如下输出：</li>\n<li>图【Implements Output】</li>\n</ul>\n<h3 id=\"Coding-a-Finite-State-Machine-2-编写一个有限状态机2\"><a href=\"#Coding-a-Finite-State-Machine-2-编写一个有限状态机2\" class=\"headerlink\" title=\"Coding a Finite State Machine 2 (编写一个有限状态机2)\"></a>Coding a Finite State Machine 2 (编写一个有限状态机2)</h3><ul>\n<li>作为一个实际问题，一会发现你使用了如下概念：<ul>\n<li>输入一个状态state（status）</li>\n<li>保持状态信息state information（the state vector）</li>\n<li>离开一个状态state（status）</li>\n<li>拒绝当前状态下无效的事务</li>\n</ul>\n</li>\n<li>在你选择去写的多种事件驱动程序里。<ul>\n<li>在GUI程序中，窗口小工具经常需要记住它们的状态。如果一个用户点击了复选框，GUI应用需要知道复选框当前的状态（选中，未选中）为了在两种状态中切换。</li>\n<li>在线应用需要记住所有种类的状态信息。如果一个用户登录一个安全的应用，用错误的密码连续提交三次，用户有可能被锁定。</li>\n<li>在Web应用中，程序经常需要记住它们的状态。如果一个购物车应用用户提交没有登录他账单信息的订单，要将错误反馈给他，并且拒绝提交事件。</li>\n<li>在分析一个编程语言时，是否接受特殊字符（如波浪字符、问号）在原文中出现。它可能在注释或者当出现在引号中没出现在其他地方时可以接受。</li>\n</ul>\n</li>\n<li>在SAX处理XML中，事件驱动应用类型的状态问题非常明显。实际上，SAX分析器提供的了startElement”和“endElement”方法实际上是“startState 开始状态”和“endState 结束状态”。当你遇到某些类型的开始标签（如”\\<h1>“），你实际上在进入一个状态。在文档中发生在这个状态上下文中所有之后的元素直到你遇到相应的末尾标签（如“\\<h1>”）。</h1></h1></li>\n<li>这有一个用Python写的SAX程序代码片段，用来检查确保在输入中不包含“\\<br>”标签或者头标签嵌套在其他头标签里的情况。</li>\n<li>图【CustomizedHandler class】</li>\n<li>对比这个代码结构和解析文字和空格的代码。</li>\n<li>解析程序非常简单，所以一旦我们进入“handlerSpace”或“handLetter”函数中，解析程序知道他要处理事务所需的一切。这对于这个程序还不够。一旦我么进入了“startElement”或“endElement”方法，我们要进一步检查我们处理的标签种类。</li>\n<li>但是一旦我们知道我们处理事件的种类，处理就变得非常简单。从根本上来说，它包含设置和检查“status information 状态信息”（inHeadingStatus）和“state-vector 状态向量信息”（currentHeadingTag），并且基于当前状态允许或拒绝事务。</li>\n</ul>\n<h3 id=\"Way-to-remember-state-记住状态的方法\"><a href=\"#Way-to-remember-state-记住状态的方法\" class=\"headerlink\" title=\"Way to remember state (记住状态的方法)\"></a>Way to remember state (记住状态的方法)</h3><ul>\n<li>许多有状态的应用只需在程序运行时记住它们的状态即可。一些应用没有记住它们状态信息的问题，它们只需要在内存中存储即可。例如，在我们的解析程序中，我们使用了state和outstring global变量。在我们的SAX内容处理程序中，我们使用的“inHeadingStatus”和“currentHeadingTag”内容处理程序对象的实例变量。</li>\n<li>但是其他有状态的应用需要推迟执行，也就是说，它们需要在内存以外存储信息。如这个应用：<ul>\n<li>存储状态信息的责任交到一些可以续存储的媒介中，例如存储在硬盘上的一个文件或数据库。当它启动的时候，它从数据库中恢复它的状态信息，在结束之前再将状态信息存回（持久化）数据库。</li>\n</ul>\n</li>\n<li>或者这样：<ul>\n<li>委托它的调用者负担起存储状态信息的责任。开始时，它从它的调用者收到状态信息，在它结束时再返回状态信息给它的调用者。</li>\n</ul>\n</li>\n<li>Web应用程序是这种有状态应用程序的好例子，因为它们经常使用这两种例子来存储状态信息。考虑“nozama.com”这个网站，一个虚构的经典的用户和Web游览器模式的Web购物应用：<ul>\n<li>打开“nozama.com”Web页</li>\n<li>他通过反复游览“Nozama”产品分类选择产品，一个一个的将产品放到购物车中。</li>\n<li>输入他的账单和购物信息</li>\n<li>提交他的订单</li>\n</ul>\n</li>\n<li>在任何给定时间，可能同时有成百上千的用户使用购物程序。Nozama必须交替从不同购物程序阶段的不同客户的请求中取出并处理。遗憾的是，简单的Web技术为Nozama提供购物者的直接链接。</li>\n<li>Nozama和类似的应用需要一种识别与特定客户端对话的方法。如一个叫做session的对话。Nozama需要管理创建、保持和存储session信息过程的方法。</li>\n<li>这有怎么做的方法。</li>\n<li>当一个用户打开Nozama网站，Nozama创建一个临时的session对象。用户通过购物程序，Nozama添加用户给出的信息（选择的产品、账单、购物信息）到他的session对象的状态信息。最后当用户提交他的订单时session的生命周期结束。</li>\n<li>Nozama通过给每个session一个sessionID，存储session的state vector（他的状态信息）到数据库来跟踪sessions，其中sessionID时state vector的关键。</li>\n<li>一旦启动一个session，在所有网页中Nozama包括session ID将它发送给用户，通过用户以某种方式编码，并且Nozame作为每个页面请求的一部分返回。当Nozama收到一个包含session ID的请求，它使用session ID作为密钥从数据库中去恢复session的vector information。在Nozama处理完用户的请求后，它会在数据库中更新和替换state vector，并且返回一个响应给用户。</li>\n<li>图【Nozama schematic】</li>\n<li>要记住我们说的，有状态应用要记住它的状态信息，可以用存储到可持久化的媒介上，或者用调用它的调用者代理存储。Nozama使用了这两种策略。他在硬盘的数据库中存储了用户的实际状态信息。但是在这个案例中，它同样的也给了它的调用者（客户端游览器）状态信息。客户端游览器负责记录一次的状态信息：session ID。</li>\n<li>还有一种策略是Nozama通过把整个session状态发送到游览器，让游览器记住他。如果Nozama这样做了，它就不用在数据库中存储信息，它就会变得更简单。但是前后端传输的state vector信息包会变大，导致降低相应时间。</li>\n<li>代替策略确实有一个明显的优势，如果用户在完成购物前放弃购物，则在数据库中则没有孤立的session信息。对比数据库的策略，Nozama必须实现一个检测session超时放弃的通知。当一段时间（比如30分钟）之后，session的状态信息将无法访问，Nozama将考虑到将session终止，并且从数据库中删除状态信息。</li>\n</ul>\n<h2 id=\"Conlusion-结尾\"><a href=\"#Conlusion-结尾\" class=\"headerlink\" title=\"Conlusion (结尾)\"></a>Conlusion (结尾)</h2><ul>\n<li>接下来我们总结一下这篇简短的介绍事件驱动编程（处理程序模式和它的变体）和相关的编程问题的文章。</li>\n<li>正如你所看到的，理解事件驱动编程是能够完成许多软件开发任务（面向对象编程、面向对象系统分析和设计、用SAX解析器解析XML、GUI编程、Web编程、甚至是词法分析）的关键。</li>\n<li>祝你的事件驱动编程顺利。</li>\n</ul>\n"},{"title":"花牌记分器","author":"SmalBox","cover":false,"top":true,"date":"2020-01-28T07:41:19.000Z","_content":"# 花牌记分器 V0.2.1\n\n## Description\n\n   - 花牌记分器用于2-6人的花牌记分\n   - 主要帮助统计玩家分数，核对本轮数据\n   - 以html实现，可在线使用，也可下载离线使用\n   - [点击使用花牌记分器](https://nas.smalbox.top/HuaPaiScore/HuaPai.html)\n\n## Usage\n\n   1. 填写**玩家名字**\n   2. 根据实际得分情况，填写本轮得分\n      - 例如：-10，10，+50\n   3. 点击 **‘结算得分’** 记分器会自动**核算本轮得分是否正确**\n      - 当发现本轮得分错误，在**消息盒子**中会提示\n      - 当本轮得分正确无误，记分器会将得分**核算到累计得分中**\n      \n   <br/>\n   \n   - 点击 **‘重置’** 可重置**累计得分**和**本轮得分**","source":"_posts/花牌记分器.md","raw":"---\ntitle: 花牌记分器\nauthor: SmalBox\ncover: false\ntop: true\ndate: 2020-01-28 15:41:19\ncategories: 前端\ntags:\n  - 花牌\n  - 统计\n---\n# 花牌记分器 V0.2.1\n\n## Description\n\n   - 花牌记分器用于2-6人的花牌记分\n   - 主要帮助统计玩家分数，核对本轮数据\n   - 以html实现，可在线使用，也可下载离线使用\n   - [点击使用花牌记分器](https://nas.smalbox.top/HuaPaiScore/HuaPai.html)\n\n## Usage\n\n   1. 填写**玩家名字**\n   2. 根据实际得分情况，填写本轮得分\n      - 例如：-10，10，+50\n   3. 点击 **‘结算得分’** 记分器会自动**核算本轮得分是否正确**\n      - 当发现本轮得分错误，在**消息盒子**中会提示\n      - 当本轮得分正确无误，记分器会将得分**核算到累计得分中**\n      \n   <br/>\n   \n   - 点击 **‘重置’** 可重置**累计得分**和**本轮得分**","slug":"花牌记分器","published":1,"updated":"2020-04-04T13:27:20.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptii70016bsfowyijtdi2","content":"<h1 id=\"花牌记分器-V0-2-1\"><a href=\"#花牌记分器-V0-2-1\" class=\"headerlink\" title=\"花牌记分器 V0.2.1\"></a>花牌记分器 V0.2.1</h1><h2 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h2><ul>\n<li>花牌记分器用于2-6人的花牌记分</li>\n<li>主要帮助统计玩家分数，核对本轮数据</li>\n<li>以html实现，可在线使用，也可下载离线使用</li>\n<li><a href=\"https://nas.smalbox.top/HuaPaiScore/HuaPai.html\" target=\"_blank\" rel=\"noopener\">点击使用花牌记分器</a></li>\n</ul>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><ol>\n<li>填写<strong>玩家名字</strong></li>\n<li>根据实际得分情况，填写本轮得分<ul>\n<li>例如：-10，10，+50</li>\n</ul>\n</li>\n<li><p>点击 <strong>‘结算得分’</strong> 记分器会自动<strong>核算本轮得分是否正确</strong></p>\n<ul>\n<li>当发现本轮得分错误，在<strong>消息盒子</strong>中会提示</li>\n<li>当本轮得分正确无误，记分器会将得分<strong>核算到累计得分中</strong></li>\n</ul>\n<p><br></p>\n</li>\n</ol>\n<ul>\n<li>点击 <strong>‘重置’</strong> 可重置<strong>累计得分</strong>和<strong>本轮得分</strong></li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"花牌记分器-V0-2-1\"><a href=\"#花牌记分器-V0-2-1\" class=\"headerlink\" title=\"花牌记分器 V0.2.1\"></a>花牌记分器 V0.2.1</h1><h2 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h2><ul>\n<li>花牌记分器用于2-6人的花牌记分</li>\n<li>主要帮助统计玩家分数，核对本轮数据</li>\n<li>以html实现，可在线使用，也可下载离线使用</li>\n<li><a href=\"https://nas.smalbox.top/HuaPaiScore/HuaPai.html\" target=\"_blank\" rel=\"noopener\">点击使用花牌记分器</a></li>\n</ul>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><ol>\n<li>填写<strong>玩家名字</strong></li>\n<li>根据实际得分情况，填写本轮得分<ul>\n<li>例如：-10，10，+50</li>\n</ul>\n</li>\n<li><p>点击 <strong>‘结算得分’</strong> 记分器会自动<strong>核算本轮得分是否正确</strong></p>\n<ul>\n<li>当发现本轮得分错误，在<strong>消息盒子</strong>中会提示</li>\n<li>当本轮得分正确无误，记分器会将得分<strong>核算到累计得分中</strong></li>\n</ul>\n<p><br></p>\n</li>\n</ol>\n<ul>\n<li>点击 <strong>‘重置’</strong> 可重置<strong>累计得分</strong>和<strong>本轮得分</strong></li>\n</ul>\n"},{"title":"群晖无损扩充硬盘空间raid1","author":"SmalBox","cover":false,"top":false,"date":"2019-07-14T01:32:17.000Z","_content":"# 群晖无损扩充硬盘空间raid1\n\n## **前言**\n\n群晖（Synology）原本的500G raid1 硬盘阵列坏了一块硬盘，准备换一块新硬盘，但是500g的硬盘和1t硬盘只有10来元的差价，果断入手1t的。那么问题来了，原来的500G可以无损扩充吗，事实证明是可以的，**（重点是！黑白晖都可直插无损修复扩展）**。\n\n接下来演示怎样无损扩展。\n\n## **步骤概要**\n\n   1. 换上1T硬盘，与原来的 500G硬盘 组500G的raid1\n   2. 换上另一块1T硬盘，与第一块 500G硬盘 组500G的raid1\n   3. 将500G的raid1扩容到1T的raid1\n\n## **恢复到硬盘1**\n\n   1. 将坏掉的硬盘换成新的1T硬盘，然后网页进入nas界面，点击**存储空间管理员**\n       ![restoreToNewHardDiskOne1](restoreToNewHardDiskOne1.png)\n   2. 在系统概况中看到绿色的未使用的硬盘，即说明硬盘安装无误，点击**存储空间**\n       ![restoreToNewHardDiskOne2](restoreToNewHardDiskOne2.png)\n   3. 在存储空间中能看到存储状态，点击**按建议在RAID Group设置下单机此处可继续**\n       ![restoreToNewHardDiskOne3](restoreToNewHardDiskOne3.png)\n   4. 在RAID Group 中，点击**管理**\n       ![restoreToNewHardDiskOne4](restoreToNewHardDiskOne4.png)\n   5. 点击**修复**\n       ![restoreToNewHardDiskOne5](restoreToNewHardDiskOne5.png)\n   6. 在选择硬盘界面，将左面的硬盘拖入右面\n       ![restoreToNewHardDiskOne6](restoreToNewHardDiskOne6.png)\n       ![restoreToNewHardDiskOne7](restoreToNewHardDiskOne7.png)\n   7. 进行硬盘检查，默认是否，建议点击是，检查硬盘\n       ![restoreToNewHardDiskOne8](restoreToNewHardDiskOne8.png)\n   8. 之后会进行数据同步修复\n       ![restoreToNewHardDiskOne9](restoreToNewHardDiskOne9.png)\n       ![restoreToNewHardDiskOne10](restoreToNewHardDiskOne10.png)\n   9. 如图，一个500G 一个1T 硬盘，存储空间500G， 即成功恢复到第一块硬盘\n       ![restoreToNewHardDiskOne11](restoreToNewHardDiskOne11.png)\n\n## **恢复到硬盘2**\n\n   1. 将第二块1T硬盘换入到nas中，恢复步骤同上一步，会进行**数据同步**\n       ![restoreToNewHardDiskTwo1](restoreToNewHardDiskTwo1.png)\n   2. **一致性校验**\n       ![restoreToNewHardDiskTwo2](restoreToNewHardDiskTwo2.png)\n   3. 如图即恢复到2块1T硬盘组500G raid1的状态\n       ![restoreToNewHardDiskTwo3](restoreToNewHardDiskTwo3.png)\n\n## **扩充容量**\n\n   1. 在存储空间中，点击编辑\n       ![capacityExpansion1](capacityExpansion1.png)\n   2. 将**配置容量**选择**最大化**，点击确定\n       ![capacityExpansion2](capacityExpansion2.png)\n   3. 显示**扩充文件系统中**\n       ![capacityExpansion3](capacityExpansion3.png)\n   4. 如图，扩充完成\n       ![capacityExpansion4](capacityExpansion4.png)\n\n## **总结**\n\n   - 群晖的raid1还是很方便好用的，只要换上硬盘相互备份即可。*(黑白晖都可直插无损修复扩展)*\n   - 群晖的系统我是装到硬盘里了。能让我这样直接抽盘换盘恢复备份，即说明，群晖的2.4G的系统分区也是在每个盘都有备份的。不管是哪个盘挂了，都能随意抽换恢复，体验很好。\n   - *（**在恢复过程中有不清楚的，可以评论或发邮件联系我**）*","source":"_posts/群晖无损扩充硬盘空间raid1.md","raw":"---\ntitle: 群晖无损扩充硬盘空间raid1\nauthor: SmalBox\ncover: false\ntop: false\ndate: 2019-07-14 09:32:17\ncategories: DIY\ntags:\n  - 群晖Synology\n  - raid1\n  - 无损扩容\n---\n# 群晖无损扩充硬盘空间raid1\n\n## **前言**\n\n群晖（Synology）原本的500G raid1 硬盘阵列坏了一块硬盘，准备换一块新硬盘，但是500g的硬盘和1t硬盘只有10来元的差价，果断入手1t的。那么问题来了，原来的500G可以无损扩充吗，事实证明是可以的，**（重点是！黑白晖都可直插无损修复扩展）**。\n\n接下来演示怎样无损扩展。\n\n## **步骤概要**\n\n   1. 换上1T硬盘，与原来的 500G硬盘 组500G的raid1\n   2. 换上另一块1T硬盘，与第一块 500G硬盘 组500G的raid1\n   3. 将500G的raid1扩容到1T的raid1\n\n## **恢复到硬盘1**\n\n   1. 将坏掉的硬盘换成新的1T硬盘，然后网页进入nas界面，点击**存储空间管理员**\n       ![restoreToNewHardDiskOne1](restoreToNewHardDiskOne1.png)\n   2. 在系统概况中看到绿色的未使用的硬盘，即说明硬盘安装无误，点击**存储空间**\n       ![restoreToNewHardDiskOne2](restoreToNewHardDiskOne2.png)\n   3. 在存储空间中能看到存储状态，点击**按建议在RAID Group设置下单机此处可继续**\n       ![restoreToNewHardDiskOne3](restoreToNewHardDiskOne3.png)\n   4. 在RAID Group 中，点击**管理**\n       ![restoreToNewHardDiskOne4](restoreToNewHardDiskOne4.png)\n   5. 点击**修复**\n       ![restoreToNewHardDiskOne5](restoreToNewHardDiskOne5.png)\n   6. 在选择硬盘界面，将左面的硬盘拖入右面\n       ![restoreToNewHardDiskOne6](restoreToNewHardDiskOne6.png)\n       ![restoreToNewHardDiskOne7](restoreToNewHardDiskOne7.png)\n   7. 进行硬盘检查，默认是否，建议点击是，检查硬盘\n       ![restoreToNewHardDiskOne8](restoreToNewHardDiskOne8.png)\n   8. 之后会进行数据同步修复\n       ![restoreToNewHardDiskOne9](restoreToNewHardDiskOne9.png)\n       ![restoreToNewHardDiskOne10](restoreToNewHardDiskOne10.png)\n   9. 如图，一个500G 一个1T 硬盘，存储空间500G， 即成功恢复到第一块硬盘\n       ![restoreToNewHardDiskOne11](restoreToNewHardDiskOne11.png)\n\n## **恢复到硬盘2**\n\n   1. 将第二块1T硬盘换入到nas中，恢复步骤同上一步，会进行**数据同步**\n       ![restoreToNewHardDiskTwo1](restoreToNewHardDiskTwo1.png)\n   2. **一致性校验**\n       ![restoreToNewHardDiskTwo2](restoreToNewHardDiskTwo2.png)\n   3. 如图即恢复到2块1T硬盘组500G raid1的状态\n       ![restoreToNewHardDiskTwo3](restoreToNewHardDiskTwo3.png)\n\n## **扩充容量**\n\n   1. 在存储空间中，点击编辑\n       ![capacityExpansion1](capacityExpansion1.png)\n   2. 将**配置容量**选择**最大化**，点击确定\n       ![capacityExpansion2](capacityExpansion2.png)\n   3. 显示**扩充文件系统中**\n       ![capacityExpansion3](capacityExpansion3.png)\n   4. 如图，扩充完成\n       ![capacityExpansion4](capacityExpansion4.png)\n\n## **总结**\n\n   - 群晖的raid1还是很方便好用的，只要换上硬盘相互备份即可。*(黑白晖都可直插无损修复扩展)*\n   - 群晖的系统我是装到硬盘里了。能让我这样直接抽盘换盘恢复备份，即说明，群晖的2.4G的系统分区也是在每个盘都有备份的。不管是哪个盘挂了，都能随意抽换恢复，体验很好。\n   - *（**在恢复过程中有不清楚的，可以评论或发邮件联系我**）*","slug":"群晖无损扩充硬盘空间raid1","published":1,"updated":"2020-04-04T14:21:34.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8lptiib001absfonxnljvi6","content":"<h1 id=\"群晖无损扩充硬盘空间raid1\"><a href=\"#群晖无损扩充硬盘空间raid1\" class=\"headerlink\" title=\"群晖无损扩充硬盘空间raid1\"></a>群晖无损扩充硬盘空间raid1</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>群晖（Synology）原本的500G raid1 硬盘阵列坏了一块硬盘，准备换一块新硬盘，但是500g的硬盘和1t硬盘只有10来元的差价，果断入手1t的。那么问题来了，原来的500G可以无损扩充吗，事实证明是可以的，<strong>（重点是！黑白晖都可直插无损修复扩展）</strong>。</p>\n<p>接下来演示怎样无损扩展。</p>\n<h2 id=\"步骤概要\"><a href=\"#步骤概要\" class=\"headerlink\" title=\"步骤概要\"></a><strong>步骤概要</strong></h2><ol>\n<li>换上1T硬盘，与原来的 500G硬盘 组500G的raid1</li>\n<li>换上另一块1T硬盘，与第一块 500G硬盘 组500G的raid1</li>\n<li>将500G的raid1扩容到1T的raid1</li>\n</ol>\n<h2 id=\"恢复到硬盘1\"><a href=\"#恢复到硬盘1\" class=\"headerlink\" title=\"恢复到硬盘1\"></a><strong>恢复到硬盘1</strong></h2><ol>\n<li>将坏掉的硬盘换成新的1T硬盘，然后网页进入nas界面，点击<strong>存储空间管理员</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne1.png\" alt=\"restoreToNewHardDiskOne1\"></li>\n<li>在系统概况中看到绿色的未使用的硬盘，即说明硬盘安装无误，点击<strong>存储空间</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne2.png\" alt=\"restoreToNewHardDiskOne2\"></li>\n<li>在存储空间中能看到存储状态，点击<strong>按建议在RAID Group设置下单机此处可继续</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne3.png\" alt=\"restoreToNewHardDiskOne3\"></li>\n<li>在RAID Group 中，点击<strong>管理</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne4.png\" alt=\"restoreToNewHardDiskOne4\"></li>\n<li>点击<strong>修复</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne5.png\" alt=\"restoreToNewHardDiskOne5\"></li>\n<li>在选择硬盘界面，将左面的硬盘拖入右面<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne6.png\" alt=\"restoreToNewHardDiskOne6\"><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne7.png\" alt=\"restoreToNewHardDiskOne7\"></li>\n<li>进行硬盘检查，默认是否，建议点击是，检查硬盘<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne8.png\" alt=\"restoreToNewHardDiskOne8\"></li>\n<li>之后会进行数据同步修复<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne9.png\" alt=\"restoreToNewHardDiskOne9\"><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne10.png\" alt=\"restoreToNewHardDiskOne10\"></li>\n<li>如图，一个500G 一个1T 硬盘，存储空间500G， 即成功恢复到第一块硬盘<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne11.png\" alt=\"restoreToNewHardDiskOne11\"></li>\n</ol>\n<h2 id=\"恢复到硬盘2\"><a href=\"#恢复到硬盘2\" class=\"headerlink\" title=\"恢复到硬盘2\"></a><strong>恢复到硬盘2</strong></h2><ol>\n<li>将第二块1T硬盘换入到nas中，恢复步骤同上一步，会进行<strong>数据同步</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskTwo1.png\" alt=\"restoreToNewHardDiskTwo1\"></li>\n<li><strong>一致性校验</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskTwo2.png\" alt=\"restoreToNewHardDiskTwo2\"></li>\n<li>如图即恢复到2块1T硬盘组500G raid1的状态<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskTwo3.png\" alt=\"restoreToNewHardDiskTwo3\"></li>\n</ol>\n<h2 id=\"扩充容量\"><a href=\"#扩充容量\" class=\"headerlink\" title=\"扩充容量\"></a><strong>扩充容量</strong></h2><ol>\n<li>在存储空间中，点击编辑<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/capacityExpansion1.png\" alt=\"capacityExpansion1\"></li>\n<li>将<strong>配置容量</strong>选择<strong>最大化</strong>，点击确定<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/capacityExpansion2.png\" alt=\"capacityExpansion2\"></li>\n<li>显示<strong>扩充文件系统中</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/capacityExpansion3.png\" alt=\"capacityExpansion3\"></li>\n<li>如图，扩充完成<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/capacityExpansion4.png\" alt=\"capacityExpansion4\"></li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><ul>\n<li>群晖的raid1还是很方便好用的，只要换上硬盘相互备份即可。<em>(黑白晖都可直插无损修复扩展)</em></li>\n<li>群晖的系统我是装到硬盘里了。能让我这样直接抽盘换盘恢复备份，即说明，群晖的2.4G的系统分区也是在每个盘都有备份的。不管是哪个盘挂了，都能随意抽换恢复，体验很好。</li>\n<li><em>（<strong>在恢复过程中有不清楚的，可以评论或发邮件联系我</strong>）</em></li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://www.bugprogrammer.me/images/my.jpeg","name":"BP","introduction":"bug killer","url":"https://www.bugprogrammer.me","title":"bugProgrammer"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"群晖无损扩充硬盘空间raid1\"><a href=\"#群晖无损扩充硬盘空间raid1\" class=\"headerlink\" title=\"群晖无损扩充硬盘空间raid1\"></a>群晖无损扩充硬盘空间raid1</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>群晖（Synology）原本的500G raid1 硬盘阵列坏了一块硬盘，准备换一块新硬盘，但是500g的硬盘和1t硬盘只有10来元的差价，果断入手1t的。那么问题来了，原来的500G可以无损扩充吗，事实证明是可以的，<strong>（重点是！黑白晖都可直插无损修复扩展）</strong>。</p>\n<p>接下来演示怎样无损扩展。</p>\n<h2 id=\"步骤概要\"><a href=\"#步骤概要\" class=\"headerlink\" title=\"步骤概要\"></a><strong>步骤概要</strong></h2><ol>\n<li>换上1T硬盘，与原来的 500G硬盘 组500G的raid1</li>\n<li>换上另一块1T硬盘，与第一块 500G硬盘 组500G的raid1</li>\n<li>将500G的raid1扩容到1T的raid1</li>\n</ol>\n<h2 id=\"恢复到硬盘1\"><a href=\"#恢复到硬盘1\" class=\"headerlink\" title=\"恢复到硬盘1\"></a><strong>恢复到硬盘1</strong></h2><ol>\n<li>将坏掉的硬盘换成新的1T硬盘，然后网页进入nas界面，点击<strong>存储空间管理员</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne1.png\" alt=\"restoreToNewHardDiskOne1\"></li>\n<li>在系统概况中看到绿色的未使用的硬盘，即说明硬盘安装无误，点击<strong>存储空间</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne2.png\" alt=\"restoreToNewHardDiskOne2\"></li>\n<li>在存储空间中能看到存储状态，点击<strong>按建议在RAID Group设置下单机此处可继续</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne3.png\" alt=\"restoreToNewHardDiskOne3\"></li>\n<li>在RAID Group 中，点击<strong>管理</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne4.png\" alt=\"restoreToNewHardDiskOne4\"></li>\n<li>点击<strong>修复</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne5.png\" alt=\"restoreToNewHardDiskOne5\"></li>\n<li>在选择硬盘界面，将左面的硬盘拖入右面<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne6.png\" alt=\"restoreToNewHardDiskOne6\"><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne7.png\" alt=\"restoreToNewHardDiskOne7\"></li>\n<li>进行硬盘检查，默认是否，建议点击是，检查硬盘<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne8.png\" alt=\"restoreToNewHardDiskOne8\"></li>\n<li>之后会进行数据同步修复<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne9.png\" alt=\"restoreToNewHardDiskOne9\"><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne10.png\" alt=\"restoreToNewHardDiskOne10\"></li>\n<li>如图，一个500G 一个1T 硬盘，存储空间500G， 即成功恢复到第一块硬盘<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskOne11.png\" alt=\"restoreToNewHardDiskOne11\"></li>\n</ol>\n<h2 id=\"恢复到硬盘2\"><a href=\"#恢复到硬盘2\" class=\"headerlink\" title=\"恢复到硬盘2\"></a><strong>恢复到硬盘2</strong></h2><ol>\n<li>将第二块1T硬盘换入到nas中，恢复步骤同上一步，会进行<strong>数据同步</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskTwo1.png\" alt=\"restoreToNewHardDiskTwo1\"></li>\n<li><strong>一致性校验</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskTwo2.png\" alt=\"restoreToNewHardDiskTwo2\"></li>\n<li>如图即恢复到2块1T硬盘组500G raid1的状态<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/restoreToNewHardDiskTwo3.png\" alt=\"restoreToNewHardDiskTwo3\"></li>\n</ol>\n<h2 id=\"扩充容量\"><a href=\"#扩充容量\" class=\"headerlink\" title=\"扩充容量\"></a><strong>扩充容量</strong></h2><ol>\n<li>在存储空间中，点击编辑<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/capacityExpansion1.png\" alt=\"capacityExpansion1\"></li>\n<li>将<strong>配置容量</strong>选择<strong>最大化</strong>，点击确定<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/capacityExpansion2.png\" alt=\"capacityExpansion2\"></li>\n<li>显示<strong>扩充文件系统中</strong><br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/capacityExpansion3.png\" alt=\"capacityExpansion3\"></li>\n<li>如图，扩充完成<br> <img src=\"/2019/07/14/qun-hui-wu-sun-kuo-chong-ying-pan-kong-jian-raid1/capacityExpansion4.png\" alt=\"capacityExpansion4\"></li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><ul>\n<li>群晖的raid1还是很方便好用的，只要换上硬盘相互备份即可。<em>(黑白晖都可直插无损修复扩展)</em></li>\n<li>群晖的系统我是装到硬盘里了。能让我这样直接抽盘换盘恢复备份，即说明，群晖的2.4G的系统分区也是在每个盘都有备份的。不管是哪个盘挂了，都能随意抽换恢复，体验很好。</li>\n<li><em>（<strong>在恢复过程中有不清楚的，可以评论或发邮件联系我</strong>）</em></li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/DIY笔记本收纳支架/assemble3.jpg","slug":"assemble3.jpg","post":"ck8lptigw0001bsfo5n91x2qi","modified":1,"renderable":0},{"_id":"source/_posts/DIY笔记本收纳支架/assemble4.jpg","slug":"assemble4.jpg","post":"ck8lptigw0001bsfo5n91x2qi","modified":1,"renderable":0},{"_id":"source/_posts/DIY笔记本收纳支架/drawAcrylicBoard.jpg","slug":"drawAcrylicBoard.jpg","post":"ck8lptigw0001bsfo5n91x2qi","modified":1,"renderable":0},{"_id":"source/_posts/DIY笔记本收纳支架/notebookStand.jpg","slug":"notebookStand.jpg","post":"ck8lptigw0001bsfo5n91x2qi","modified":1,"renderable":0},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5BackInner1.jpg","slug":"mi5BackInner1.jpg","post":"ck8lptihc000dbsfo8ooas79t","modified":1,"renderable":0},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5BackInner2.jpg","slug":"mi5BackInner2.jpg","post":"ck8lptihc000dbsfo8ooas79t","modified":1,"renderable":0},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5BackNewBattery2.jpg","slug":"mi5BackNewBattery2.jpg","post":"ck8lptihc000dbsfo8ooas79t","modified":1,"renderable":0},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5BackNewCoverGlue.jpg","slug":"mi5BackNewCoverGlue.jpg","post":"ck8lptihc000dbsfo8ooas79t","modified":1,"renderable":0},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5BackNewCover.jpg","slug":"mi5BackNewCover.jpg","post":"ck8lptihc000dbsfo8ooas79t","modified":1,"renderable":0},{"_id":"source/_posts/笔记本-K680e-改侧键开机/finishedProduct.jpg","slug":"finishedProduct.jpg","post":"ck8lptiho000pbsfo1ywgrbyo","modified":1,"renderable":0},{"_id":"source/_posts/笔记本-K680e-改侧键开机/mouse.jpg","slug":"mouse.jpg","post":"ck8lptiho000pbsfo1ywgrbyo","modified":1,"renderable":0},{"_id":"source/_posts/笔记本-K680e-改侧键开机/holdClickButton.jpg","slug":"holdClickButton.jpg","post":"ck8lptiho000pbsfo1ywgrbyo","modified":1,"renderable":0},{"_id":"source/_posts/笔记本-K680e-改侧键开机/safeHole.jpg","slug":"safeHole.jpg","post":"ck8lptiho000pbsfo1ywgrbyo","modified":1,"renderable":0},{"_id":"source/_posts/笔记本-K680e-改侧键开机/safeHoleButton.jpg","slug":"safeHoleButton.jpg","post":"ck8lptiho000pbsfo1ywgrbyo","modified":1,"renderable":0},{"_id":"source/_posts/笔记本-K680e-改侧键开机/safeHoleInner.jpg","slug":"safeHoleInner.jpg","post":"ck8lptiho000pbsfo1ywgrbyo","modified":1,"renderable":0},{"_id":"source/_posts/笔记本-K680e-改侧键开机/weldButton.jpg","slug":"weldButton.jpg","post":"ck8lptiho000pbsfo1ywgrbyo","modified":1,"renderable":0},{"_id":"source/_posts/DIY笔记本收纳支架/combinationOfDrilling.jpg","slug":"combinationOfDrilling.jpg","post":"ck8lptigw0001bsfo5n91x2qi","modified":1,"renderable":0},{"_id":"source/_posts/DIY笔记本收纳支架/supportForm1.jpg","slug":"supportForm1.jpg","post":"ck8lptigw0001bsfo5n91x2qi","modified":1,"renderable":0},{"_id":"source/_posts/DIY笔记本收纳支架/supportForm2.jpg","slug":"supportForm2.jpg","post":"ck8lptigw0001bsfo5n91x2qi","modified":1,"renderable":0},{"_id":"source/_posts/mi5魔改8000mAh大电池/battery.jpg","slug":"battery.jpg","post":"ck8lptihc000dbsfo8ooas79t","modified":1,"renderable":0},{"_id":"source/_posts/earphone1/earphone1.png","slug":"earphone1.png","post":"ck8lptih70009bsfo8q3ro8sp","modified":1,"renderable":0},{"_id":"source/_posts/gitNote/git.png","slug":"git.png","post":"ck8lptiha000absfo5fmkh6t0","modified":1,"renderable":0},{"_id":"source/_posts/安装Gitment及常见问题解决/gitmentConfig.png","post":"ck8lptihi000ibsfodadfz09p","slug":"gitmentConfig.png","modified":1,"renderable":1},{"_id":"source/_posts/安装Gitment及常见问题解决/gitmentConfiged.jpeg","post":"ck8lptihi000ibsfodadfz09p","slug":"gitmentConfiged.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5Back.jpg","post":"ck8lptihc000dbsfo8ooas79t","slug":"mi5Back.jpg","modified":1,"renderable":1},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5BackCover.jpg","post":"ck8lptihc000dbsfo8ooas79t","slug":"mi5BackCover.jpg","modified":1,"renderable":1},{"_id":"source/_posts/mi5魔改8000mAh大电池/mi5BackNewBattery.jpg","slug":"mi5BackNewBattery.jpg","post":"ck8lptihc000dbsfo8ooas79t","modified":1,"renderable":0},{"_id":"source/_posts/mi5魔改8000mAh大电池/tool.jpg","post":"ck8lptihc000dbsfo8ooas79t","slug":"tool.jpg","modified":1,"renderable":1},{"_id":"source/_posts/DIY笔记本收纳支架/assemble1.jpg","slug":"assemble1.jpg","post":"ck8lptigw0001bsfo5n91x2qi","modified":1,"renderable":0},{"_id":"source/_posts/DIY笔记本收纳支架/assemble2.jpg","slug":"assemble2.jpg","post":"ck8lptigw0001bsfo5n91x2qi","modified":1,"renderable":0},{"_id":"source/_posts/DIY笔记本收纳支架/cuttingAcrylicBoard.jpg","post":"ck8lptigw0001bsfo5n91x2qi","slug":"cuttingAcrylicBoard.jpg","modified":1,"renderable":1},{"_id":"source/_posts/DIY笔记本收纳支架/storageForm.jpg","slug":"storageForm.jpg","post":"ck8lptigw0001bsfo5n91x2qi","modified":1,"renderable":0},{"_id":"source/_posts/笔记本-K680e-改侧键开机/button.jpg","post":"ck8lptiho000pbsfo1ywgrbyo","slug":"button.jpg","modified":1,"renderable":1},{"_id":"source/_posts/笔记本-K680e-改侧键开机/clickButton.jpg","post":"ck8lptiho000pbsfo1ywgrbyo","slug":"clickButton.jpg","modified":1,"renderable":1},{"_id":"source/_posts/笔记本-K680e-改侧键开机/mouseButton.jpg","post":"ck8lptiho000pbsfo1ywgrbyo","slug":"mouseButton.jpg","modified":1,"renderable":1},{"_id":"source/_posts/笔记本-K680e-改侧键开机/safeHoleButton2.jpg","post":"ck8lptiho000pbsfo1ywgrbyo","slug":"safeHoleButton2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/笔记本-K680e-改侧键开机/safeHoleButtonInner.jpg","post":"ck8lptiho000pbsfo1ywgrbyo","slug":"safeHoleButtonInner.jpg","modified":1,"renderable":1},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Accessories1.jpg","slug":"TexYoda2Accessories1.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2AssemblyInstructions.jpg","slug":"TexYoda2AssemblyInstructions.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Box.jpg","slug":"TexYoda2Box.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Box2.jpg","slug":"TexYoda2Box2.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Feature1.jpg","slug":"TexYoda2Feature1.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Feature2.jpg","slug":"TexYoda2Feature2.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Feature3.jpg","post":"ck8lptihr000rbsfox3bghrbk","slug":"TexYoda2Feature3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Keycap.jpg","slug":"TexYoda2Keycap.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Pkg.jpg","slug":"TexYoda2Pkg.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2SatelliteAxis1.jpg","slug":"TexYoda2SatelliteAxis1.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2SatelliteAxis2.jpg","slug":"TexYoda2SatelliteAxis2.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Shell1.jpg","slug":"TexYoda2Shell1.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Shell2.jpg","slug":"TexYoda2Shell2.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Shell3.jpg","slug":"TexYoda2Shell3.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Shell4.jpg","slug":"TexYoda2Shell4.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Trackpoint1.jpg","slug":"TexYoda2Trackpoint1.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2Trackpoint2.jpg","slug":"TexYoda2Trackpoint2.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/组装小红点机械键盘-tex-yoda-2-定制键盘盖/TexYoda2night.jpg","slug":"TexYoda2night.jpg","post":"ck8lptihr000rbsfox3bghrbk","modified":1,"renderable":0},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/capacityExpansion1.png","post":"ck8lptiib001absfonxnljvi6","slug":"capacityExpansion1.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/capacityExpansion2.png","post":"ck8lptiib001absfonxnljvi6","slug":"capacityExpansion2.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/capacityExpansion3.png","post":"ck8lptiib001absfonxnljvi6","slug":"capacityExpansion3.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/capacityExpansion4.png","post":"ck8lptiib001absfonxnljvi6","slug":"capacityExpansion4.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne1.png","post":"ck8lptiib001absfonxnljvi6","slug":"restoreToNewHardDiskOne1.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne10.png","post":"ck8lptiib001absfonxnljvi6","slug":"restoreToNewHardDiskOne10.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne11.png","post":"ck8lptiib001absfonxnljvi6","slug":"restoreToNewHardDiskOne11.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne2.png","post":"ck8lptiib001absfonxnljvi6","slug":"restoreToNewHardDiskOne2.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne3.png","post":"ck8lptiib001absfonxnljvi6","slug":"restoreToNewHardDiskOne3.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne4.png","post":"ck8lptiib001absfonxnljvi6","slug":"restoreToNewHardDiskOne4.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne5.png","post":"ck8lptiib001absfonxnljvi6","slug":"restoreToNewHardDiskOne5.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne6.png","post":"ck8lptiib001absfonxnljvi6","slug":"restoreToNewHardDiskOne6.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne7.png","post":"ck8lptiib001absfonxnljvi6","slug":"restoreToNewHardDiskOne7.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne8.png","post":"ck8lptiib001absfonxnljvi6","slug":"restoreToNewHardDiskOne8.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskOne9.png","post":"ck8lptiib001absfonxnljvi6","slug":"restoreToNewHardDiskOne9.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskTwo1.png","post":"ck8lptiib001absfonxnljvi6","slug":"restoreToNewHardDiskTwo1.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskTwo2.png","post":"ck8lptiib001absfonxnljvi6","slug":"restoreToNewHardDiskTwo2.png","modified":1,"renderable":1},{"_id":"source/_posts/群晖无损扩充硬盘空间raid1/restoreToNewHardDiskTwo3.png","post":"ck8lptiib001absfonxnljvi6","slug":"restoreToNewHardDiskTwo3.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ck8lptigw0001bsfo5n91x2qi","category_id":"ck8lptih10004bsfo7ac42cnh","_id":"ck8lptihg000fbsfoaqns7z6w"},{"post_id":"ck8lptihc000dbsfo8ooas79t","category_id":"ck8lptih10004bsfo7ac42cnh","_id":"ck8lptihl000lbsfonr1wfhbi"},{"post_id":"ck8lptih00003bsfooj0p53kc","category_id":"ck8lptiha000bbsfoj51mr78e","_id":"ck8lptiho000qbsfoiphjl2n7"},{"post_id":"ck8lptih70009bsfo8q3ro8sp","category_id":"ck8lptihg000gbsfoaj6m1ym1","_id":"ck8lptiht000sbsfomvs7q7if"},{"post_id":"ck8lptiho000pbsfo1ywgrbyo","category_id":"ck8lptih10004bsfo7ac42cnh","_id":"ck8lptihx000ybsfot2n0jf5j"},{"post_id":"ck8lptiha000absfo5fmkh6t0","category_id":"ck8lptihn000nbsfoj8wj9chi","_id":"ck8lptii00011bsfomug74fgs"},{"post_id":"ck8lptihr000rbsfox3bghrbk","category_id":"ck8lptih10004bsfo7ac42cnh","_id":"ck8lptii40015bsfo69onu2ow"},{"post_id":"ck8lptihu000vbsfozxm3sl28","category_id":"ck8lptih10004bsfo7ac42cnh","_id":"ck8lptii70017bsfou0gdgh6o"},{"post_id":"ck8lptihf000ebsfo7law4ubq","category_id":"ck8lptiht000tbsfouhvvgjwl","_id":"ck8lptiib001bbsfo5ynxkxoz"},{"post_id":"ck8lptii00010bsfo7mbebbxq","category_id":"ck8lptihn000nbsfoj8wj9chi","_id":"ck8lptiif001dbsfocc5z78rl"},{"post_id":"ck8lptihi000ibsfodadfz09p","category_id":"ck8lptii00012bsfoknh7eoge","_id":"ck8lptiik001hbsfostmanqsc"},{"post_id":"ck8lptii70016bsfowyijtdi2","category_id":"ck8lptii00012bsfoknh7eoge","_id":"ck8lptiik001ibsfocktgaeh2"},{"post_id":"ck8lptiib001absfonxnljvi6","category_id":"ck8lptih10004bsfo7ac42cnh","_id":"ck8lptiil001lbsfo7b8ripk3"},{"post_id":"ck8lptihl000kbsfoya845ses","category_id":"ck8lptiht000tbsfouhvvgjwl","_id":"ck8lptiil001nbsfoq7fwxv2v"},{"post_id":"ck8lptihx000xbsfowiihbnqt","category_id":"ck8lptiif001fbsfof5atvvpg","_id":"ck8lptiim001pbsfoskuo1mfs"},{"post_id":"ck8lptii30014bsfo13drp35j","category_id":"ck8lptiik001jbsfon5r0nss2","_id":"ck8lptiim001rbsfokxv8u9me"}],"PostTag":[{"post_id":"ck8lptigw0001bsfo5n91x2qi","tag_id":"ck8lptih20005bsfo7p6dt3v2","_id":"ck8lptihj000jbsfo4xufn92p"},{"post_id":"ck8lptigw0001bsfo5n91x2qi","tag_id":"ck8lptiha000cbsfo59ea4r4m","_id":"ck8lptihm000mbsfoqj67un6j"},{"post_id":"ck8lptih00003bsfooj0p53kc","tag_id":"ck8lptihh000hbsfooad2actm","_id":"ck8lptihw000wbsfowbshe914"},{"post_id":"ck8lptih00003bsfooj0p53kc","tag_id":"ck8lptihn000obsfo2vxq4zks","_id":"ck8lptihz000zbsfoip07w0ey"},{"post_id":"ck8lptih70009bsfo8q3ro8sp","tag_id":"ck8lptiht000ubsfokxjk3oid","_id":"ck8lptiic001cbsfosn68dyn9"},{"post_id":"ck8lptih70009bsfo8q3ro8sp","tag_id":"ck8lptii00013bsfoq1waf9an","_id":"ck8lptiif001ebsfomanwosg4"},{"post_id":"ck8lptiha000absfo5fmkh6t0","tag_id":"ck8lptii80019bsfop09s3duy","_id":"ck8lptiil001mbsfo8plsu1xz"},{"post_id":"ck8lptiha000absfo5fmkh6t0","tag_id":"ck8lptiij001gbsfohua1y6pg","_id":"ck8lptiil001obsfol9hiaxr3"},{"post_id":"ck8lptihc000dbsfo8ooas79t","tag_id":"ck8lptiil001kbsfoupylnbl2","_id":"ck8lptiin001tbsfoifk1fcwb"},{"post_id":"ck8lptihc000dbsfo8ooas79t","tag_id":"ck8lptiim001qbsfoafjnxk0v","_id":"ck8lptiin001ubsfofabgbjwi"},{"post_id":"ck8lptihf000ebsfo7law4ubq","tag_id":"ck8lptiim001sbsforl4lo62x","_id":"ck8lptiip001ybsfoc7nwcn34"},{"post_id":"ck8lptihf000ebsfo7law4ubq","tag_id":"ck8lptiin001vbsfop925nzbw","_id":"ck8lptiip001zbsfo26rum6k9"},{"post_id":"ck8lptihf000ebsfo7law4ubq","tag_id":"ck8lptiio001wbsfoziuik6l8","_id":"ck8lptiip0021bsfotblse5k9"},{"post_id":"ck8lptihi000ibsfodadfz09p","tag_id":"ck8lptiio001xbsfo6pp5j8b2","_id":"ck8lptiiq0022bsfoay3junmo"},{"post_id":"ck8lptihl000kbsfoya845ses","tag_id":"ck8lptiip0020bsfowfwdpxv3","_id":"ck8lptiir0025bsforjzoct25"},{"post_id":"ck8lptihl000kbsfoya845ses","tag_id":"ck8lptiiq0023bsfohj6u0rhg","_id":"ck8lptiis0026bsfo6k65lf5q"},{"post_id":"ck8lptiho000pbsfo1ywgrbyo","tag_id":"ck8lptiha000cbsfo59ea4r4m","_id":"ck8lptiit0029bsfokfbdd2xg"},{"post_id":"ck8lptiho000pbsfo1ywgrbyo","tag_id":"ck8lptiiq0024bsfo4rsmpb3v","_id":"ck8lptiit002absfooq06qgfd"},{"post_id":"ck8lptiho000pbsfo1ywgrbyo","tag_id":"ck8lptiis0027bsfomu20nwuj","_id":"ck8lptiit002cbsfouz3s8dh1"},{"post_id":"ck8lptihr000rbsfox3bghrbk","tag_id":"ck8lptiit0028bsfotuvvv0ee","_id":"ck8lptiiu002fbsfo6zq7ycra"},{"post_id":"ck8lptihr000rbsfox3bghrbk","tag_id":"ck8lptiit002bbsfo2c2mwfu0","_id":"ck8lptiiu002gbsfofela7lm0"},{"post_id":"ck8lptihr000rbsfox3bghrbk","tag_id":"ck8lptiiu002dbsfob98qwyb0","_id":"ck8lptiiu002ibsfo50br1o6c"},{"post_id":"ck8lptihu000vbsfozxm3sl28","tag_id":"ck8lptiha000cbsfo59ea4r4m","_id":"ck8lptiiv002jbsfoawgvvc7g"},{"post_id":"ck8lptihu000vbsfozxm3sl28","tag_id":"ck8lptiiu002ebsfororyu46x","_id":"ck8lptiiv002lbsfohgjiip8z"},{"post_id":"ck8lptihx000xbsfowiihbnqt","tag_id":"ck8lptiiu002hbsfoghmmr5vn","_id":"ck8lptiiv002obsfo4r5fqtr0"},{"post_id":"ck8lptihx000xbsfowiihbnqt","tag_id":"ck8lptiiv002kbsfofuz1q39e","_id":"ck8lptiiv002pbsfoa028l0jt"},{"post_id":"ck8lptihx000xbsfowiihbnqt","tag_id":"ck8lptiiv002mbsfoiijx9ejg","_id":"ck8lptiiw002rbsfou65ldxl3"},{"post_id":"ck8lptii00010bsfo7mbebbxq","tag_id":"ck8lptiiv002nbsfo5p9uqs16","_id":"ck8lptiiw002tbsfo36qzdrm1"},{"post_id":"ck8lptii00010bsfo7mbebbxq","tag_id":"ck8lptiiw002qbsfocvcwutne","_id":"ck8lptiiw002ubsfob1fmiqy8"},{"post_id":"ck8lptii30014bsfo13drp35j","tag_id":"ck8lptiiw002sbsfohjdx8nuk","_id":"ck8lptiix002ybsfopsoo3x3w"},{"post_id":"ck8lptii30014bsfo13drp35j","tag_id":"ck8lptiiw002vbsfoblkjyj60","_id":"ck8lptiix002zbsfo3muwbbjw"},{"post_id":"ck8lptii30014bsfo13drp35j","tag_id":"ck8lptiix002wbsfotf38mc5w","_id":"ck8lptiix0031bsfoj3z8y4kj"},{"post_id":"ck8lptii70016bsfowyijtdi2","tag_id":"ck8lptiix002xbsfonc36tuc4","_id":"ck8lptiiy0033bsfotgf34hck"},{"post_id":"ck8lptii70016bsfowyijtdi2","tag_id":"ck8lptiix0030bsfohum2cpyy","_id":"ck8lptiiy0034bsfohdxwkfav"},{"post_id":"ck8lptiib001absfonxnljvi6","tag_id":"ck8lptiip0020bsfowfwdpxv3","_id":"ck8lptiiz0037bsfo3pbluje2"},{"post_id":"ck8lptiib001absfonxnljvi6","tag_id":"ck8lptiiy0035bsfo0xcytlic","_id":"ck8lptiiz0038bsfoue6oh8kc"},{"post_id":"ck8lptiib001absfonxnljvi6","tag_id":"ck8lptiiy0036bsfoquyqz37s","_id":"ck8lptiiz0039bsfoky2cknhr"}],"Tag":[{"name":"支架","_id":"ck8lptih20005bsfo7p6dt3v2"},{"name":"笔记本","_id":"ck8lptiha000cbsfo59ea4r4m"},{"name":"VScode","_id":"ck8lptihh000hbsfooad2actm"},{"name":"Q&A","_id":"ck8lptihn000obsfo2vxq4zks"},{"name":"hand painted","_id":"ck8lptiht000ubsfokxjk3oid"},{"name":"earphone","_id":"ck8lptii00013bsfoq1waf9an"},{"name":"git","_id":"ck8lptii80019bsfop09s3duy"},{"name":"note","_id":"ck8lptiij001gbsfohua1y6pg"},{"name":"手机","_id":"ck8lptiil001kbsfoupylnbl2"},{"name":"电池","_id":"ck8lptiim001qbsfoafjnxk0v"},{"name":"nohup","_id":"ck8lptiim001sbsforl4lo62x"},{"name":"screen","_id":"ck8lptiin001vbsfop925nzbw"},{"name":"后台运行程序","_id":"ck8lptiio001wbsfoziuik6l8"},{"name":"Gitment","_id":"ck8lptiio001xbsfo6pp5j8b2"},{"name":"群晖Synology","_id":"ck8lptiip0020bsfowfwdpxv3"},{"name":"抢救系统","_id":"ck8lptiiq0023bsfohj6u0rhg"},{"name":"diy","_id":"ck8lptiiq0024bsfo4rsmpb3v"},{"name":"改侧开机键","_id":"ck8lptiis0027bsfomu20nwuj"},{"name":"小红点","_id":"ck8lptiit0028bsfotuvvv0ee"},{"name":"yex yoda 2","_id":"ck8lptiit002bbsfo2c2mwfu0"},{"name":"定制键盘盖","_id":"ck8lptiiu002dbsfob98qwyb0"},{"name":"内存条","_id":"ck8lptiiu002ebsfororyu46x"},{"name":"Unity","_id":"ck8lptiiu002hbsfoghmmr5vn"},{"name":"Android","_id":"ck8lptiiv002kbsfofuz1q39e"},{"name":"Export","_id":"ck8lptiiv002mbsfoiijx9ejg"},{"name":"视频编码","_id":"ck8lptiiv002nbsfo5p9uqs16"},{"name":"视频封装","_id":"ck8lptiiw002qbsfocvcwutne"},{"name":"面向对象","_id":"ck8lptiiw002sbsfohjdx8nuk"},{"name":"事件驱动","_id":"ck8lptiiw002vbsfoblkjyj60"},{"name":"GUI编程","_id":"ck8lptiix002wbsfotf38mc5w"},{"name":"花牌","_id":"ck8lptiix002xbsfonc36tuc4"},{"name":"统计","_id":"ck8lptiix0030bsfohum2cpyy"},{"name":"raid1","_id":"ck8lptiiy0035bsfo0xcytlic"},{"name":"无损扩容","_id":"ck8lptiiy0036bsfoquyqz37s"}]}}